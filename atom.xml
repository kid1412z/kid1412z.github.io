<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Q.Y Zuo Believes]]></title>
  <subtitle><![CDATA[Qiyang Zuo's Blog]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zuoqy.com/"/>
  <updated>2018-10-29T16:23:57.653Z</updated>
  <id>http://zuoqy.com/</id>
  
  <author>
    <name><![CDATA[Qiyang Zuo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Kubernates2 基本概念]]></title>
    <link href="http://zuoqy.com/2018/10/29/Kubernates2-essential-concept/"/>
    <id>http://zuoqy.com/2018/10/29/Kubernates2-essential-concept/</id>
    <published>2018-10-29T14:39:15.000Z</published>
    <updated>2018-10-29T16:23:57.653Z</updated>
    <content type="html"><![CDATA[<h2 id="要解决什么问题">要解决什么问题</h2><p>可以方便的将用户应用的镜像部署到集群，并提供路由网关、水平扩展、监控、备份灾难恢复等一系列运维能力。这些问题，其实一个PAAS平台都可以解决。</p>
<p>除了解决以上问题，Kubernates项目区别于其他PAAS平台，重点要解决的问题，来自于Borg项目的研究人员在论文中的一个重要观点：</p>
<blockquote>
<p>运行在大规模集群中的各个任务之间，存在着各种各样的关系。这些关系的处理，才是作业编排和管理系统最困难的地方。</p>
</blockquote>
<h2 id="需要什么样的架构">需要什么样的架构</h2><ul>
<li>节点分为控制节点Master和计算节点Node</li>
<li>Master节点包含kube-controller, kube-api-server 和 kube-scheduler三个组件</li>
<li>Node节点中的核心组件kubelet：<ul>
<li>通过CNI(Container Networking Interface)与网络插件交互，配置容器网络；</li>
<li>通过CSI(Container Storage Interface)与存储插件交互，配置持久化存储；</li>
<li>通过CRI（Container Runtime Interface）与容器运行时交互，定义容器运行时的各项操作。</li>
<li>容器运行时通过OCI容器运行时规范，与Linux操作系统交互。<a id="more"></a>
</li>
</ul>
</li>
</ul>
<p><img src="http://zuoqy.com/images/2018-10-29/1.png" alt="1"></p>
<p>其控制节点的架构理论，参考Google内部系统Borg</p>
<p><img src="http://zuoqy.com/images/2018-10-29/2.png" alt="2"></p>
<p>Kubernates项目的设计思想，就是从更宏观的角度，以统一的方式来定义任务之间的各种关系，并未将来支持更多类型的关系留有余地。</p>
<p>如果应用内部各个子服务之间的依赖关系不复杂，则用Swarm+Compose的方式完全可以解决。在Compose文件中，经常会出现类似这样的编排配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DB_NAME=/web/db</span><br><span class="line">DB_PORT=tcp://<span class="number">172.17</span>.<span class="number">0.5</span>:<span class="number">5432</span></span><br><span class="line">DB_PORT_5432_TCP=tcp://<span class="number">172.17</span>.<span class="number">0.5</span>:<span class="number">5432</span></span><br><span class="line">DB_PORT_5432_TCP_PROTO=tcp</span><br><span class="line">DB_PORT_5432_TCP_PORT=<span class="number">5432</span></span><br><span class="line">DB_PORT_5432_TCP_ADDR=<span class="number">172.17</span>.<span class="number">0.5</span></span><br></pre></td></tr></table></figure>
<p>对应子系统之间依赖负责的应用，例如：有的子服务需要部署在同一台机器上（例如需要本地进程间通信，如<a href="http://zuoqy.com/2018/10/07/Pattern-Service-Mesh/" target="_blank" rel="external">Service Mesh</a>），有的需要安排在不同的机器上(如web服务和DB)。</p>
<p>此时，Kubernates的设计理念就派上了用场。Kubernates以Pod为核心，抽象出了处理容器间关系的各种上层对象，如下图所示：</p>
<p><img src="http://zuoqy.com/images/2018-10-29/3.png" alt="3"></p>
<p>例如，容器间需要紧密协作，则需要Pod；容器间需要访问授权，则由Secret对象来完成等等。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://malteschwarzkopf.de/research/assets/google-stack.pdf" target="_blank" rel="external">http://malteschwarzkopf.de/research/assets/google-stack.pdf</a></li>
<li><a href="https://time.geekbang.org/column/article/23132" target="_blank" rel="external">https://time.geekbang.org/column/article/23132</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="要解决什么问题">要解决什么问题</h2><p>可以方便的将用户应用的镜像部署到集群，并提供路由网关、水平扩展、监控、备份灾难恢复等一系列运维能力。这些问题，其实一个PAAS平台都可以解决。</p>
<p>除了解决以上问题，Kubernates项目区别于其他PAAS平台，重点要解决的问题，来自于Borg项目的研究人员在论文中的一个重要观点：</p>
<blockquote>
<p>运行在大规模集群中的各个任务之间，存在着各种各样的关系。这些关系的处理，才是作业编排和管理系统最困难的地方。</p>
</blockquote>
<h2 id="需要什么样的架构">需要什么样的架构</h2><ul>
<li>节点分为控制节点Master和计算节点Node</li>
<li>Master节点包含kube-controller, kube-api-server 和 kube-scheduler三个组件</li>
<li>Node节点中的核心组件kubelet：<ul>
<li>通过CNI(Container Networking Interface)与网络插件交互，配置容器网络；</li>
<li>通过CSI(Container Storage Interface)与存储插件交互，配置持久化存储；</li>
<li>通过CRI（Container Runtime Interface）与容器运行时交互，定义容器运行时的各项操作。</li>
<li>容器运行时通过OCI容器运行时规范，与Linux操作系统交互。]]>
    
    </summary>
    
      <category term="kubernates" scheme="http://zuoqy.com/tags/kubernates/"/>
    
      <category term="Cloud Compute" scheme="http://zuoqy.com/categories/Cloud-Compute/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何有效地沟通]]></title>
    <link href="http://zuoqy.com/2018/10/17/communicate-effectively/"/>
    <id>http://zuoqy.com/2018/10/17/communicate-effectively/</id>
    <published>2018-10-17T14:28:03.000Z</published>
    <updated>2018-10-17T15:03:43.027Z</updated>
    <content type="html"><![CDATA[<p>在吴军老师新书《态度》写给其女儿一封信中，提到了如何有效地沟通：</p>
<p><strong>第一，有效的沟通要以对方确认为准，不要以为话说出去，别人就一定能接收了你传递的信息。</strong><br>（那么反过来，自己要做到对别人来讲”靠谱”，就是”凡事有交代，件件有着落，事事有回应。”）</p>
<p><strong>第二，要以对方听得懂的话来沟通，不要把简单的问题讲复杂了。</strong> 这里作者举了一个很好的例子：</p>
<blockquote>
<p>中国的顾维钧先生是一个优秀的外交家，他在1919年的巴黎和会上向西方国家的代表讲述山东省对中国的重要性时，是这样说的：<br>孔子对中国人来说，相当于耶稣对西方人一样重要。西方人一直把耶路撒冷作为圣地，并且上千年一直要夺回那个地方。<br>山东是孔子的出生地，它在中国人心中的地位，相当于耶路撒冷在西方人心中的地位。</p>
</blockquote>
<p>简单的几句话，就把意思说明白了。对方能听懂，不是因为对山东和孔子有多么熟悉，而是因为熟知耶路撒冷和耶稣。</p>
<p><strong>第三，沟通要简洁，切中要害。对不同的人，表达方式也不一样。</strong></p>
<p><strong>第四，善辩不等于好的沟通，沟通的目的是让对方接受自己的想法，而非把对方驳得哑口无言。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在吴军老师新书《态度》写给其女儿一封信中，提到了如何有效地沟通：</p>
<p><strong>第一，有效的沟通要以对方确认为准，不要以为话说出去，别人就一定能接收了你传递的信息。</strong><br>（那么反过来，自己要做到对别人来讲”靠谱”，就是”凡事有交代，件件有]]>
    </summary>
    
      <category term="Reading" scheme="http://zuoqy.com/tags/Reading/"/>
    
      <category term="态度" scheme="http://zuoqy.com/tags/%E6%80%81%E5%BA%A6/"/>
    
      <category term="沟通" scheme="http://zuoqy.com/tags/%E6%B2%9F%E9%80%9A/"/>
    
      <category term="Reading" scheme="http://zuoqy.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pattern Service Mesh]]></title>
    <link href="http://zuoqy.com/2018/10/07/Pattern-Service-Mesh/"/>
    <id>http://zuoqy.com/2018/10/07/Pattern-Service-Mesh/</id>
    <published>2018-10-07T06:25:57.000Z</published>
    <updated>2018-10-09T16:47:41.024Z</updated>
    <content type="html"><![CDATA[<h2 id="当网络刚刚出现">当网络刚刚出现</h2><p>当人们刚想到让两台计算机通信，模型是这样的：</p>
<p><img src="http://zuoqy.com/images/2018-10-07/1.png" alt="1"></p>
<p>但上面过于简单的建模，无法使任意两台计算机之间的通信变得通用。分层的网络协议，使应用之间的通信时，应用本身不用关心网络的底层细节，例如如何拆包粘包，如何将字节序列转化成电信号等等。</p>
<p><img src="http://zuoqy.com/images/2018-10-07/2.png" alt="2"></p>
<p>上面的模型依然存在问题，因为应用A在向B发送请求和数据包时，并不知道B是否能处理过来，如果B不能及时处理网络包，则会丢失数据。因此应用除了业务逻辑之外，还需要有专门的模块控制数据包的发送速度。</p>
<p><img src="http://zuoqy.com/images/2018-10-07/3.png" alt="3"></p>
<p>幸运的是TCP/IP传输层协议的出现，从底层解决了流量控制和拥塞避免的问题，实现了可靠传输。</p>
<p><img src="http://zuoqy.com/images/2018-10-07/4.png" alt="4"></p>
<p>上面的模型也成功的沿用了很长一段时间。</p>
<h2 id="微服务出现">微服务出现</h2><p>随后计算机逐渐变得便宜，出现了更多的节点和更可靠的网络连接。业界开始使用各种类型的网络系统，出现了更细粒度的分布式agent和面向服务的体系架构（SOA，Service Oriented Architectures）但依旧较重的服务组件。</p>
<p>90年代，Peter Deutsch和他的同事共同提出了<em>有关分布式系统的8条错误假设</em>(<a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" target="_blank" rel="external">The 8 Fallacies of Distributed Computing</a>):</p>
<ul>
<li>网络是可靠的</li>
<li>没有延迟</li>
<li>带宽无限大</li>
<li>网络是安全的</li>
<li>网络拓扑不会改变</li>
<li>只有一个管理员</li>
<li>传输成本是0</li>
<li>网络是同构的</li>
</ul>
<a id="more"></a>
<p>这8条谬误，是为了提醒分布式系统的工程师们，不能简单忽视上面的问题，需要显式的处理它们。在分布式系统或者说微服务框架体系下，我们至少需要做以下事情：</p>
<ul>
<li>快速配置计算资源</li>
<li>基本的监控系统</li>
<li>快速的部署</li>
<li>易于配置的存储系统</li>
<li>轻松的访问边缘节点</li>
<li>权限验证和授权</li>
<li>标准RPC协议</li>
</ul>
<p>虽然TCP/IP协议和和通用的网络模型，仍然起到了很大的作用，但现如今，更智能的微服务架构模型需要新的服务层。例如服务发现（Service Discovery）和断路器(Circuit Breaker)。</p>
<p><img src="http://zuoqy.com/images/2018-10-07/5.png" alt="5"></p>
<p><a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="external">Martin Fowler这样概括断路器</a>：</p>
<blockquote>
<p>The basic idea behind the circuit breaker is very simple. You wrap a protected function call in a circuit breaker object, which monitors for failures. Once the failures reach a certain threshold, the circuit breaker trips, and all further calls to the circuit breaker return with an error, without the protected call being made at all. Usually you’ll also want some kind of monitor alert if the circuit breaker trips.</p>
</blockquote>
<p>像断路器这样的简单装置，可以为服务之间的交互提供可靠性保证。（个人使用过Netflix公司的<a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">Hystrix</a>）即便如此，随着分布式系统规模的增长，某个组件出问题的可能性也成指数级增加。在一个庞大系统中的某个组件出问题，可能导致其客户端以及客户端的客户端相继发生断路。</p>
<p><strong>在过去需要几行代码搞定的东西，现在需要在各个client端重复模板代码来处理断路逻辑</strong></p>
<p>如果你使用过Hystrix，则你一定知道，你的代码中将大量包含类似:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandMayFailure</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommandMayFailure</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Setter</span><br><span class="line">            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"SystemX"</span>))</span><br><span class="line">            .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"SecondaryCommand"</span>))</span><br><span class="line">            .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"SecondaryCommand"</span>))</span><br><span class="line">            .andCommandPropertiesDefaults(</span><br><span class="line">                    <span class="comment">// we default to a 100ms timeout for secondary</span></span><br><span class="line">                    HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(<span class="number">100</span>)));</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"this command always fails"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Failure "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些样板代码往往需要设置线程池大小，断路器的失败阈值，超时时间，失败时的fallback逻辑等等。他们会遍布整个分布式系统的每个服务，他们与主要业务逻辑无关，大部分都是相同的。是不是很烦？</p>
<p>实际上，Facebook的<a href="https://code.fb.com/networking-traffic/introducing-proxygen-facebook-s-c-http-framework/" target="_blank" rel="external">Proxygen</a>和Twitter的<a href="https://finagle.github.io/blog/" target="_blank" rel="external">Finagle</a>这样的类库，意在避免这样的模板代码。</p>
<p><img src="http://zuoqy.com/images/2018-10-07/6.png" alt="6"></p>
<p>上图描述了像Netflix、SoundCloud、Twitter这样的微服务先驱的微服务架构。</p>
<p>把断路器和服务发现下沉到类库中，有以下几个缺点：</p>
<ul>
<li>团队需要有专门的人力和时间，为适配这种类库构建生态系统</li>
<li>类库限制了你在微服务中使用什么样的工具、运行时环境和开发语言</li>
<li>在庞大分布式系统中，使用上述类库模型，类库本身也需要维护，版本适配将非常复杂。</li>
</ul>
<h2 id="Sidecar">Sidecar</h2><p>对比分层的网络协议栈，我们更希望断路和服务发现作为一个服务层（如下图所示），屏蔽底层的逻辑，对应用透明。但更改网络协议栈短期内是没有可能的事情。</p>
<p><img src="http://zuoqy.com/images/2018-10-07/7.png" alt="7"></p>
<p>有些将这个服务层实现成一个代理应用（Proxy），服务之间不直接相互调用，而是将流量直接打到代理上，由代理做服务发现和路由。</p>
<p>这里衍生出的一个重要概念，就是<strong>Sidecars</strong>。<strong>Sidecar</strong>是和主应用进程相伴运行的进程，用来为主应用进程提供额外的功能特性。这里可以参见<a href="https://medium.com/airbnb-engineering/smartstack-service-discovery-in-the-cloud-4b8a080de619" target="_blank" rel="external">AirBnb</a>和<a href="https://medium.com/netflix-techblog/prana-a-sidecar-for-your-netflix-paas-based-applications-and-services-258a5790a015" target="_blank" rel="external">Netflix</a>的两篇有关Sidecar的文章。</p>
<p><img src="http://zuoqy.com/images/2018-10-07/8.png" alt="8"></p>
<h2 id="Service_Mesh">Service Mesh</h2><p>如果你的微服务系统中各个应用间通过Sidecar proxy相互调用，则你的部署图可能是下图这样的：</p>
<p><img src="http://zuoqy.com/images/2018-10-07/9.png" alt="9"></p>
<p>2017年William在文章中这样定义<strong>Service Mesh</strong>:</p>
<blockquote>
<p>A service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the service mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware.</p>
</blockquote>
<p>而这套机制，已经在先进的PaaS运行时环境Kubernates和Mesos完美支持：</p>
<p><img src="http://zuoqy.com/images/2018-10-07/10.png" alt="10"></p>
<p>最近火爆的项目<em><a href="https://istio.io/" target="_blank" rel="external">Istio project</a></em>则是Service Mesh系统的重要实例。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://philcalcado.com/2017/08/03/pattern_service_mesh.html" target="_blank" rel="external">http://philcalcado.com/2017/08/03/pattern_service_mesh.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" target="_blank" rel="external">https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing</a></li>
<li><a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="external">https://martinfowler.com/bliki/CircuitBreaker.html</a></li>
<li><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">https://github.com/Netflix/Hystrix</a></li>
<li><a href="https://code.fb.com/networking-traffic/introducing-proxygen-facebook-s-c-http-framework/" target="_blank" rel="external">https://code.fb.com/networking-traffic/introducing-proxygen-facebook-s-c-http-framework/</a></li>
<li><a href="https://finagle.github.io/blog/" target="_blank" rel="external">https://finagle.github.io/blog/</a></li>
<li><a href="https://medium.com/airbnb-engineering/smartstack-service-discovery-in-the-cloud-4b8a080de619" target="_blank" rel="external">https://medium.com/airbnb-engineering/smartstack-service-discovery-in-the-cloud-4b8a080de619</a></li>
<li><a href="https://medium.com/netflix-techblog/prana-a-sidecar-for-your-netflix-paas-based-applications-and-services-258a5790a015" target="_blank" rel="external">https://medium.com/netflix-techblog/prana-a-sidecar-for-your-netflix-paas-based-applications-and-services-258a5790a015</a></li>
<li><a href="https://istio.io/" target="_blank" rel="external">https://istio.io/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="当网络刚刚出现">当网络刚刚出现</h2><p>当人们刚想到让两台计算机通信，模型是这样的：</p>
<p><img src="http://zuoqy.com/images/2018-10-07/1.png" alt="1"></p>
<p>但上面过于简单的建模，无法使任意两台计算机之间的通信变得通用。分层的网络协议，使应用之间的通信时，应用本身不用关心网络的底层细节，例如如何拆包粘包，如何将字节序列转化成电信号等等。</p>
<p><img src="http://zuoqy.com/images/2018-10-07/2.png" alt="2"></p>
<p>上面的模型依然存在问题，因为应用A在向B发送请求和数据包时，并不知道B是否能处理过来，如果B不能及时处理网络包，则会丢失数据。因此应用除了业务逻辑之外，还需要有专门的模块控制数据包的发送速度。</p>
<p><img src="http://zuoqy.com/images/2018-10-07/3.png" alt="3"></p>
<p>幸运的是TCP/IP传输层协议的出现，从底层解决了流量控制和拥塞避免的问题，实现了可靠传输。</p>
<p><img src="http://zuoqy.com/images/2018-10-07/4.png" alt="4"></p>
<p>上面的模型也成功的沿用了很长一段时间。</p>
<h2 id="微服务出现">微服务出现</h2><p>随后计算机逐渐变得便宜，出现了更多的节点和更可靠的网络连接。业界开始使用各种类型的网络系统，出现了更细粒度的分布式agent和面向服务的体系架构（SOA，Service Oriented Architectures）但依旧较重的服务组件。</p>
<p>90年代，Peter Deutsch和他的同事共同提出了<em>有关分布式系统的8条错误假设</em>(<a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">The 8 Fallacies of Distributed Computing</a>):</p>
<ul>
<li>网络是可靠的</li>
<li>没有延迟</li>
<li>带宽无限大</li>
<li>网络是安全的</li>
<li>网络拓扑不会改变</li>
<li>只有一个管理员</li>
<li>传输成本是0</li>
<li>网络是同构的</li>
</ul>]]>
    
    </summary>
    
      <category term="Cloud Compute" scheme="http://zuoqy.com/tags/Cloud-Compute/"/>
    
      <category term="Distributing System" scheme="http://zuoqy.com/tags/Distributing-System/"/>
    
      <category term="Service Mesh" scheme="http://zuoqy.com/tags/Service-Mesh/"/>
    
      <category term="Distributing System, Service Mesh" scheme="http://zuoqy.com/categories/Distributing-System-Service-Mesh/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件设计的哲学（John Ousterhout分享）]]></title>
    <link href="http://zuoqy.com/2018/10/06/A-Philosophy-of-Software-Design/"/>
    <id>http://zuoqy.com/2018/10/06/A-Philosophy-of-Software-Design/</id>
    <published>2018-10-06T14:37:57.000Z</published>
    <updated>2018-10-09T16:47:41.024Z</updated>
    <content type="html"><![CDATA[<h2 id="软件设计的目标">软件设计的目标</h2><ol>
<li><p>软件设计最大的目标是降低软件的复杂性（Complexity），复杂性使软件难于理解和维护。</p>
</li>
<li><p>复杂性的来源：</p>
<ul>
<li>含义模糊（Obscurity）： 重要信息不突出。</li>
<li>相互依赖：模块无法独立于其他模块而被理解。</li>
</ul>
</li>
<li><p>复杂性的危害</p>
</li>
</ol>
<p>复杂性会逐渐递增，前面埋的坑，会导致后面的设计越来越复杂。</p>
<h2 id="设计原则">设计原则</h2><h3 id="暴露简单通用的接口，隐藏复杂的实现。">暴露简单通用的接口，隐藏复杂的实现。</h3><a id="more"></a>
<p><img src="http://zuoqy.com/images/2018-10-06/1.png" alt="Class should go deep"> </p>
<p>正例：Unix 文件I/O 接口</p>
<ul>
<li>Unix文件操作逻辑极为复杂，但前端模块只暴露的5个简单的接口。</li>
<li>隐藏了文件在磁盘上的表现形式、块分配、目录管理、权限管理、磁盘调度、块缓存和设备信息等复杂的底层内容。</li>
</ul>
<p><img src="http://zuoqy.com/images/2018-10-06/2.png" alt="A deep interface"> </p>
<p>反例：Java文件操作接口，读写一个文件要客户端感知很多类和细节：</p>
<p><img src="http://zuoqy.com/images/2018-10-06/3.png" alt="A deep interface cont&#39;d"> </p>
<h3 id="模块外部需要感知和必须处理的异常越少越好：">模块外部需要感知和必须处理的异常越少越好：</h3><p><img src="http://zuoqy.com/images/2018-10-06/4.png" alt="minimize exceptions outside"> </p>
<h3 id="注重设计_vs-_注重速度">注重设计 vs. 注重速度</h3><p>如果目标是尽快把feature作完，把bug都fix掉，最终导致的结果就是设计缺陷，越来越复杂。</p>
<p><img src="http://zuoqy.com/images/2018-10-06/5.png" alt="tactical"> </p>
<p>如果初始有一个良好的设计，则在后面的迭代中形成良性循环，最小化复杂性。长远看来则节省了很多时间。</p>
<p><img src="http://zuoqy.com/images/2018-10-06/6.png" alt="strategy"> </p>
<p>Facebook由最初的口号”Move quickly and break things”转变为”Move quickly with solid infrastructure”<br>Google和VMWare由于注重设计而成功，吸引了大量顶级工程师。</p>
<p><img src="http://zuoqy.com/images/2018-10-06/7.png" alt="invest"> </p>
<p>持续的在设计上的小投入，最终换来巨大回报。</p>
<p><img src="http://zuoqy.com/images/2018-10-06/8.png" alt="invest"> </p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=bmSAYlu0NcY" target="_blank" rel="external">https://www.youtube.com/watch?v=bmSAYlu0NcY</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="软件设计的目标">软件设计的目标</h2><ol>
<li><p>软件设计最大的目标是降低软件的复杂性（Complexity），复杂性使软件难于理解和维护。</p>
</li>
<li><p>复杂性的来源：</p>
<ul>
<li>含义模糊（Obscurity）： 重要信息不突出。</li>
<li>相互依赖：模块无法独立于其他模块而被理解。</li>
</ul>
</li>
<li><p>复杂性的危害</p>
</li>
</ol>
<p>复杂性会逐渐递增，前面埋的坑，会导致后面的设计越来越复杂。</p>
<h2 id="设计原则">设计原则</h2><h3 id="暴露简单通用的接口，隐藏复杂的实现。">暴露简单通用的接口，隐藏复杂的实现。</h3>]]>
    
    </summary>
    
      <category term="Software Design" scheme="http://zuoqy.com/tags/Software-Design/"/>
    
      <category term="Software Design" scheme="http://zuoqy.com/categories/Software-Design/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kubernates学习笔记01: 一点历史]]></title>
    <link href="http://zuoqy.com/2018/10/02/Kubernates1-Some-History/"/>
    <id>http://zuoqy.com/2018/10/02/Kubernates1-Some-History/</id>
    <published>2018-10-02T14:02:34.000Z</published>
    <updated>2018-10-09T16:47:41.024Z</updated>
    <content type="html"><![CDATA[<h2 id="1">1</h2><p>2013年，作为云计算PaaS热潮中的一份子，dotCloud相比于OpenStack、 Cloud Foundry、Heroku、Pivotal、RedHat似乎有些微不足道。</p>
<p>Cloud Foundry的开源PaaS项目，代表了当时PaaS技术的事实标准，被广泛接纳。它提供了一种”应用托管”能力，通过提供简单的命令，使开发者可以方便的将应用”上云”, 例如：<code>cf push &quot;my_app&quot;</code>其核心是应用的打包和分发。Cloud Foundry为每种主流语言都定义了一种打包格式， <code>cf push</code>的作用，就是将应用包、启动脚本上传到云端，通过调度器选择一批应用的虚拟机，<br>将脚本和应用包分发到机器上并启动执行。一个虚拟机上，往往启动多个来自不同用户的应用，PaaS平台会调用操作系统的Cgroups和Namespace机制，为每个应用单独创建隔离环境。<br>实现多个租户之间互不干涉的在虚拟机中部署和执行应用。整个过程就是PaaS项目最核心的能力。所谓的隔离环境，就是现在的容器技术。</p>
<p>在dotCloud公司开源自己的Docker项目之前，容器技术作为PaaS底层机制，并没有太多人关注。可就在开源后的短短几个月时间，Docker项目就迅速崛起，席卷了整个PaaS社区，改变了整个云计算领域的发展历程。</p>
<p>Docker项目区别于传统PaaS项目的秘密武器就是Docker镜像。如前面所述，当时PaaS项目的痛点就是用用的打包分发，用户需要为每一种语言、每一个应用维护一个打好的包，很难保持本地环境和云端环境的一致性。</p>
<p>Docker镜像的出现，从根本上解决了应用打包分发的问题：相比PaaS应用的压缩包只包含启动脚本加应用执行文件，Docker镜像则直接包含一个完整的操作系统所有文件和目录和应用启动的所有文件和脚本。轻松的保持了本地和云端环境的高度一致。<br>使用<code>docker build</code>、 <code>docker push</code> 和 <code>docker run</code> 即可将应用本地环境完整一致的打包推送到云端运行。</p>
<p>另外，Docker项目还对开发者有者天然的亲和力，开发者无需精通Linux内核原理和太多其他知识，就可以打包定制自己的镜像。简单的几个命令，就可以构建一个网站镜像，一个Nginx集群。深受开发者的欢迎。</p>
<p>Docker项目，重新定义了PaaS，使其演变为以Docker容器为核心，以Docker镜像为打包标准的”容器化”的PaaS。</p>
<h2 id="2">2</h2><p>随着Docker项目的崛起，dotCloud公司也将自己的公司名字改为Docker，并且不甘于仅仅提供创建和启停容器的小工具，希望提供更多平台层的能力，向PaaS进化。</p>
<p>2014年底，Docker公司发布Swarm，展示了Docker公司PaaS方向的野心。Swarm项目的最大亮点，就是它基本保持了单机部署和集群部署API的一致性，操作方式简单明了，受到众多开发者的热捧。（当时在公司的容器控制项目依赖Swarm也是基于这个原因）。</p>
<p>随后，Docker公司收购了率先提出”容器编排”(Container Orchestration)概念的<a href="http://www.fig.sh/" target="_blank" rel="external">Fig项目</a>(后来改名为Compose)。一时间，容器生态相关的项目层出不穷：容器网络处理SocketPlane项目（后被Docker公司收购），容器存储Flocker项目（后被EMC公司收购）， 集群图形化管理Tutum项目(被Docker公司收购)等。</p>
<p>2014年6月，Google开源名为Kubernates的项目，再一次改变了容器市场的格局。</p>
<h2 id="3">3</h2><p>为了限制Docker公司在Docker开源项目中的绝对话语权和强势态度，以及Docker项目在告诉迭代中表现出的不稳定和频繁变更问题，2015年6月，Docker公司、CoreOS、Google、RedHat共同宣布将Libcontainer（Containerd）项目捐出，改名为RunC，交由完全中立的基金会管理，并以其为依据，共同制定标准和规范，即OCI（Open Container Initiative）. </p>
<p>然而OCI的成立，并没有改变Docker公司一家独大的现状。随后，Google、RedHat牵头发起名为CNCF（Cloud Native Computing Foundation)的基金会。希望以Kubernates项目为基础，建立开源基础设施领域厂商主导的、按照独立基金会方式运营的平台级社区。</p>
<p>在容器编排方面，RedHat与Google结盟，打造出了一个与众不同的容器编排和管理生态。并在整个社区推进民主化架构。与Docker社区和Mesos社区形成三足鼎立局面。</p>
<p>2017年10月，DOcker公司在企业版Docker中内置Kubernates，标志编排之争落下帷幕。</p>
<p>次年3月，Docker公司CTO Solomon Hykes宣布辞职，5年容器纷争尘埃落定。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1">1</h2><p>2013年，作为云计算PaaS热潮中的一份子，dotCloud相比于OpenStack、 Cloud Foundry、Heroku、Pivotal、RedHat似乎有些微不足道。</p>
<p>Cloud Foundry的开源PaaS项目，]]>
    </summary>
    
      <category term="kubernates" scheme="http://zuoqy.com/tags/kubernates/"/>
    
      <category term="Cloud Compute" scheme="http://zuoqy.com/categories/Cloud-Compute/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于回溯算法的几点心得]]></title>
    <link href="http://zuoqy.com/2018/09/26/About-Backtracking/"/>
    <id>http://zuoqy.com/2018/09/26/About-Backtracking/</id>
    <published>2018-09-26T15:23:54.000Z</published>
    <updated>2018-10-09T16:58:18.371Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：关于回溯算法的几点心得<br><strong>Abstract</strong>: Some inspirations about backtracking algorithms.</p>
<h2 id="回溯（Backtracking）算法思路：">回溯（Backtracking）算法思路：</h2><p>在当前局面下，你有若干种选择。逐一尝试每一种选择。<br>如果发现某种选择行不通（违反了某些限定条件）就返回；<br>如果某种选择试到最后发现是正确解，就将其加入解集。</p>
<blockquote>
<p>这里需要注意的是，为了能够回溯，多个选择都是从相同起点出发的，注意在同一层次下的多个选择结果之间不要相互影响。</p>
</blockquote>
<p>使用递归解决问题需要明确以下三点：<strong>选择 (Options)</strong>、<strong>限制 (Restraints)</strong> 和 <strong>结束条件 (Termination)</strong>。即“ORT原则”。</p>
<a id="more"></a>
<h2 id="例题">例题</h2><h3 id="例1：generate_parentheses">例1：<a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="external">generate parentheses</a></h3><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>选择：有两种选择：</li>
</ul>
<p>加左括号。<br>加右括号。</p>
<ul>
<li>限制：同时有以下限制：</li>
</ul>
<p>如果左括号已经用完了，则不能再加左括号了。<br>如果已经出现的右括号和左括号一样多，则不能再加右括号了。因为那样的话新加入的右括号一定无法匹配。</p>
<ul>
<li>结束条件： 左右括号都已经用完。</li>
</ul>
<p>结束后的正确性： 左右括号用完以后，一定是正确解。因为</p>
<ol>
<li>左右括号一样多</li>
<li>每个右括号都一定有与之配对的左括号。因此一旦结束就可以加入解集（有时也可能出现结束以后不一定是正确解的情况，这时要多一步判断）。</li>
</ol>
<p>递归函数传入参数： 限制和结束条件中有“用完”和“一样多”字样，因此你需要知道左右括号的数目，还有参数记录解集。</p>
<p>因此，把上面的思路拼起来就是代码：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(左右括号都已用完)</span> &#123;</span><br><span class="line">  加入解集，返回</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则开始试各种选择</span></span><br><span class="line"><span class="keyword">if</span> <span class="comment">(还有左括号可以用)</span> &#123;</span><br><span class="line">  加一个左括号，继续递归</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="comment">(右括号小于左括号)</span> &#123;</span><br><span class="line">  加一个右括号，继续递归</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        gen(list, <span class="string">""</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gen</span><span class="params">(List&lt;String&gt; list, String s, <span class="keyword">int</span> leftCount, <span class="keyword">int</span> rightCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftCount == <span class="number">0</span> &amp;&amp; rightCount == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            gen(list, s + <span class="string">"("</span>, leftCount - <span class="number">1</span>, rightCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightCount &gt; leftCount) &#123;</span><br><span class="line">            gen(list, s + <span class="string">")"</span>, leftCount, rightCount - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例2：_Letter_Combinations_of_a_Phone_Number">例2： <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="external">Letter Combinations of a Phone Number</a></h3><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p>Input: “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
<p>思路：</p>
<ul>
<li>选择：当前数字上的所有letters，每个letter都是一个选择</li>
<li>限制：只能使用当前数字键上的letters，每次只能选一个</li>
<li>结束条件： 数字串结束</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] MAPPER = &#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"qprs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        combine(list, <span class="string">""</span>, digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(List&lt;String&gt; list, String value, String digits, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt;= digits.length()) &#123;</span><br><span class="line">            list.add(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择</span></span><br><span class="line">        String letters = MAPPER[digits.charAt(n) - <span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 限制</span></span><br><span class="line">            combine(list, value + letters.charAt(i), digits, n+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例3：_Combination_Sum">例3： <a href="https://leetcode.com/problems/combination-sum/description/" target="_blank" rel="external">Combination Sum</a></h3><p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>
<p>The same repeated number may be chosen from candidates unlimited number of times.</p>
<p>Note:</p>
<p>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example 1:&#10;Input: candidates = [2,3,6,7], target = 7,&#10;A solution set is:&#10;[&#10;  [7],&#10;  [2,2,3]&#10;]&#10;Example 2:&#10;&#10;Input: candidates = [2,3,5], target = 8,&#10;A solution set is:&#10;[&#10;  [2,2,2,2],&#10;  [2,3,3],&#10;  [3,5]&#10;]</span><br></pre></td></tr></table></figure></p>
<p>思路：</p>
<ul>
<li>选择：所有candidates中的一个</li>
<li>限制： 当前任何情况下，list中元素的和需要小于target</li>
<li>结束条件： 当前list中的元素和等于target</li>
</ul>
<p>需要注意： </p>
<ul>
<li>结果去重， 引入index解决</li>
<li>list副本在回溯过程中不应该相互影响</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        combinations(results, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combinations</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; list, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = sum(list);</span><br><span class="line">        <span class="keyword">if</span> (s == target) &#123;</span><br><span class="line">            results.add(copyOf(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            combinations(results, list, candidates, target, i);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">copyOf</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例4_Permutations">例4 <a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="external">Permutations</a></h3><p>Given a collection of distinct integers, return all possible permutations.</p>
<p>Example:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]&#10;Output:&#10;[&#10;  [1,2,3],&#10;  [1,3,2],&#10;  [2,1,3],&#10;  [2,3,1],&#10;  [3,1,2],&#10;  [3,2,1]&#10;]</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ul>
<li>选择：余下的nums中的一个</li>
<li>限制：不重复的使用nums中的数字</li>
<li>结束条件：当前list长度等于nums个数</li>
</ul>
<p>Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        permute(resultList, nums, <span class="keyword">new</span> LinkedList(), <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; resultList, <span class="keyword">int</span>[] nums, List&lt;Integer&gt; current, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current.size() == nums.length) &#123;</span><br><span class="line">            resultList.add(copyOf(current));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current.add(nums[i]);</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            permute(resultList, nums, current, visited);</span><br><span class="line">            current.remove(current.size() -<span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">copyOf</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例5_N-Queens">例5 <a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="external">N-Queens</a></h3><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</p>
<p>Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<p>Example:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Input: 4&#10;Output: [&#10; [&#34;.Q..&#34;,  // Solution 1&#10;  &#34;...Q&#34;,&#10;  &#34;Q...&#34;,&#10;  &#34;..Q.&#34;],&#10;&#10; [&#34;..Q.&#34;,  // Solution 2&#10;  &#34;Q...&#34;,&#10;  &#34;...Q&#34;,&#10;  &#34;.Q..&#34;]&#10;]&#10;Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.</span><br></pre></td></tr></table></figure></p>
<p>思路：</p>
<ul>
<li>选择: 当前行中的任意一个不与前面所有行上皇后冲突的列</li>
<li>限制：横、竖、斜 都不能有两个皇后在同一线上 条件：x1 != x2 &amp;&amp; y1 != y2 &amp;&amp; |x1 - x2| != |y1 - y2|</li>
<li>结束条件：所有行上都放了皇后</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] board = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; results= <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        solve(results, board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(List&lt;List&lt;String&gt;&gt; results, <span class="keyword">boolean</span>[][] board, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == board.length) &#123;</span><br><span class="line">            results.add(build(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123; <span class="comment">// 对于当前行</span></span><br><span class="line">            <span class="keyword">if</span> (valid(i, index, board)) &#123; <span class="comment">// 可放皇后则继续搜索</span></span><br><span class="line">                board[index][i] = <span class="keyword">true</span>;</span><br><span class="line">                solve(results, board, index + <span class="number">1</span>);</span><br><span class="line">                board[index][i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">boolean</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y2 = <span class="number">0</span>; y2 &lt; y1; y2++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x2 = <span class="number">0</span>; x2 &lt; board.length; x2++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[y2][x2] &amp;&amp; (x1 == x2 || y1 == y2 || Math.abs(x1-x2) == Math.abs(y1 - y2))) &#123; <span class="comment">// heng</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">build</span><span class="params">(<span class="keyword">boolean</span>[][] board)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j]) &#123;</span><br><span class="line">                    sb.append(<span class="string">"Q"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sb.append(<span class="string">"."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考：">参考：</h2><ul>
<li><a href="http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=172641&amp;page=1#pid2237150" target="_blank" rel="external">http://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=172641&amp;page=1#pid2237150</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：关于回溯算法的几点心得<br><strong>Abstract</strong>: Some inspirations about backtracking algorithms.</p>
<h2 id="回溯（Backtracking）算法思路：">回溯（Backtracking）算法思路：</h2><p>在当前局面下，你有若干种选择。逐一尝试每一种选择。<br>如果发现某种选择行不通（违反了某些限定条件）就返回；<br>如果某种选择试到最后发现是正确解，就将其加入解集。</p>
<blockquote>
<p>这里需要注意的是，为了能够回溯，多个选择都是从相同起点出发的，注意在同一层次下的多个选择结果之间不要相互影响。</p>
</blockquote>
<p>使用递归解决问题需要明确以下三点：<strong>选择 (Options)</strong>、<strong>限制 (Restraints)</strong> 和 <strong>结束条件 (Termination)</strong>。即“ORT原则”。</p>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://zuoqy.com/tags/algorithm/"/>
    
      <category term="backtracking" scheme="http://zuoqy.com/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[kotlin01 基本语法]]></title>
    <link href="http://zuoqy.com/2018/04/19/kotlin01-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>http://zuoqy.com/2018/04/19/kotlin01-基本语法/</id>
    <published>2018-04-19T13:57:52.000Z</published>
    <updated>2018-04-19T14:13:32.082Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：kotlin基本语法<br><strong>Abstract</strong>: kotlin basic syntax</p>
<h2 id="定义package">定义package</h2><p>包定义需要在文件开头，不需要和文件系统路径一致。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br></pre></td></tr></table></figure>
<h2 id="定义function">定义function</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Int &#123;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数可以是一个表达式，返回类型由编译器推断：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> = a + b</span></span><br></pre></td></tr></table></figure>
<p>无返回值的函数返回<code>Unit</code>对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Unit &#123;</span></span><br><span class="line">    println(<span class="string">"sum of $a and $b is $&#123;a + b&#125;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unit可以被省略。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> &#123;</span></span><br><span class="line">    println(<span class="string">"sum of $a and $b is $&#123;a + b&#125;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="定义变量（Variables）">定义变量（Variables）</h2><p>只读变量：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> a</span>: <span class="typename">Int</span> = <span class="number">1</span>  <span class="comment">// 定义变量时复制</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> b</span> = <span class="number">2</span>   <span class="comment">// 类型推断：`Int`</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> c</span>: <span class="typename">Int</span>  <span class="comment">// 没有立即赋值需要显式指定变量类型</span></span><br><span class="line">c = <span class="number">3</span>       <span class="comment">// deferred assignment</span></span><br></pre></td></tr></table></figure>
<p>可变变量：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> x = <span class="number">5</span> // `<span class="javascript">Int</span>` type <span class="keyword">is</span> inferred</span><br><span class="line">x += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="注释（Comments）">注释（Comments）</h2><p>kotlin的注释可以嵌套</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 块注释，</span><br><span class="line">可以包含多行 */</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串模板（string_templates）">字符串模板（string templates）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> a</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 简单变量模板:</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> s1</span> = <span class="string">"a is $a"</span> </span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板中包含表达式</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> s2</span> = <span class="string">"$&#123;s1.replace("</span><span class="keyword">is</span><span class="string">", "</span>was<span class="string">")&#125;, but now is $a"</span></span><br></pre></td></tr></table></figure>
<h2 id="条件表达式（conditional_expressions）">条件表达式（conditional expressions）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxOf</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Int &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="function"><span class="title">maxOf</span><span class="params">(a: Int, b: Int)</span></span> = <span class="keyword">if</span> (<span class="tag">a</span> &gt; b) <span class="tag">a</span> <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>
<h2 id="检查null">检查null</h2><p>如果函数返回null，必须显式在返回值类型后面加上<code>?</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str: <span class="typename">String</span>)</span>: Int? &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printProduct</span><span class="params">(arg1: <span class="typename">String, arg2: String</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> x</span> = parseInt(arg1)</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> y</span> = parseInt(arg2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接计算 `x * y` 会产生编译错误，因为x和y可能是null</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; y != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// x 和 y 检查null之后会自动转型成非空类型（non-nullable）</span></span><br><span class="line">        println(x * y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">"either '$arg1' or '$arg2' is not a number"</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型检查和自动转型">类型检查和自动转型</h2><p><code>is</code>操作符可以用来检查对象是否属于某种类型，非可变本地变量或者属性在做完类型检查之后，会在分支内自动转成目标类型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="typename">Any</span>)</span>: Int? &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">        <span class="comment">// `obj` 自动转型成 `String`</span></span><br><span class="line">        <span class="keyword">return</span> obj.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `obj` 类型在这里是`Any`</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="typename">Any</span>)</span>: Int? &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (obj !<span class="keyword">is</span> String) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `obj` 自动转型成 `String`</span></span><br><span class="line">    <span class="keyword">return</span> obj.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="typename">Any</span>)</span>: Int? &#123;</span></span><br><span class="line">    <span class="comment">// `obj` 在 `&amp;&amp;` 操作符的右侧被自动转型成 `String`类型</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> String &amp;&amp; obj.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for循环">for循环</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val <span class="keyword">items</span> = listOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"kiwifruit"</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">item</span> <span class="operator">in</span> <span class="keyword">items</span>) &#123;</span><br><span class="line">    println(<span class="keyword">item</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"kiwifruit"</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">index</span> in items.indices) &#123;</span><br><span class="line">    println(<span class="string">"item at <span class="variable">$index</span> is <span class="subst">$&#123;items[<span class="keyword">index</span>]&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="while循环">while循环</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val items = listOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"kiwifruit"</span>)</span><br><span class="line">var <span class="keyword">index</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">index</span> &lt; items.size) &#123;</span><br><span class="line">    println(<span class="string">"item at <span class="variable">$index</span> is <span class="subst">$&#123;items[<span class="keyword">index</span>]&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">index</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="when_表达式">when 表达式</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">describe</span><span class="params">(obj: <span class="typename">Any</span>)</span>: String =</span></span><br><span class="line"><span class="keyword">when</span> (obj) &#123;</span><br><span class="line">    <span class="number">1</span>          -&gt; <span class="string">"One"</span></span><br><span class="line">    <span class="string">"Hello"</span>    -&gt; <span class="string">"Greeting"</span></span><br><span class="line">    <span class="keyword">is</span> <span class="typename">Long</span>    -&gt; <span class="string">"Long"</span></span><br><span class="line">    !<span class="keyword">is</span> String -&gt; <span class="string">"Not a string"</span></span><br><span class="line">    <span class="keyword">else</span>       -&gt; <span class="string">"Unknown"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="range">range</h2><p>使用<code>in</code>操作符来判断变量是否在范围内， <code>!in</code>判断是否在范围外</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> x</span> = <span class="number">10</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> y</span> = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1.</span>.y+<span class="number">1</span>) &#123;</span><br><span class="line">    println(<span class="string">"fits in range"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="built_in">list</span> = listOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (-<span class="number">1</span> !<span class="keyword">in</span> <span class="number">0.</span>.<span class="built_in">list</span>.lastIndex) &#123;</span><br><span class="line">    println(<span class="string">"-1 is out of range"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>.size !<span class="keyword">in</span> <span class="built_in">list</span>.indices) &#123;</span><br><span class="line">    println(<span class="string">"list size is out of valid list indices range too"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置迭代步长</p>
<p>for (x in 1..10 step 2) {<br>    print(x)<br>}<br>println()<br>for (x in 9 downTo 0 step 3) {<br>    print(x)<br>}</p>
<h2 id="使用集合类">使用集合类</h2><p>迭代</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">item</span> <span class="operator">in</span> <span class="keyword">items</span>) &#123;</span><br><span class="line">    println(<span class="keyword">item</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断元素是否存在于集合中<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    <span class="string">"orange"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"juicy"</span>)</span><br><span class="line">    <span class="string">"apple"</span> <span class="keyword">in</span> items -&gt; println(<span class="string">"apple is fine too"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fitler and map</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruits</span><br><span class="line">.<span class="built_in">filter</span> &#123; <span class="keyword">it</span>.startsWith(<span class="string">"a"</span>) &#125;</span><br><span class="line">.sortedBy &#123; <span class="keyword">it</span> &#125;</span><br><span class="line">.map &#123; <span class="keyword">it</span>.toUpperCase() &#125;</span><br><span class="line">.forEach &#123; println(<span class="keyword">it</span>) &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><ol>
<li><a href="https://kotlinlang.org/docs/reference/basic-syntax.html" target="_blank" rel="external">https://kotlinlang.org/docs/reference/basic-syntax.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：kotlin基本语法<br><strong>Abstract</strong>: kotlin basic syntax</p>
<h2 id="定义package">定义package</h2><p>包定义需要在文件开头，不需要和文件系统路径一致。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br></pre></td></tr></table></figure>
<h2 id="定义function">定义function</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Int &#123;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数可以是一个表达式，返回类型由编译器推断：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> = a + b</span></span><br></pre></td></tr></table></figure>
<p>无返回值的函数返回<code>Unit</code>对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Unit &#123;</span></span><br><span class="line">    println(<span class="string">"sum of $a and $b is $&#123;a + b&#125;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unit可以被省略。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> &#123;</span></span><br><span class="line">    println(<span class="string">"sum of $a and $b is $&#123;a + b&#125;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="kotlin" scheme="http://zuoqy.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[matplotlib unicode]]></title>
    <link href="http://zuoqy.com/2017/03/21/matplotlib-unicode/"/>
    <id>http://zuoqy.com/2017/03/21/matplotlib-unicode/</id>
    <published>2017-03-21T07:05:11.000Z</published>
    <updated>2018-09-26T15:22:33.368Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：解决matplotlib中文乱码的问题<br><strong>Abstract</strong>:How to plot unicode using matplotlib<br><a id="more"></a></p>
<h2 id="方法一">方法一</h2><p>在plot之前加上如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'FangSong'</span>] <span class="comment"># 指定默认字体</span></span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="keyword">False</span>     <span class="comment"># 解决保存图像是负号'-'显示为方块的问题</span></span><br></pre></td></tr></table></figure>
<p>方法的优点是不需要改动任何配置文件，缺点是每次都要加上这样的额外代码。</p>
<h2 id="方法二">方法二</h2><p>找到matplotlib 所在的安装目录，在mac下，使用anaconda2时，所在路径为：<code>~/anaconda2/pkgs/matplotlib-2.0.0-np111py36_0/lib/python3.6/site-packages/matplotlib/mpl-data</code><br>然后copy其中的matplotlibrc 文件到用户目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp matplotlibrc ~/.matplotlib/</span><br></pre></td></tr></table></figure>
<p>修改其中的：<code>font.sans-serif</code> 加上支持中文的字体，修改<code>axes.unicode_minus</code>为<code>False</code><br>保存之后，删除<code>~/matplotlib/</code>下的<code>fontList.py3k.cache</code>字体缓存，重新加载程序即可。如果系统没有所选的字体，需要把字体文件拷贝到<code>~/anaconda2/pkgs/matplotlib-2.0.0-np111py36_0/lib/python3.6/site-packages/matplotlib/mpl-data/fonts/ttf</code>。</p>
<p>此方法的有点就是全局生效，对所有依赖该类库的程序都可以在plot中显示unicode字符。</p>
<p>验证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">3</span>*np.pi, <span class="number">500</span>)</span><br><span class="line">plt.plot(x, np.sin(x**<span class="number">2</span>))</span><br><span class="line">plt.title(<span class="string">'中文'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://zuoqy.com/images/2017-03-21/1.png"></p>
<blockquote>
<p>以上方法可以解决包括nltk在内的所有用到matplotlib而不能打印中文的问题。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：解决matplotlib中文乱码的问题<br><strong>Abstract</strong>:How to plot unicode using matplotlib<br>]]>
    
    </summary>
    
      <category term="matplotlib" scheme="http://zuoqy.com/tags/matplotlib/"/>
    
      <category term="nltk" scheme="http://zuoqy.com/tags/nltk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016——和时间赛跑的我]]></title>
    <link href="http://zuoqy.com/2016/12/31/oh-my-2016/"/>
    <id>http://zuoqy.com/2016/12/31/oh-my-2016/</id>
    <published>2016-12-31T09:38:07.000Z</published>
    <updated>2017-03-21T07:05:40.000Z</updated>
    <content type="html"><![CDATA[<p>新年临近，转眼间已经是2016年的最后一天了。抓紧这最后的几个小时，跟风写个总结。</p>
<p>如果说要我2016年的关键词，那我想就想题目那样，和时间赛跑。从2011年来到北京，到现在已经有五年时间了。想起来北京上学之前，和长辈们、朋友们聊天，总会说到，北京的生活节奏很快blabla，我一直没有什么深刻的体会。如今我挤在早班地铁里，或者9点多下班打车回家的路上，有时想起那些话，心里琢磨难道这就是所谓的”生活节奏快吗”？只是我不知不觉地习惯了这样的”节奏”，很少有时间静下心来回顾和反思。李笑来在其公众号文章中曾说”慢即是快，快即是无”。我认为不光是读书是这样，一味的”快”，缺乏精益和反思，和懒惰一样可怕，整个人很容易被这样的节奏淹没。<br>2016年，我的最大敌人就是时间。繁忙的工作让我更加珍惜时间，深感时间流逝太快。人的年龄越大，越感到时间变快，可能是因为对于一个3岁小孩，他的一天占到他人生的一千分之一，一年占到他人生的三分之一，而对于一个70岁的老人，他的一天占到人生的两万分之一<code>[1]</code>。和时间赛跑，就是在和这样的节奏抗争，让我能继续保持进取心、继续保持好奇心、继续我的业余爱好，从看似重复的工作和生活中获取新鲜的东西。<br><a id="more"></a></p>
<ol>
<li>工作</li>
</ol>
<p>毕业之后便加入阿里巴巴，算上实习，已经有三年半的时间。虽然平时工作很忙，但很庆幸当时选择了互联网这个行业，没错过这个飞速发展时代。科技发展日新月异，互联网的发展最为抢眼，人们的生活方式也正在被互联网改变：人工智能、互联网汽车、共享单车、直播、VR正在影响千千万万普通的家庭。互联网改变了人们的出行方式、支付方式、娱乐方式，时常因为自己身处浪潮之中并有幸能贡献微薄之力而感到兴奋。用一个词去概括过去一年的工作，我想就是”变化”。互联网行业发展瞬息万变，要做102年的阿里巴巴，有一个很重要的理念，就是”拥抱变化”。在阿里巴巴的1000多天中，我已经经历了很多次业务变化。每一次变化都有”涅槃重生”的感觉，每经历一次都更加强。从开始的迷茫和愤愤，到现在能快速的调整和适应，内心更加强大，专注力更强，对业务的理解更快速。变化让我接触到更多项目的初创和死亡，遇到了更多在大公司中业务发展各阶段的各种问题和困难。有句话说的一点都不错，过的不那么”舒服”的时候，才是进步最快的时候。2016年经历了两次大的业务调整和变化，有幸接触到智能交互服务领域。2016年，各大互联网公司争相推出自己的智能语音交互服务，Google发布了Google Home、亚马逊发布了Echo、微软也推出小冰……身在其中，才感受到了这个领域所面临的各种挑战，而我又这么喜欢挑战。</p>
<ol>
<li>阅读</li>
</ol>
<p>读书占去了我大部分的业余时间。从2015年底开始到现在这一年多的时间里，我总共读过22本书。还剩着一堆进度为40%-50%的烂尾书没有读完（实在惭愧）。完成的书单按照时间顺序排列分别是：《重来》、《曾国藩的正面与侧面》、《极客与团队》、《HBase in Action》、《支付战争》、《文学回忆录》、《量子理论：爱因斯坦与波尔关于世界本质的伟大论战》、《一万小时天才理论》、《把你的英语用起来》、《失控》、《七周七并发模型》、《巴菲特之道》、《黑客与画家》、《第一本Docker书》、《囚徒健身》、《Java 8函数式编程》、《精进》、《Java性能优化权威指南》、《我最想要的记忆魔法书》、《神奇的眼脑直映快读法》、《激荡三十年（上）中国企业1978-2008》、《刻意练习》。书单还算比较多样，什么类型的都有，甚至还有文学类<code>- - ！</code>。现在看着这个书单就像是一个日历摆在我面前，回忆书中的内容，总会想到写看书时所经历的事情。比如其中的技术书完全依据业务的需要，有些书则是在杭州出差期间，深夜的宾馆里静静看完的。读书的感觉很好，可以让浮躁的心安静下来，如同在时空中畅游，了解自己未知的领域、和作者对话。</p>
<ol>
<li>旅行</li>
</ol>
<p>读万卷书，行万里路。年初难得的两周假期，我和妻子去了美国旅行，期间从东岸飞到西岸，从纽约到旧金山，还去了夏威夷。在美国的两周多时间，我的身心的到了彻底的放松，在纽约时去了大都会博物馆、自然历史博物馆、帝国大厦、洛克菲勒、时代广场、中央公园和自由女神。被一个短短几百年时间建设起来的国家的文化积淀深深的震撼到了。自然环境、人文环境和文化气息，每每想起都感觉那么不真实，感觉我们的祖国还有很长很长的路要走啊。在旧金山，我们拜访了我向往的斯坦福大学，在金门大桥上徒步走过，迟到了渔人码头的海鲜大餐（感谢小伙伴在旧金山的招待）。在夏威夷，我们去过Maui和Honolulu两个岛，干净的沙滩和海水让我们流连忘返。</p>
<ol>
<li>写作</li>
</ol>
<p>2016年，我总共写了7篇博客。博客和微信公众号改变了我对写作的看法。原来越觉得一个人的能力在很大程度上体现在其阅读理解和写作上。同样的文字，不同人的理解程度千差万别，读过不一定全部理解，全部理解不一定能用自己的话写出来，能写出来，不一定能在Presentation中流畅的讲出来。而很多重要的机会都是看演讲和写作中能表达多少，你比别人多读了多少，多理解了多少。个人认为自己在写作方面有待提高，而且没有太多时间投入到写作上。这可能是和我在中学时代严重偏向理科导致的。其实，无论身处什么行业，偏爱什么学科，都离不开阅读理解和写作。</p>
<ol>
<li>业余爱好</li>
</ol>
<p>还好，我还有个业余爱好一直没有放弃。虽然能弹吉他的时间原来越少，但总有那么一些时间练习。音乐和阅读一样美妙，让大脑得到另一种形式的锻炼和休息。学习一样乐器的乐趣很多，吉他让我有机会真正去想了解音乐以及一些乐理知识。在中学时代，音乐课其实教授了不少有用的知识，知识当时不够重视。而有些能力比如音阶调式的听力、乐感等如果幼年时没有得到足够的锻炼，一旦成年是很难再去补救的<code>[2]</code>。在阅读《一万小时天才理论》和《精进》等书时从中获得的学习方法用在音乐中同样得到了良好的效果，避免无效练习之后，我节省了更多的时间获得真正的进步，也有了更多的成就感和乐趣。</p>
<ol>
<li>健身</li>
</ol>
<p>身体是一切的前提，工作后运动减少，让我开始了解健身知识，增加在健身方面投入。每周有一天少加半小时一小时班跑去健身房，回报就是身体状态和工作效率的提高。除了让大脑时刻保持良好的状态，让身体得到足够的锻炼是保持健康状态的不错选择。<em>种一棵树最好的时间是十年前，其次是现在。</em>不要等身体出了问题再去补救。从办健身卡到现在，坚持的还算不错，基本保持着一周去两次的状态。坚持健身也增强了我的意志力和身体状态，能够更好的投入工作和生活。</p>
<ol>
<li>公开课</li>
</ol>
<p>2016年，我业余时间完成了一门Coursera公开课的自修，并拿到证书。相比之前有所减少，主要是我的时间越来越少，很少有大块的时间用来完成课程作业了。两年前，我得益于住在公司附近，用大量早上早起的时间选修了人工智能和机器学习方面的课程，它们后来在我的工作中起到了很关键的作用并改变了我对好多事情的看法。</p>
<p>最后，感谢我的家人和我的妻子对我的支持和理解。在新的一年，希望家人和朋友们身体健康，特别祝愿我九十岁的姥姥身体健康。工作顺利，每天都有新的进步！</p>
<p>2016年12月31日<br>于石家庄</p>
<h2 id="参考">参考</h2><ul>
<li><code>[1]</code> 《把时间当做朋友》</li>
<li><code>[2]</code> 《一万小时天才理论》《精进》《刻意练习》</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>新年临近，转眼间已经是2016年的最后一天了。抓紧这最后的几个小时，跟风写个总结。</p>
<p>如果说要我2016年的关键词，那我想就想题目那样，和时间赛跑。从2011年来到北京，到现在已经有五年时间了。想起来北京上学之前，和长辈们、朋友们聊天，总会说到，北京的生活节奏很快blabla，我一直没有什么深刻的体会。如今我挤在早班地铁里，或者9点多下班打车回家的路上，有时想起那些话，心里琢磨难道这就是所谓的”生活节奏快吗”？只是我不知不觉地习惯了这样的”节奏”，很少有时间静下心来回顾和反思。李笑来在其公众号文章中曾说”慢即是快，快即是无”。我认为不光是读书是这样，一味的”快”，缺乏精益和反思，和懒惰一样可怕，整个人很容易被这样的节奏淹没。<br>2016年，我的最大敌人就是时间。繁忙的工作让我更加珍惜时间，深感时间流逝太快。人的年龄越大，越感到时间变快，可能是因为对于一个3岁小孩，他的一天占到他人生的一千分之一，一年占到他人生的三分之一，而对于一个70岁的老人，他的一天占到人生的两万分之一<code>[1]</code>。和时间赛跑，就是在和这样的节奏抗争，让我能继续保持进取心、继续保持好奇心、继续我的业余爱好，从看似重复的工作和生活中获取新鲜的东西。<br>]]>
    
    </summary>
    
      <category term="2016" scheme="http://zuoqy.com/tags/2016/"/>
    
      <category term="summary" scheme="http://zuoqy.com/tags/summary/"/>
    
      <category term="summary" scheme="http://zuoqy.com/categories/summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Median of Two Sorted Arrays]]></title>
    <link href="http://zuoqy.com/2016/12/03/Median-of-Two-Sorted-Arrays/"/>
    <id>http://zuoqy.com/2016/12/03/Median-of-Two-Sorted-Arrays/</id>
    <published>2016-12-03T10:48:58.000Z</published>
    <updated>2016-12-03T13:05:35.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：两个有序数组的中位数<br><strong>Abstract</strong>: Median of Two Sorted Arrays<br>最近遇到一个有意思的题，求两个有序数组的中位数，亲自做了一下发现坑很多，除了二分查找的思想运用的很巧妙，还有各种边界条件把我搞得很崩溃。于是记录下来。<br><a id="more"></a><br>首先，题目是这样的：<br>有两个有序数组，长度分别是m和n，找到两个数组的中位数，要求时间复杂度是<code>O(log (m+n))</code></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> 1:</span><br><span class="line"><span class="keyword">nums1</span> =<span class="sqbracket"> [1, 3]</span></span><br><span class="line"><span class="keyword">nums2</span> =<span class="sqbracket"> [2]</span></span><br><span class="line"><span class="keyword">The</span> median is 2.0</span><br><span class="line"></span><br><span class="line"><span class="keyword">Example</span> 2:</span><br><span class="line"><span class="keyword">nums1</span> =<span class="sqbracket"> [1, 2]</span></span><br><span class="line"><span class="keyword">nums2</span> =<span class="sqbracket"> [3, 4]</span></span><br><span class="line"><span class="keyword">The</span> median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<p><code>O(m+n)</code>的解法就是一趟归并排序然后再取中位数，比较简单。<code>O(log(m+n))</code>的解法需要用到二分的思想。<br>假设<code>i</code>,<code>j</code>将数组<code>A</code>，<code>B</code>分为左右两部分：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left_part                |        right_part&#10;A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]&#10;B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</span><br></pre></td></tr></table></figure>
<p>如果保持左右两部分数量相同，则<code>i</code>和<code>j</code>：的关系如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i + j = (m - i) + (n - j)&#10;==&#62; i + j = (m + n) / 2&#10;==&#62; j = (m + n) / 2 - i</span><br></pre></td></tr></table></figure>
<p>即：我们只需要找到<code>i</code>,<code>j</code>满足：<code>i + j = (m - i) + (n - j)</code>且<code>max(left_part) &lt;= min(right_part)</code>即可通过：<code>A[i-1]、A[i]、B[j-1]、B[j]</code>计算出中位数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median = (max(left_part) + min(right_part))/2</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#22312;A&#25968;&#32452;&#20013;&#20108;&#20998;&#26597;&#25214;&#65292;&#24403;&#21069;&#20803;&#32032;index = i&#65306;&#10;1&#65289;&#24403;A[i - 1] &#62; B[j]&#65292;&#35828;&#26126;i&#36807;&#22823;&#65292;&#35201;&#25214;&#30340;i&#22312;A[0...i-1]&#20013;&#65307;&#10;2&#65289;&#24403;B[j - 1] &#62; A[i]&#65292;&#35828;&#26126;i&#36807;&#23567;&#65292;&#35201;&#25214;&#30340;i&#22312;A[i+1...m]&#20013;&#65307;&#10;&#24490;&#29615;1&#65289;2&#65289;&#30452;&#21040;&#25214;&#21040;&#31526;&#21512;&#26465;&#20214;&#30340;i&#21644;j</span><br></pre></td></tr></table></figure>
<p>以上就是这个算法的主要思想，当然有这些还不够，还需要注意<code>i = 0</code>、<code>i = m</code>、<code>j = 0</code>、<code>j = n</code>和空数组<code>[]</code>等边界情况。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = B.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = m;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(B, A);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (B[n/<span class="number">2</span>] + B[(n - <span class="number">1</span>) / <span class="number">2</span>])/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            i = (left + right) / <span class="number">2</span>;</span><br><span class="line">            j = (m + n) / <span class="number">2</span> - i;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; A[i - <span class="number">1</span>] &gt; B[j]) &#123; <span class="comment">// i &gt; 0 ==&gt; j &lt; n</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(j &gt; <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; B[j - <span class="number">1</span>] &gt; A[i])</span> </span>&#123; <span class="comment">// j &gt; 0 ==&gt; i &lt; m</span></span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftMax, rightMin;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            leftMax = B[j-<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(j == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">            leftMax = A[i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftMax = Math.max(A[i-<span class="number">1</span>], B[j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">            rightMin = B[j];</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(j == n)</span> </span>&#123;</span><br><span class="line">            rightMin = A[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rightMin = Math.min(A[i], B[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightMin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (leftMax + rightMin) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：两个有序数组的中位数<br><strong>Abstract</strong>: Median of Two Sorted Arrays<br>最近遇到一个有意思的题，求两个有序数组的中位数，亲自做了一下发现坑很多，除了二分查找的思想运用的很巧妙，还有各种边界条件把我搞得很崩溃。于是记录下来。<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://zuoqy.com/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://zuoqy.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gartner Hyper Cycle]]></title>
    <link href="http://zuoqy.com/2016/06/21/Gartner-Hyper-Cycle/"/>
    <id>http://zuoqy.com/2016/06/21/Gartner-Hyper-Cycle/</id>
    <published>2016-06-21T03:29:19.000Z</published>
    <updated>2018-09-26T15:22:33.368Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：高德纳技术成熟度曲线。<br><strong>Abstract</strong>: Theory of Gartner Hyper Cycle.<br><a id="more"></a></p>
<h2 id="概要">概要</h2><p>高德纳技术成熟度曲线如图所示,其描述了一个技术成熟度和该技术实际被应用和接受程度的关系.<br><img src="http://zuoqy.com/images/2016-06-21/1.png" alt="Gartner Hyper Cycle"></p>
<h2 id="如何使用">如何使用</h2><p>人们使用技术成熟度曲线获得新兴技术的承诺和业界对风险的控制偏好.<br>你是否要抢先尝试使用新兴技术? 如果你结合承担的风险并理解风险投资不会经常得到应有的回报,你有所收获.<br>使用温和的方式是否合适? 新技术采纳者应该明白,新兴的技术往往没有得到足够的证明.<br>需要等待其更成熟之后再使用吗?如果你还存在很多关于商业可行性方面的额问题不能回答,你最好等待其他人给出更靠谱的答案之后再尝试使用.</p>
<h2 id="技术成熟度曲线">技术成熟度曲线</h2><p>1995年开始，高德纳咨询公司依其专业分析预测与推论各种新科技的成熟演变速度及要达到成熟所需的时间，分成5个阶段：</p>
<table>
<thead>
<tr>
<th style="text-align:center">阶段</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">科技诞生的促动期 (Technology Trigger)</td>
<td style="text-align:center">在此阶段，随着媒体大肆的报导过度，非理性的渲染，产品的知名度无所不在，然而随着这个科技的缺点、问题、限制出现，失败的案例大于成功的案例，例如:.com公司 1998~2000年之间的非理性疯狂飙升期。</td>
</tr>
<tr>
<td style="text-align:center">过高期望的峰值（Peak of Inflated Expectations）</td>
<td style="text-align:center">早期公众的过分关注演绎出了一系列成功的故事——当然同时也有众多失败的例子。对于失败，有些公司采取了补救措施，而大部分却无动于衷。</td>
</tr>
<tr>
<td style="text-align:center">泡沫化的底谷期 (Trough of Disillusionment)</td>
<td style="text-align:center">在历经前面阶段所存活的科技经过多方扎实有重点的试验，而对此科技的适用范围及限制是以客观的并实际的了解，成功并能存活的经营模式逐渐成长。</td>
</tr>
<tr>
<td style="text-align:center">稳步爬升的光明期 (Slope of Enlightenment)</td>
<td style="text-align:center">在此阶段，有一新科技的诞生，在市面上受到主要媒体与业界高度的注意，例如:1996年的Internet ，Web。</td>
</tr>
<tr>
<td style="text-align:center">实质生产的高原期 (Plateau of Productivity)</td>
<td style="text-align:center">在此阶段，新科技产生的利益与潜力被市场实际接受，实质支援此经营模式的工具、方法论经过数代的演进，进入了非常成熟的阶段。</td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Hype_cycle" target="_blank" rel="external">https://en.wikipedia.org/wiki/Hype_cycle</a></li>
<li><a href="http://www.gartner.com/technology/research/methodologies/hype-cycle.jsp" target="_blank" rel="external">http://www.gartner.com/technology/research/methodologies/hype-cycle.jsp</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：高德纳技术成熟度曲线。<br><strong>Abstract</strong>: Theory of Gartner Hyper Cycle.<br>]]>
    
    </summary>
    
      <category term="Theory" scheme="http://zuoqy.com/tags/Theory/"/>
    
      <category term="Theory" scheme="http://zuoqy.com/categories/Theory/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP重定向状态码的区别]]></title>
    <link href="http://zuoqy.com/2016/05/23/HTTP-redirect-codes/"/>
    <id>http://zuoqy.com/2016/05/23/HTTP-redirect-codes/</id>
    <published>2016-05-23T10:13:53.000Z</published>
    <updated>2016-05-23T16:05:49.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：HTTP重定向状态码区分。<br><strong>Abstract</strong>: Difference between HTTP redirect code 301, 302, 303, 307<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left">资源被永久移除。客户端后续应该请求到新的URI上（相应报文首部给出），客户端需要向新的URI重新发起请求。后续的请求也都应该请求新的URI。</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">临时重定向。客户端后续请求仍然使用原有的URI。</td>
</tr>
<tr>
<td style="text-align:left">303</td>
<td style="text-align:left">See Other(since HTTP/1.1)</td>
<td style="text-align:left">告诉客户端，用Get方法请求给定的新URI中的资源。对于POST/PUT/DELETE请求，客户端应该假定服务器已经收到并处理了该请求，应该向新的URI再发一次GET请求来获取结果。后续请求还需要请求到老URI上。</td>
</tr>
<tr>
<td style="text-align:left">307</td>
<td style="text-align:left">Temporary Redirect (since HTTP/1.1)</td>
<td style="text-align:left">临时重定向。对于所有POST/PUT/DELETE请求，客户端<strong>应当重新发起本次请求</strong>。后续的请求还应该使用老的URI。</td>
</tr>
</tbody>
</table>
<p><code>302 Found</code>标准与实现有偏差，The HTTP/1.0（RFC 1945）规定客户端需要做临时重定向，原始的描述是<code>&quot;Moved Temporarily&quot;</code>，本应实现成307所描述的功能，但是主流的浏览器实现成了类似303 See Other的功能。因此在HTTP/1.1中，增加了303和307两个状态码来区分两种不同的行为。</p>
<h2 id="参考">参考</h2><ul>
<li>1 <a href="http://stackoverflow.com/questions/4764297/difference-between-http-redirect-codes" target="_blank" rel="external">Difference between HTTP redirect codes</a></li>
<li>2 Gourley, David, and Brian Totty. HTTP: the definitive guide. “ O’Reilly Media, Inc.”, 2002.</li>
<li>3 <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection" target="_blank" rel="external">List of HTTP status codes</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：HTTP重定向状态码区分。<br><strong>Abstract</strong>: Difference between HTTP redirect code 301, 302, 303, 307<br>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://zuoqy.com/tags/HTTP/"/>
    
      <category term="redirect" scheme="http://zuoqy.com/tags/redirect/"/>
    
      <category term="重定向" scheme="http://zuoqy.com/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    
      <category term="HTTP" scheme="http://zuoqy.com/categories/HTTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java对象的共享]]></title>
    <link href="http://zuoqy.com/2016/05/22/sharing-objects/"/>
    <id>http://zuoqy.com/2016/05/22/sharing-objects/</id>
    <published>2016-05-22T07:48:56.000Z</published>
    <updated>2016-05-22T09:40:12.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：Java内存可见性、对象的发布和逸出以及不变性<br><strong>Abstract</strong>:Visibility、publish and escape、immutable。<br><a id="more"></a></p>
<h2 id="可见性">可见性</h2><p>可见性是指某个线程对变量写入的值，其他线程是否总能够正确的读取。通常，为了确保多线程之间对内存写入操作的可见性，必须使用同步机制。</p>
<h3 id="重排序">重排序</h3><p>在多线程情况下，存在指令重排序的情况，因此在没有同步的情况下，不能假定多线程程序的指令执行顺序。</p>
<h3 id="失效数据">失效数据</h3><p>在没有同步保证的多线程程序中，一个线程可能读取到某个变量的新值，也可能读取到其已经失效的值。</p>
<h3 id="非原子的64位操作">非原子的64位操作</h3><p>在多线程程序中使用共享且可变的long和double等类型的变量是不安全的，除非用volatile声明或者用锁保护起来。因为JVM允许将64位的操作分解为两个32位的操作。</p>
<h3 id="加锁与可见性">加锁与可见性</h3><p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读写操作的线程都必须在同一个锁上进行同步。</p>
<h3 id="volatile变量">volatile变量</h3><p>volatile变量不会被缓存在寄存器中或者对其他处理器不可见的地方，因此在读取volatile类型的变量时，总会返回最新写入的值。<br>仅当volatile变量能简化代码实现以及对同步策略的验证时，才应该使用它们。使用方式包括：确保变量自身状态的可见性、确保所引用对象状态的可见性、标识一些重要的程序生命周期事件的发生（如初始化或关闭）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断某个状态，决定是否退出循环</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> asleep;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(!asleep) &#123;</span><br><span class="line">    countSomeSheep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：volatile语义不足以保证递增操作（count++）的原子性，因为递增是读-修改-写操作。<strong>加锁机制既可以确保可见性，又可以确保原子性，而volatile变量只能确保可见性</strong>。</p>
<p><strong>当且仅当满足以下所有条件时，才应该使用volatile变量</strong>：</p>
<ul>
<li>对变量的写入操作比依赖变量当前的值，或者确保只有一个线程更新变量的值。</li>
<li>该变量不会与其他状态变量一起纳入不变性条件。</li>
<li>访问该变量时不需要加锁。</li>
</ul>
<h2 id="发布与逸出">发布与逸出</h2><p><strong>发布（publish）</strong>对象，是指是对象能够在当前作用域之外的代码中使用。例如将对象的引用保存到其他类的代码中，或者将引用传递到其他类的方法中。<br><strong>逸出（escape）</strong>：当不应该发布的对象被发布，则成为逸出。</p>
<h3 id="this逸出">this逸出</h3><p>在一个类的构造函数中发布对象时，只是发布了一个尚未构造完成的对象，即使发布对象的语句位于构造函数的最后一行。如果this引用在构造函数中逸出，这种对象的创建就是不正确的构造。<strong>不要在函数构造方法中，使this逸出</strong></p>
<h4 id="错误1：在构造方法内发布内部类对象">错误1：在构造方法内发布内部类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不正确的构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        source.registerListener() &#123;</span><br><span class="line">            <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                    doSomeThing(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上例中，假设EventListener是ThisEscape类的内部类，在发布内部类的对象时，this隐含的也被发布了。</p>
<h4 id="错误2：在构造函数中启动线程">错误2：在构造函数中启动线程</h4><p>如果想在构造器中启动线程或者设置事件监听，应该使用一个私有构造方法和一个公共的静态工厂方法，从而避免不正确的构造过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        listener = <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        SafeListener safe = <span class="keyword">new</span> SafeListener();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程封闭（Thread_Confinement）">线程封闭（Thread Confinement）</h2><p>当某个对象封闭在一个线程中时，将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。</p>
<h3 id="Ad-hoc线程封闭">Ad-hoc线程封闭</h3><p>Ad-hoc线程封闭是指维护线程封闭性的职责完全有程序实现来承担。例如在volatile变量上的读-修改-写操作确保只有一个线程来完成。<br>这种线程封闭较脆弱，应该尽量避免使用。</p>
<h3 id="栈封闭">栈封闭</h3><p>栈封闭：是指只能通过局部变量才能访问对象。</p>
<h3 id="ThreadLocal类">ThreadLocal类</h3><p>ThreadLocal是维持线程封闭性的一种更规范的方法，ThreadLocal对象通常用于防止可变的单例或者全局变量进行共享。静态的ThreadLocal对象可以将包含在其中的全局变量为每个使用它的线程都保存一份，当线程终结时，会被垃圾回收掉。运用此机制，可以很好的实现线程上下文的保存。</p>
<h2 id="不变性">不变性</h2><p>不可变对象一定是线程安全的，当满足下面的条件时，对象才是不可变的：</p>
<ul>
<li>对象创建以后其状态不可修改</li>
<li>对象所有域都是final类型</li>
<li>对象是正确被创建的（在构造方法中没有this逸出）</li>
</ul>
<h3 id="final域">final域</h3><p>final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象。</p>
<h3 id="安全发布的常用模式">安全发布的常用模式</h3><ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到volatile类型的域或者AtomicReference对象中。</li>
<li>将对象的引用保存到某个正确构造对象的final类型的域中</li>
<li>将兑现给的引用保存到一个由锁保护的域中。</li>
</ul>
<h2 id="参考">参考</h2><ul>
<li>1 Goetz, Brian, and Tim Peierls. Java concurrency in practice. Pearson Education, 2006.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：Java内存可见性、对象的发布和逸出以及不变性<br><strong>Abstract</strong>:Visibility、publish and escape、immutable。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="concurrency" scheme="http://zuoqy.com/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二阶段提交协议]]></title>
    <link href="http://zuoqy.com/2016/03/27/2-phase-commit/"/>
    <id>http://zuoqy.com/2016/03/27/2-phase-commit/</id>
    <published>2016-03-27T03:55:25.000Z</published>
    <updated>2016-03-27T08:04:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：简要介绍二阶段提交协议的思想<br><strong>Abstract</strong>:Main ideas of 2 phase commit.<br><a id="more"></a></p>
<h2 id="两阶段提交协议（Two_Phase_Commit_Protocol）">两阶段提交协议（Two Phase Commit Protocol）</h2><p>两阶段提交协议是分布式事务处理使用的一种一致性协议。它用来协调分布式事务中的每个参与者，应对系统分布式系统执行事务过程中的短暂系统异常（如：节点失败、网络通信异常等）。</p>
<h2 id="前提">前提</h2><ul>
<li>系统有存在一个协调者（coordinator）节点，其他节点为参与者（cohorts）</li>
<li>系统中有稳定的存储，用来记录事务日志（预写日志WAL，Write-ahead logging），预写日志不会因为节点宕机而丢失。</li>
<li>系统中，任意两个节点之间都可以相互通信。（相比前两条，可放宽一些）</li>
</ul>
<h2 id="算法描述">算法描述</h2><h3 id="第一阶段：请求提交阶段Commit_Request_Phase（投票阶段_voting_phase）">第一阶段：请求提交阶段Commit Request Phase（投票阶段 voting phase）</h3><ul>
<li>协调者向所有参与值发起事务提交请求，等待所有参与者的投票响应。</li>
<li>所有参与者执行协调者发起的事务，记录Undo和Redo log。</li>
<li>所有参与者投票给协调者（事务可以执行成功，回复<em>Yes</em>，否则回复<em>No</em>）。任何一个参数者没有回复yes都会导致事务回滚。</li>
</ul>
<h3 id="第二阶段：事务提交阶段（Commit_Phase）">第二阶段：事务提交阶段（Commit Phase）</h3><h4 id="执行成功：">执行成功：</h4><ul>
<li>协调者向所有参与者发送commit命令</li>
<li>所有参与者完成事务提交，并释放事务处理期间所占用的锁和资源</li>
<li>参与者发送ACK给协调者</li>
<li>当协调者收到所有参与者的ACK之后，事务执行成功</li>
</ul>
<h4 id="执行失败：">执行失败：</h4><ul>
<li>任何一个参与者投票No或者超时，都导致事务回滚</li>
<li>每个参与者根据WAL日志回滚</li>
<li>每个参与者发送ACK给协调者</li>
<li>协调者收到所有ACK后，事务回滚完成</li>
</ul>
<p>时序图：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Coordinator                                         Cohort&#10;                              QUERY TO COMMIT&#10;                --------------------------------&#62;&#10;                              VOTE YES/NO           prepare*/abort*&#10;                &#60;-------------------------------&#10;commit*/abort*                COMMIT/ROLLBACK&#10;                --------------------------------&#62;&#10;                              ACKNOWLEDGMENT        commit*/abort*&#10;                &#60;--------------------------------  &#10;end</span><br></pre></td></tr></table></figure>
<p><code>*</code>表示改操作需要依赖稳定的存储</p>
<h2 id="算法缺陷">算法缺陷</h2><ul>
<li>同步阻塞：两阶段提交最大的缺点，等待其他参与者响应的过程中是阻塞的，无法进行其他操作。如果在阶段二协调者失败，则参与者永远处于阻塞状态，直到收到commit命令或者abort命令。</li>
<li>单点问题：协调者存在单点问题</li>
<li>太过保守：任何参与者错误或者超时，都会导致整个分布式事务失败。</li>
</ul>
<h2 id="参考">参考</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="external">https://en.wikipedia.org/wiki/Two-phase_commit_protocol</a></li>
<li><a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00RECRKPK" target="_blank" rel="external">从paxos到zookeeper——分布式一致性原理与实践</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：简要介绍二阶段提交协议的思想<br><strong>Abstract</strong>:Main ideas of 2 phase commit.<br>]]>
    
    </summary>
    
      <category term="2 Phase Commit" scheme="http://zuoqy.com/tags/2-Phase-Commit/"/>
    
      <category term="2PC" scheme="http://zuoqy.com/tags/2PC/"/>
    
      <category term="一致性协议" scheme="http://zuoqy.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="二阶段提交" scheme="http://zuoqy.com/tags/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java ClassLoader]]></title>
    <link href="http://zuoqy.com/2016/02/05/classloader/"/>
    <id>http://zuoqy.com/2016/02/05/classloader/</id>
    <published>2016-02-05T13:53:45.000Z</published>
    <updated>2016-03-27T03:50:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：Java类加载器<br><strong>Abstract</strong>: An overview of Java ClassLoaders<br><a id="more"></a></p>
<h2 id="走进CLassLoader">走进CLassLoader</h2><p>每个类加载器（classloader）自身都是一个扩展自<code>java.lang.ClassLoader</code>类的实例。那么如果类加载器本身也有类型，并且每类都是由classloader加载的，那么加载的顺序是怎样的？我们需要了解classloader的机制和JVM类加载体系。首先看一下classloader的API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Class de <span class="title">neClass</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> URL <span class="title">getResource</span><span class="params">(String name)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Enumeration <span class="title">getResources</span><span class="params">(String name)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getParent</span><span class="params">()</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>loadClass</code>方法是<code>java.lang.ClassLoader</code>类中最重要的方法，接收类的全名，返回改类型的实例对象。<br><code>defineClass</code>方法，参数为byte数组，一般是从磁盘或其他地方加载的Java字节码。<br><code>getResource</code>和<code>getResources</code>返回资源的URL，它有类似于<code>loadClass</code>方法的<strong>委托机制</strong>，首先委托给父类加载，然后再在本地查找。<code>loadClass</code>方法等同于<code>defineClass(getResource(name).getBytes())</code>.<br><code>getParent</code>方法返回父类加载器（parent classloader），在下一节中我们将详细描述。<br>由于Java的晚期绑定，类型加载延迟到最晚时刻进行。一个类只有在第一次调用其构造方法、static方法或static属性时，才会被加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    b.doSomethingElse();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>B b = new B();</code>在语义上等同于<code>getClassLoader().loadClass(&quot;B&quot;).newInstance();</code><br>在Java中，所有的对象都和他们的类关联，而所有的类都和该类的加载器关联。<br>当我们实例化一个<code>ClassLoader</code>，我们可以通过构造方法指定其父类加载器（<code>parent ClassLoader</code>），如果没有显式的指定，则JVM会指定一个默认的parent classloader。那么默认的parent classloader是什么呢？这取决于JVM的ClassLoader继承体系。</p>
<h2 id="JVM的类加载委托体系（classloader_delegation_hierarchy）">JVM的类加载委托体系（classloader delegation hierarchy）</h2><p>JVM在启动时，会首先加载<strong>bootstrap classloader</strong>，bootstrap classloader是所有类加载器的parent，负责加载重要的Java基础类（如java.lang package）和其他运行时类型。<em>bootstrap类加载器是JVM中，唯一一个没有parent的类加载器</em>。<br>接着是加载<strong>extension classloader</strong>。它的parent是bootstrap classloader，负责加载<code>java.ext.dirs</code>路径下的所有jar包。<br>第三步，也是最重要的一步，就是加载<strong>system classpath classloader</strong>,该classloader的直接父节点是extention classloader。它负责从<code>CLASSPATH</code>变量指定的路径、<code>java.class.path</code>系统变量或<code>-classpath</code>命令行参数指定的路径中加载类。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10; +---------------------+&#10; |bootstrap classloader|&#10; +---------------------+&#10;           |&#10;           v&#10; +---------------------+&#10; |extention classloader|&#10; +---------------------+&#10;           |&#10;           v&#10;+----------------------------+&#10;|system classpath classloader|&#10;+----------------------------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是，以上JVM的类加载体系并非一个继承体系，而是一个委托体系（delegation hierarchy）。</p>
</blockquote>
<p>大部分的classloader在加载自己本地classpath种的资源和类之前，优先委托给他们的parent。如果parent classloader不能找到目标类或者资源，classloader才会尝试在本地的classpath中搜索并加载资源。也就是说，classloader只加载它的parent无法加载的类或资源。相反，被处于委托体系下层的classloader加载的class不能被委托体系上层的类访问。</p>
<blockquote>
<p>最初建立这样的类加载委托体系的初衷是为了避免相同类型可能被加载数次。回到1995年，当时Java平台的主要应用是Web Applet。当时网络带宽的限制，决定了JVM需要延迟加载类型。但后来证明Java在服务端程序和JavaEE中表现优异，在服务端程序中，classloader理想的加载顺序是相反的——优先在本地查找并加载class，没有找到时，再向parant中去查找。</p>
</blockquote>
<h2 id="JavaEE类型加载委托体系">JavaEE类型加载委托体系</h2><p>下面是一个典型的web容器classloader体系：每个EAR（J2EE Enterprise Archive）module和WAR都有自己的类加载器。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;                   +-----------+&#10;                   | container |&#10;                   +-----------+&#10;                         |&#10;           +---------------+----------+&#10;           |               |          |&#10;      +--------+       +--------+ +--------+&#10;      |App1.ear|       |App2.ear| |App3.ear|&#10;      +--------+       +--------+ +--------+&#10;          |                |          |&#10;    +-----------+          |          |&#10;    |           |          |          |&#10;+-------+   +-------+  +-------+  +-------+&#10;| WAR1  |   | WAR2  |  | WAR3  |  | WAR4  |&#10;+-------+   +-------+  +-------+  +-------+</span><br></pre></td></tr></table></figure>
<p>Java Servlet规范建议web模块的classloader优先加载类加载器本地的内容。之后当没有找到目标类时，才委托parent加载。</p>
<blockquote>
<p>颠倒委托顺序的原因是：应用容器中的加载的众多类库都有自己的发布周期，不一定适用于开发者。典型的例子就是log4j类库，在container中使用的是一个版本，而在应用中使用的是另一个版本。</p>
</blockquote>
<p>然而这带来了问题：</p>
<blockquote>
<p>JEVGENI KABANOV:The reversed behavior of web module classloader has caused more problems with classloaders than anything else… ever.</p>
</blockquote>
<h3 id="JavaEE类加载错误">JavaEE类加载错误</h3><p>JavaEE的委托模型又是会出现以下几种有趣的错误。<code>NoClassDefFoundError</code>, <code>LinkageError</code>, <code>ClassNotFoundException</code>, <code>NoSuchMethodError</code>, <code>ClassCastException</code>.</p>
<h4 id="NoClassDefFoundError">NoClassDefFoundError</h4><p><code>NoClassDefFoundError</code> 是上述错误中最常见的一种，排错分析的复杂程度取决于你Web项目的复杂性和规模。Java文档中是这样描述的：</p>
<blockquote>
<p>NoClassDefFoundError is thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the de nition of a class and no de nition of the class could be found.</p>
</blockquote>
<p>也就是说，类型定义在编译期存在，而在运行时无法找到。这就是你不能完全依赖IDE的错误信息提示，许多运行时的错误IDE并帮不上忙。</p>
<blockquote>
<p>JEVGENI KABANOV: All classloading happens at runtime, which makes the IDE results irrelevant.</p>
</blockquote>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoClassDefFoundErrorServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.print(StringUtils.defaultString(<span class="string">"hello"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NoClassDefFoundErrorServlet</code> 调用<code>StringUtils</code>类的defaultString方法，打印一条信息。但是在运行时会发生如下错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;java.lang.NoClassDefFoundError: org/apache/commons/lang3/StringUtils&#10;&#9;com.zuoqy.classloader.NoClassDefFoundErrorServlet.doGet(NoClassDefFoundErrorServlet.java:20)&#10;&#9;javax.servlet.http.HttpServlet.service(HttpServlet.java:620)&#10;&#9;javax.servlet.http.HttpServlet.service(HttpServlet.java:727)&#10;&#9;org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)</span><br></pre></td></tr></table></figure>
<p>如何排除这个错误？ 很显然你需要检查<code>StringUtils</code>这个类是否真的被引入到了package里。由于maven依赖的<code>commons-lang3</code>的scope是provided，因此在编译期间并不会出错。由于运行时tomcat的lib目录中没有对应的jar包，才会产生运行时错误。</p>
<p>这里有一个技巧，就是打印出classloader加载类的classpath：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoClassDefFoundErrorServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.print(Arrays.toString(((URLClassLoader) NoClassDefFoundErrorServlet.class.getClassLoader()).getURLs()));</span><br><span class="line">        <span class="comment">//writer.print(StringUtils.defaultString("hello"));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会看到类似下面的输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;[file:/opt/tomcat/deploy/ROOT/WEB-INF/classes/, file:/opt/tomcat/deploy/ROOT/]</span><br></pre></td></tr></table></figure>
<p>但打印classpath的方法不是在所有情况下都可以，我们还可以使用<code>jconsole</code>命令连接到tomcat进程上查看classpath信息以及在运行时加载了哪些类。</p>
<h4 id="NoSuchMethodError">NoSuchMethodError</h4><p>产生<code>NoSuchMethodError</code>的原因一般是被引用的class存在，但是不是正确的版本。首先需要知道这个版本不正确的class是从哪加载的。可以通过设置JVM参数<code>‘-verbose:class</code>查看类的加载和卸载日志。确定所加载的class路径之后，可以使用<code>javap -private classfile</code>命令来查看此class文件中是否有目标方法。</p>
<p>如果是maven项目，还可以通过在项目根目录下运行 <code>mvn clean dependency:tree</code> 命令查看是否存在依赖冲突。然后把错误版本的jar包在依赖中排除掉即可。</p>
<p>未完待续…</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://zeroturnaround.com/rebellabs/rebel-labs-tutorial-do-you-really-get-classloaders/" target="_blank" rel="external">http://zeroturnaround.com/rebellabs/rebel-labs-tutorial-do-you-really-get-classloaders/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：Java类加载器<br><strong>Abstract</strong>: An overview of Java ClassLoaders<br>]]>
    
    </summary>
    
      <category term="ClassLoader" scheme="http://zuoqy.com/tags/ClassLoader/"/>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="Java" scheme="http://zuoqy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vmstat用法]]></title>
    <link href="http://zuoqy.com/2015/12/01/vmstat/"/>
    <id>http://zuoqy.com/2015/12/01/vmstat/</id>
    <published>2015-12-01T04:37:58.000Z</published>
    <updated>2018-09-26T15:22:33.367Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：vmstat用法<br><strong>Abstract</strong>: usage of vmstat<br><a id="more"></a></p>
<h2 id="注记">注记</h2><p>vmstat - virtual memory statistics</p>
<h2 id="概要">概要</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">vmstat</span> [-<span class="atom">a</span>] [-<span class="atom">n</span>] [-<span class="name">S</span> <span class="atom">unit</span>] [<span class="atom">delay</span> [ <span class="atom">count</span>]]</span><br><span class="line">       <span class="atom">vmstat</span> [-<span class="atom">s</span>] [-<span class="atom">n</span>] [-<span class="name">S</span> <span class="atom">unit</span>]</span><br><span class="line">       <span class="atom">vmstat</span> [-<span class="atom">m</span>] [-<span class="atom">n</span>] [<span class="atom">delay</span> [ <span class="atom">count</span>]]</span><br><span class="line">       <span class="atom">vmstat</span> [-<span class="atom">d</span>] [-<span class="atom">n</span>] [<span class="atom">delay</span> [ <span class="atom">count</span>]]</span><br><span class="line">       <span class="atom">vmstat</span> [-<span class="atom">p</span> <span class="atom">disk</span> <span class="atom">partition</span>] [-<span class="atom">n</span>] [<span class="atom">delay</span> [ <span class="atom">count</span>]]</span><br><span class="line">       <span class="atom">vmstat</span> [-<span class="atom">f</span>]</span><br><span class="line">       <span class="atom">vmstat</span> [-<span class="name">V</span>]</span><br></pre></td></tr></table></figure>
<h2 id="描述">描述</h2><p>vmstat命令打印关于进程，内存，分页，块IO，陷阱和CPU活动的信息。</p>
<h2 id="选项说明">选项说明</h2><ul>
<li><code>-a</code>: 显示活跃/非活跃内存</li>
<li><code>-f</code>: 不与其他选项同时使用，显示系统从启动到现在fork（包含fork、vfork、clone系统调用）次数，等同于创建的任务数。不重复显示。</li>
<li><code>-m</code>: 显示板子（网卡等）信息</li>
<li><code>-n</code>: 让表头在刷新显示过程中只显示一次</li>
<li><code>-s</code>: 显示一系列事件总数和内存统计，不重复显示</li>
<li><code>delay</code>: 更新时间，如果没有设置这个参数，则显示的是从系统启动到现在的均值</li>
<li><code>count</code>: 刷新次数</li>
<li><code>-d</code>: 磁盘统计信息</li>
<li><code>-w</code>: 扩大打印列宽</li>
<li><code>-p</code>: 指定磁盘分区，获得更详细的统计信息。</li>
<li><code>-S</code>: 指定单位<code>k/K/m/M</code> 分别表示：<code>1000/1024/1000000/1048576</code> </li>
<li><code>-V</code>: 显示版本信息</li>
</ul>
<h2 id="VM模式显示字段说明">VM模式显示字段说明</h2><h3 id="Procs">Procs</h3><ul>
<li><code>r</code>: 等待运行的进程数</li>
<li><code>b</code>: 不可中断的休眠进程数</li>
</ul>
<h3 id="Memory">Memory</h3><ul>
<li><code>swpd</code>: 虚拟内存使用量</li>
<li><code>free</code>: 空闲内存</li>
<li><code>buff</code>: 作为缓冲区的内存数</li>
<li><code>cache</code>: 作为加速缓存的内存数</li>
<li><code>inactive</code>: 不活跃的内存</li>
<li><code>active</code>: 活跃内存</li>
</ul>
<h3 id="Swap">Swap</h3><ul>
<li><code>si</code>: 从磁盘换入占用内存数</li>
<li><code>so</code>: 换出到磁盘的内存数</li>
</ul>
<h3 id="IO">IO</h3><ul>
<li><code>bi</code>: 从块设备输入的块数</li>
<li><code>bo</code>: 从块设备输出的块数</li>
</ul>
<h3 id="System">System</h3><ul>
<li><code>in</code>: 每秒中断次数（包含时钟中断）</li>
<li><code>cs</code>: 每秒上下文切换次数</li>
</ul>
<h3 id="CPU">CPU</h3><p>下面的指标是CPU时间的百分比</p>
<ul>
<li><code>us</code>: 用户区代码CPU时间</li>
<li><code>sy</code>: 内核代码CPU时间</li>
<li><code>id</code>: 空闲CPU时间</li>
<li><code>wa</code>: IO等待时间</li>
<li><code>st</code>: 从虚拟机偷的CPU时间</li>
</ul>
<h2 id="磁盘模式显示选项说明">磁盘模式显示选项说明</h2><h3 id="Reads">Reads</h3><ul>
<li><code>total</code>: 成功读出的总量</li>
<li><code>merged</code>: 单次I/O读操作的量（合并到一次）</li>
<li><code>sectors</code>: 成功读取的扇区数</li>
<li><code>ms</code>: 读操作的时间</li>
</ul>
<h3 id="Writes">Writes</h3><ul>
<li><code>total</code>: 成功写入的总量</li>
<li><code>merged</code>: 单次I/O写操作的量（合并到一次）</li>
<li><code>sectors</code>: 成功写入的扇区数</li>
<li><code>ms</code>: 写操作的时间</li>
</ul>
<h3 id="IO-1">IO</h3><ul>
<li><code>cur</code>: 当前正在进行的I/O </li>
<li><code>s</code>: I/O消耗的时间（秒）</li>
</ul>
<h2 id="重要">重要</h2><p>vmstat不需要特殊的权限。当前所有linux的块大小都是1024 bytes。旧版内核可能是512 bytes 2048 bytes 或 4096bytes。</p>
<h2 id="示例：">示例：</h2><p>在CPU密集型机器上：</p>
<p><img src="http://zuoqy.com/images/2015-12-01/1.png" alt="vmstat1"></p>
<p>在GPU机器上：</p>
<p><img src="http://zuoqy.com/images/2015-12-01/2.png" alt="vmstat2"></p>
<h2 id="参考">参考</h2><ul>
<li><em>vmstat man page</em></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：vmstat用法<br><strong>Abstract</strong>: usage of vmstat<br>]]>
    
    </summary>
    
      <category term="vmstat" scheme="http://zuoqy.com/tags/vmstat/"/>
    
      <category term="性能监控" scheme="http://zuoqy.com/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    
      <category term="performance" scheme="http://zuoqy.com/categories/performance/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Hbase in Action》读书笔记]]></title>
    <link href="http://zuoqy.com/2015/11/04/hbase-in-action/"/>
    <id>http://zuoqy.com/2015/11/04/hbase-in-action/</id>
    <published>2015-11-04T12:38:18.000Z</published>
    <updated>2015-11-05T14:20:53.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：<em>Hbase in Action</em> 读书笔记。</p>
<p><strong>Abstract</strong>: <em>HBase in Action</em> notes.<br><a id="more"></a></p>
<h2 id="使用场景和成功案例">使用场景和成功案例</h2><h3 id="抓取增量数据">抓取增量数据</h3><ul>
<li>抓取监控指标 OpenTSDB：采集机器监控指标和日志信息，并支持按照时间序列进行查询</li>
<li>抓取用户交互数据：Facebook 和 StumbleUpon</li>
<li>遥测技术：Mozillahe Trend Micro: 收集软件崩溃报告</li>
<li>广告效果和点击流：</li>
</ul>
<h3 id="内容服务">内容服务</h3><ul>
<li>URL短连接：存储短连接和原始连接之间的映射关系</li>
<li>runa.com用户模型服务：实时报价。</li>
</ul>
<h3 id="信息交换">信息交换</h3><ul>
<li>Facebook的短信交换系统</li>
</ul>
<h2 id="概要">概要</h2><h3 id="五个基本命令">五个基本命令</h3><ul>
<li>Get</li>
<li>Put</li>
<li>Delete</li>
<li>Scan</li>
<li>Increment</li>
</ul>
<h3 id="数据存储">数据存储</h3><h4 id="无模式">无模式</h4><p>Hbase是无模式的，不需要事先定义Schema，不需要提前指定列和数据类型，只需要在写数据时给出列的名字。</p>
<h3 id="工作机制">工作机制</h3><h4 id="写机制">写机制</h4><ul>
<li><strong>持久化保证</strong>写入时会写到两个地方：预写式日志（WAL）和MemStore，只有这两个地方写完成才算写成功。</li>
<li><strong>写速度</strong>：Memstore是内存缓冲区，缓冲区满才刷磁盘（HFile）。HFile是磁盘文件，对应列族。<strong>列族和HFile之间是一对多的关系。一个列族可以有多个HFile，但一个HFile只对应一个列族</strong>。</li>
<li><strong>崩溃恢复</strong>：在写动作完成之前先写WAL，HBase集群中的每台服务器维护一个WAL，服务器宕机情况下，可以通过回放WAL的方式来恢复。跳过WAL可以提高写性能，但可能会产生数据丢失。</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Put p = <span class="keyword">new</span> Put();</span><br><span class="line"><span class="comment">//禁用预写日志</span></span><br><span class="line">p.setWriteToWAL(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h4 id="读机制">读机制</h4><ul>
<li><strong>毫秒级读</strong>：Hbase在读操作上使用了LRU缓存BlockCache（与MemStore在同一个JVM堆里），每个列族都有自己的BlockCache。</li>
<li><strong>Block设置</strong>：Block是简历索引和从磁盘读的最小单位，默认是64KB。根据查询方式是Scan居多还是KV查询居多可以调整Block大小。scan居多时，调大block可以增大读取速度。并减少索引所占空间。</li>
</ul>
<h4 id="删除机制">删除机制</h4><ul>
<li><strong>合并</strong>：Delete命令之后，并不是立即删除内容，而是针对被删除内容写入一条新的墓碑记录（tombstone）来标记删除。墓碑记录不能在scan和get时返回结果。直到执行一次大合并（major compaction）这些墓碑记录占用的空间才被释放。</li>
<li><strong>小合并</strong>：合并分为大合并和小合并，小合并把多个HFile合并成一个大HFile。然后把新Hfile标记为激活状态，合并前的旧HFile被删除。</li>
<li><strong>大合并</strong>：处理给定region一个列族的所有HFile。大合并消耗资源，不会频繁发生，但是清理被删除记录的唯一机会。</li>
</ul>
<h4 id="时间版本">时间版本</h4><p>Hbase中的数据有时间版本的概念，Hbase中的时间版本是long类型的，以毫秒为单位的当前时间。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;KeyValue&gt; kv = r.getColumn(Bytes.toBytes(<span class="string">"family"</span>),Bytes.toBytes(<span class="string">"col1"</span>));</span><br><span class="line">kv.<span class="literal">get</span>(<span class="number">0</span>).getValue();</span><br><span class="line">kv.<span class="literal">get</span>(<span class="number">1</span>).getValue();</span><br></pre></td></tr></table></figure>
<h3 id="数据模型">数据模型</h3><ul>
<li><strong>表（Table）</strong>：Hbase使用table组织数据，表名是字符串，由可以在文件系统路径里使用的字符构成。</li>
<li><strong>行（Row)</strong>: 在表里，数据按行存储，行由行键（Rowkey）作为唯一标识。行键没有数据类型，总是视为<code>byte[]</code>.</li>
<li><strong>列族（column family）</strong>：行里的数据按照列族分组，列族影响到Hbase数据的物理存放。他们必须事先定义好并且不轻易修改。</li>
<li><strong>列限定符（column qualifier）</strong>：列族里的数据通过列限定符或列来定位。列限定符不必实现定义，不必再不同行之间保持一致。列限定符都是<code>byte[]</code>。</li>
<li><strong>单元（cell）</strong>：行键、列族和列限定符一起确定一个单元。存储在单元中的数据成为<em>值（value）</em>。值都是<code>byte[]</code>.</li>
<li><strong>时间版本</strong>：单元值有时间版本，时间版本用long型时间戳标识。时间版本的数量基于列族配置，默认数量是3.</li>
</ul>
<p>关系型数据库中的数据是<em>结构化数据</em>，Hbase中的数据是<em>半结构化数据</em>。Hbase是专门为半结构化数据和水平可扩展性设计的数据库。</p>
<h3 id="数据坐标">数据坐标</h3><p>Hbase依次使用：行键、列族、列限定符和时间版本作为数据的坐标。基于非键值查询Hbase的唯一办法就是带过滤器的扫描。</p>
<h3 id="事务特性">事务特性</h3><p>Hbase不是ACID兼容数据库。</p>
<ul>
<li>同一行上的<code>Put()</code>操作具有原子性。要么整体成功，要么整体失败。</li>
<li>行间的<code>Put()</code>操作不是原子性的。</li>
<li><code>Get()</code>操作返回当时所保存的完整行数据。</li>
<li><code>Scan()</code>操作不是扫描快照，在扫描过程中如果有行更新，则扫描到的结果包含更新后的完整的行</li>
</ul>
<h2 id="Hbase表设计">Hbase表设计</h2><h3 id="IO优化">IO优化</h3><h4 id="写优化">写优化</h4><ul>
<li>散列：通过散列行键（如取Md5或SHA1）来避免Region热点的问题。</li>
<li>salting：通过在行键上加上前缀，将数据分散到各个Region。</li>
</ul>
<p>但以上两种方案会使Scan性能下降(连续的记录被打散到多个Region中)。</p>
<h4 id="读优化">读优化</h4><p>例：推贴按照倒序时间戳和用户id组成的复合行键可以scan出最近n条用户推贴。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：<em>Hbase in Action</em> 读书笔记。</p>
<p><strong>Abstract</strong>: <em>HBase in Action</em> notes.<br>]]>
    
    </summary>
    
      <category term="Hbase" scheme="http://zuoqy.com/tags/Hbase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则表达式参考手册]]></title>
    <link href="http://zuoqy.com/2015/07/24/regex/"/>
    <id>http://zuoqy.com/2015/07/24/regex/</id>
    <published>2015-07-24T02:14:45.000Z</published>
    <updated>2015-07-26T12:39:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：正则表达式参考手册<br><strong>Abstract</strong>: Regular Expression Reference<br><a id="more"></a></p>
<h2 id="Character_classes">Character classes</h2><table>
<thead>
<tr>
<th style="text-align:left">Exp.</th>
<th style="text-align:left">Match</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">Matches any character except line breaks. Equivalent to <code>[^\n\r]</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>\w</code></td>
<td style="text-align:left">Matches any word character (alphanumeric &amp; underscore). Only matches low-ascii characters (no accented or non-roman characters). Equivalent to <code>[A-Za-z0-9_]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\W</code></td>
<td style="text-align:left">Matches any character that is not a word character (alphanumeric <code>&amp;</code> underscore). Equivalent to <code>[^A-Za-z0-9_]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\d</code></td>
<td style="text-align:left">Matches any digit character (0-9). Equivalent to <code>[0-9]</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>\D</code></td>
<td style="text-align:left">Matches any character that is not a digit character (0-9). Equivalent to <code>[^0-9]</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>\s</code></td>
<td style="text-align:left">Matches any whitespace character (spaces, tabs, line breaks).</td>
</tr>
<tr>
<td style="text-align:left"><code>\S</code></td>
<td style="text-align:left">Matches any character that is not a whitespace character (spaces, tabs, line breaks).</td>
</tr>
<tr>
<td style="text-align:left"><code>[ABC]</code></td>
<td style="text-align:left">Match any character in the set.</td>
</tr>
<tr>
<td style="text-align:left"><code>[^ABC]</code></td>
<td style="text-align:left">Match any character that is not in the set.</td>
</tr>
<tr>
<td style="text-align:left"><code>a-z</code></td>
<td style="text-align:left">Matches a character having a character code between the two specified characters inclusive.</td>
</tr>
</tbody>
</table>
<h2 id="Anchors">Anchors</h2><table>
<thead>
<tr>
<th style="text-align:left">Exp.</th>
<th style="text-align:left">Match</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">Matches the beginning of the string, or the beginning of a line if the multiline flag (m) is enabled. This matches a position, not a character.</td>
</tr>
<tr>
<td style="text-align:left"><code>$</code></td>
<td style="text-align:left">Matches the end of the string, or the end of a line if the multiline flag (m) is enabled. This matches a position, not a character.</td>
</tr>
<tr>
<td style="text-align:left"><code>\b</code></td>
<td style="text-align:left">Matches a word boundary position such as whitespace, punctuation, or the start/end of the string. This matches a position, not a character.</td>
</tr>
<tr>
<td style="text-align:left"><code>\B</code></td>
<td style="text-align:left">Matches any position that is not a word boundary. This matches a position, not a character.</td>
</tr>
</tbody>
</table>
<h2 id="Escape_charactors">Escape charactors</h2><table>
<thead>
<tr>
<th style="text-align:left">Exp.</th>
<th style="text-align:left">Match</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\.</code> <code>\*</code> <code>\\</code> <code>\+</code> <code>\*</code> <code>\?</code> <code>\{</code> <code>\(</code> <code>\[</code></td>
<td style="text-align:left">escaped special characters</td>
</tr>
<tr>
<td style="text-align:left"><code>\t</code> <code>\v</code> <code>\n</code> <code>\r</code> <code>\f</code></td>
<td style="text-align:left">tab, vertical tab, linefeed, carriage return, FORM FEED character (char code 12).</td>
</tr>
<tr>
<td style="text-align:left"><code>\u00A9</code></td>
<td style="text-align:left">unicode escaped ©</td>
</tr>
<tr>
<td style="text-align:left"><code>\000</code></td>
<td style="text-align:left">Octal escaped character in the form <code>\000</code>(null). Value must be less than 255 (<code>\377</code>).</td>
</tr>
<tr>
<td style="text-align:left"><code>\xFF</code></td>
<td style="text-align:left">Hexadecimal escaped character in the form <code>\xFF</code>.</td>
</tr>
</tbody>
</table>
<h2 id="Groups_and_Lookaround">Groups and Lookaround</h2><p>Quantifiers indicate that the preceding token must be matched a certain number of times. By default, quantifiers are greedy, and will match as many characters as possible.<br>Alternation acts like a boolean OR, matching one sequence or another.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Exp.</th>
<th style="text-align:left">Match</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(abc)</td>
<td style="text-align:left">capture group</td>
</tr>
<tr>
<td style="text-align:left"><code>\1</code></td>
<td style="text-align:left">Back reference. Matches the results of a previous capture group. For example \1 matches the results of the first capture group <code>&amp;</code> \3 matches the third.</td>
</tr>
<tr>
<td style="text-align:left"><code>(?:abc)</code></td>
<td style="text-align:left">Non-capturing group. Groups multiple tokens together without creating a capture group.</td>
</tr>
<tr>
<td style="text-align:left"><code>(?=abc)</code></td>
<td style="text-align:left">Positive lookahead. Matches a group after the main expression without including it in the result.</td>
</tr>
<tr>
<td style="text-align:left"><code>(?!abc)</code></td>
<td style="text-align:left">Negative lookahead. Specifies a group that can not match after the main expression (if it matches, the result is discarded).</td>
</tr>
<tr>
<td style="text-align:left"><code>(?&lt;=ABC)</code></td>
<td style="text-align:left">Positive lookbehind. Matches a group before the main expression without including it in the result.</td>
</tr>
<tr>
<td style="text-align:left"><code>(?&lt;!ABC)</code></td>
<td style="text-align:left">Negative lookbhind. Specifies a group that can not match before the main expression (if it matches, the result is discarded).</td>
</tr>
</tbody>
</table>
<h2 id="Quantifiers_and_Alternation">Quantifiers and Alternation</h2><table>
<thead>
<tr>
<th style="text-align:left">Exp.</th>
<th style="text-align:left">Match</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">Matches 1 or more of the preceding token.</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">Matches 0 or more of the preceding token.</td>
</tr>
<tr>
<td style="text-align:left"><code>{1,3}</code></td>
<td style="text-align:left">Quantifier.Matches the specified quantity of the previous token. <code>{1,3}</code> will match 1 to 3. <code>{3}</code> will match exactly 3. <code>{3,}</code> will match 3 or more.</td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left">Optional. Matches 0 or 1 of the preceding token, effectively making it optional.</td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left">Makes the preceding quantifier lazy, causing it to match as few characters as possible. By default, quantifiers are greedy, and will match as many characters as possible.</td>
</tr>
</tbody>
</table>
<p>Note:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| Acts like <span class="operator">a</span> boolean OR. Matches <span class="operator">the</span> expression <span class="keyword">before</span> <span class="operator">or</span> <span class="keyword">after</span> <span class="operator">the</span> |.It can operate <span class="operator">within</span> <span class="operator">a</span> group, <span class="operator">or</span> <span class="command"><span class="keyword">on</span> <span class="title">a</span> <span class="title">whole</span> <span class="title">expression</span>. <span class="title">The</span> <span class="title">patterns</span> <span class="title">will</span> <span class="title">be</span> <span class="title">tested</span> <span class="title">in</span> <span class="title">order</span>.</span></span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2><ul>
<li><a href="http://regexr.com/" target="_blank" rel="external">http://regexr.com/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：正则表达式参考手册<br><strong>Abstract</strong>: Regular Expression Reference<br>]]>
    
    </summary>
    
      <category term="Regular Expression" scheme="http://zuoqy.com/tags/Regular-Expression/"/>
    
      <category term="json" scheme="http://zuoqy.com/tags/json/"/>
    
      <category term="正则表达式" scheme="http://zuoqy.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入HashMap]]></title>
    <link href="http://zuoqy.com/2015/06/22/java-hashmap/"/>
    <id>http://zuoqy.com/2015/06/22/java-hashmap/</id>
    <published>2015-06-22T13:51:04.000Z</published>
    <updated>2018-09-26T15:22:33.367Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：JDK1.7 HashMap源码阅读<br><strong>Abstract</strong>: Source code analysis of JDK1.7</p>
<a id="more"></a>
<h2 id="概述">概述</h2><p>HashMap实现了Map接口，HashMap和Hashtable唯一的区别就是HashMap不是线程安全的，并且允许插入空值。影响HashMap性能的参数有两个：<em>初始大小</em>和<em>填装因子（Load Factor）</em>，初始大小设置HashMap中初始有多少个bucket，填装因子则设置HashMap中的元素占总容量的最大比例，超过这一比例时，HashMap将自动扩容。当Entry数量超过容量乘以填装因子时，HashMap中的元素将会被rehash到一个二倍于原来容量的新哈希表中。<br>一般情况下，填装因子默认设置为0.75，这个数值是空间和时间的折中。填装因子增大会减少HashMap所占空间，但会增加查找时间。为了保证效率，最好能对放入HashMap中的元素总数有一个预估，设置适当的初始大小从而避免<em>rehash</em>发生。<br>需要注意的是，HashMap不是线程安全的，当多个线程同时改变同一个HashMap实例的结构时（structural modification），必须有额外的同步。所谓改变HashMap的结构，就是添加或者删除Mapping。只是改变key对应的value的值，不能算改变结构。同步操作可以在额外的Object实例上同步，也可以使用<code>Map m = Collections.synchronizedMap(new HashMap(...));</code>，如果没有做正确的同步，HashMap上的并发操作会<em>快速失败（fail-fast）</em>（事实上，它并不能保证未经同步的并发修改操作绝对能够快速失败），并抛出<code>ConcurrentModificationException</code>，这个异常机制只能用来检查程序是否有潜在的BUG，不能依赖这个异常去做程序逻辑的其他判断。</p>
<p><img src="http://zuoqy.com/images/2015-06-22/1.png" alt="HashMap-dia"></p>
<h2 id="结构">结构</h2><p>HashMap最基本的构成单位是Entry，在HashMap内部，所有的键值对都存储在Entry数组中，如果放入HashMap的键值对有冲突，则用拉链法，把具有相同哈希值的Entry存放在一个链表中，如下图所示：</p>
<p><img src="http://zuoqy.com/images/2015-06-22/2.png" alt="HashMap-structure"></p>
<p>Entry类的定义如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K <span class="variable">key</span>;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="built_in">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates new entry.</span><br><span class="line">     */</span></span><br><span class="line">    Entry(<span class="built_in">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        <span class="variable">key</span> = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K getKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">key</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V getValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> o) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        <span class="keyword">Object</span> k1 = getKey();</span><br><span class="line">        <span class="keyword">Object</span> k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            <span class="keyword">Object</span> v1 = getValue();</span><br><span class="line">            <span class="keyword">Object</span> v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">int</span> hashCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This method is invoked whenever the value in an entry is</span><br><span class="line">     * overwritten by an invocation of put(k,v) for a key k that's already</span><br><span class="line">     * in the HashMap.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">void</span> recordAccess(<span class="keyword">HashMap</span>&lt;K,V&gt; m) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This method is invoked whenever the entry is</span><br><span class="line">     * removed from the table.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">void</span> recordRemoval(<span class="keyword">HashMap</span>&lt;K,V&gt; m) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重要的属性和常量">重要的属性和常量</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量，必须是2的指数幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap的最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认填装因子load factor</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75</span>f;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空哈希表 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表，长度必须是2的整数指数幂</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阈值（capacity * load factor），当键值对数量超过该值时扩容</span></span><br><span class="line"><span class="comment">// 当表为空表时，该值是默认初始大小</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填装因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表结构改变（Structurally Modified）的次数</span></span><br><span class="line"><span class="comment">// 结构改变：键值对数量变化、rehash</span></span><br><span class="line"><span class="comment">// 用于快速未经同步的并发操作的失败</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用替代hash算法的阈值</span></span><br><span class="line"> <span class="comment">// 替代Hash算法降低了String类型的key的冲突的可能性</span></span><br><span class="line"> <span class="comment">// 容量超过这个阈值的时候，将使用替代Hash算法</span></span><br><span class="line"> <span class="comment">// 这个值可由系统参数jdk.map.althashing.threshold指定</span></span><br><span class="line"> <span class="comment">// 当此系统参数为1时，确保总是使用替代hash算法</span></span><br><span class="line"> <span class="comment">// 为-1时，确保永远不适用替代hash算法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * A randomizing value associated with this instance that is applied to</span><br><span class="line"> * hash code of keys to make hash collisions harder to find. If 0 then</span><br><span class="line"> * alternative hashing is disabled.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 用于减少key的hash code冲突</span></span><br><span class="line"><span class="comment">// 如果是0，表示不使用替代的hash算法</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> hashSeed = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><code>ALTERNATIVE_HASHING_THRESHOLD_DEFAULT</code>初始化代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放虚拟机启动后才能初始化的内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> &#123;</span></span><br><span class="line">    <span class="comment">// 使用替代hash算法的容量阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="typename">int</span> ALTERNATIVE_HASHING_THRESHOLD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        String altThreshold = java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> sun.security.action.GetPropertyAction(</span><br><span class="line">                <span class="string">"jdk.map.althashing.threshold"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="typename">int</span> threshold;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threshold = (<span class="literal">null</span> != altThreshold)</span><br><span class="line">                    ? Integer.parseInt(altThreshold)</span><br><span class="line">                    : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// disable alternative hashing if -1</span></span><br><span class="line">            <span class="keyword">if</span> (threshold == -<span class="number">1</span>) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (threshold &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"value must be positive integer."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException failed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Illegal value for 'jdk.map.althashing.threshold'"</span>, failed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ALTERNATIVE_HASHING_THRESHOLD = threshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法">构造方法</h2><p>指定初始大小和填装因子，创建HashMap：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity; <span class="comment">// 这里并没有设置table，而是设置阈值</span></span><br><span class="line">    init(); <span class="comment">// 空方法，用于继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定初始大小，创建HashMap，填装因子使用默认值 0.75</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认初始大小和填装因子，创建HashMap：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据已有的Hashmap创建，使用默认的填装因子，和根据填装因子计算出的容量：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重要内部类">重要内部类</h2><h3 id="Entry类"><code>Entry</code>类</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K <span class="variable">key</span>;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="built_in">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates new entry.</span><br><span class="line">     */</span></span><br><span class="line">    Entry(<span class="built_in">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        <span class="variable">key</span> = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K getKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">key</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V getValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> o) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        <span class="keyword">Object</span> k1 = getKey();</span><br><span class="line">        <span class="keyword">Object</span> k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            <span class="keyword">Object</span> v1 = getValue();</span><br><span class="line">            <span class="keyword">Object</span> v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">int</span> hashCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This method is invoked whenever the value in an entry is</span><br><span class="line">     * overwritten by an invocation of put(k,v) for a key k that's already</span><br><span class="line">     * in the HashMap.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">void</span> recordAccess(<span class="keyword">HashMap</span>&lt;K,V&gt; m) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This method is invoked whenever the entry is</span><br><span class="line">     * removed from the table.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">void</span> recordRemoval(<span class="keyword">HashMap</span>&lt;K,V&gt; m) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Iterators">Iterators</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator&lt;E&gt;</span> <span class="title">implements</span> <span class="title">Iterator&lt;E&gt;</span> &#123;</span></span><br><span class="line">    <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    int expectedModCount;   <span class="comment">// For fast-fail</span></span><br><span class="line">    int index;              <span class="comment">// current slot</span></span><br><span class="line">    <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; current;     <span class="comment">// current entry</span></span><br><span class="line"></span><br><span class="line">    <span class="type">HashIterator</span>() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// 设置next为第一个entry</span></span><br><span class="line">            <span class="type">Entry</span>[] t = table;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">final</span> boolean hasNext() &#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; nextEntry() &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((next = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Entry</span>[] t = table;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">        current = e;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="type">Object</span> k = current.key;</span><br><span class="line">        current = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">HashMap</span>.<span class="keyword">this</span>.removeEntryForKey(k);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HashIterator&lt;V&gt;</span> &#123;</span></span><br><span class="line">    public <span class="type">V</span> next() &#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry().value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HashIterator&lt;K&gt;</span> &#123;</span></span><br><span class="line">    public <span class="type">K</span> next() &#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry().getKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HashIterator&lt;Map</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;&gt;</span> &#123;</span></span><br><span class="line">    public <span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next() &#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KeySet">KeySet</h3><p>这个集合是一个代理集合，真正的数据对象是map，所以map的改动会反映在Set上，反之亦然。<br>此集合支持：<code>Iterator.remove()</code>、<code>Set.remove()</code>、<code>removeAll()</code>、<code>clear()</code><br>不支持：<code>add()</code>和<code>addAll()</code></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;K&gt; iterator() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">newKeyIterator</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">containsKey</span><span class="params">(o)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HashMap.<span class="keyword">this</span>.removeEntryForKey(o) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似<code>HashMap.this.xxx()</code>是内部类调用外部类对象非静态方法时需要明确给出的，否则会调用内部类本身的<code>xxx()</code>方法。</p>
<h3 id="Values">Values</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;V&gt; iterator() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">newValueIterator</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">containsValue</span><span class="params">(o)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主要方法">主要方法</h2><h3 id="clear">clear</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Removes all of the mappings from this map.</span><br><span class="line"> * The map will be empty after this call returns.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">clear</span>() &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    Arrays.<span class="built_in">fill</span>(table, <span class="keyword">null</span>);</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="clone">clone</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">Object</span> clone() &#123;</span><br><span class="line">    <span class="type">HashMap</span>&lt;K,V&gt; <span class="literal">result</span> = null;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="literal">result</span> = (<span class="type">HashMap</span>&lt;K,V&gt;)super.clone();</span><br><span class="line">    &#125; catch (<span class="type">CloneNotSupportedException</span> e) &#123;</span><br><span class="line">        // assert <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">result</span>.table != <span class="type">EMPTY_TABLE</span>) &#123;</span><br><span class="line">        <span class="literal">result</span>.inflateTable(<span class="type">Math</span>.min(</span><br><span class="line">            (<span class="type">int</span>) <span class="type">Math</span>.min(</span><br><span class="line">                size * <span class="type">Math</span>.min(<span class="number">1</span> / loadFactor, <span class="number">4</span>.<span class="number">0</span>f),</span><br><span class="line">                // we have limits...</span><br><span class="line">                <span class="type">HashMap</span>.<span class="type">MAXIMUM_CAPACITY</span>),</span><br><span class="line">           table.length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">result</span>.entrySet = null;</span><br><span class="line">    <span class="literal">result</span>.modCount = <span class="number">0</span>;</span><br><span class="line">    <span class="literal">result</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="literal">result</span>.init();</span><br><span class="line">    <span class="literal">result</span>.putAllForCreate(this);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="containsKey">containsKey</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> containsKey(<span class="keyword">Object</span> <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> getEntry(<span class="variable">key</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="containsValue">containsValue</h3><p>顺序查找每一个slot的下拉链表</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsValue</span><span class="params">(Object <span class="keyword">value</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> containsNullValue();</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span>.equals(e.<span class="keyword">value</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="entrySet">entrySet</h3><p>返回的是HashMap的成员变量，如果是null，新建一个空集合。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">Set</span><span class="subst">&lt;</span><span class="built_in">Map</span><span class="built_in">.</span>Entry<span class="subst">&lt;</span>K,V<span class="subst">&gt;&gt;</span> entrySet() &#123;</span><br><span class="line">    <span class="keyword">return</span> entrySet0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">Set</span><span class="subst">&lt;</span><span class="built_in">Map</span><span class="built_in">.</span>Entry<span class="subst">&lt;</span>K,V<span class="subst">&gt;&gt;</span> entrySet0() &#123;</span><br><span class="line">    <span class="built_in">Set</span><span class="subst">&lt;</span><span class="built_in">Map</span><span class="built_in">.</span>Entry<span class="subst">&lt;</span>K,V<span class="subst">&gt;&gt;</span> es <span class="subst">=</span> entrySet;</span><br><span class="line">    <span class="keyword">return</span> es <span class="subst">!=</span> <span class="built_in">null</span> <span class="subst">?</span> es : (entrySet <span class="subst">=</span> <span class="literal">new</span> EntrySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get">get</h3><p>如果key为null，在<code>table[0]</code>链表上查找，否则调用getEntry方法</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(<span class="variable">key</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="isEmpty">isEmpty</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="keySet">keySet</h3><p>返回map中的所有的key的集合 详见类<a href="#KeySet">KeySet</a></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="built_in">Set</span><span class="subst">&lt;</span>K<span class="subst">&gt;</span> keySet() &#123;</span><br><span class="line">    <span class="built_in">Set</span><span class="subst">&lt;</span>K<span class="subst">&gt;</span> ks <span class="subst">=</span> keySet;</span><br><span class="line">    <span class="keyword">return</span> (ks <span class="subst">!=</span> <span class="built_in">null</span> <span class="subst">?</span> ks : (keySet <span class="subst">=</span> <span class="literal">new</span> KeySet()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="put">put</h3><p>将k-v放入map，如果key在map中已经存在，则用新值替换旧值。注意，HashMap允许key value为null。<br>如果key为null，则指定在<code>table[0]</code>拉链。<br>因此，条件<code>get(xxx) == null</code> 并不能判断key-value不存在HashMap中。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V put(K <span class="variable">key</span>, V value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="built_in">int</span> hash = hash(<span class="variable">key</span>);</span><br><span class="line">    <span class="built_in">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">Object</span> k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.<span class="variable">key</span>) == <span class="variable">key</span> || <span class="variable">key</span>.equals(k))) &#123; <span class="comment">// 注意判断条件</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, <span class="variable">key</span>, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="putAll">putAll</h3><p>这里注意以下HashMap扩容的条件并不是<code>(m.size() + size) &gt;= threshold</code>，如果<code>m</code>中的key和hashmap中的key有重复，则可能导致不必要的扩容操作。<br>在这个方法里，扩容的条件计算非常保守，使得最多进行一次扩容一次。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeysToBeAdded = m.size();</span><br><span class="line">    <span class="keyword">if</span> (numKeysToBeAdded == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable((<span class="keyword">int</span>) Math.max(numKeysToBeAdded * loadFactor, threshold));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Expand the map if the map if the number of mappings to be added</span><br><span class="line">     * is greater than or equal to threshold.  This is conservative; the</span><br><span class="line">     * obvious condition is (m.size() + size) &gt;= threshold, but this</span><br><span class="line">     * condition could result in a map with twice the appropriate capacity,</span><br><span class="line">     * if the keys to be added overlap with the keys already in this map.</span><br><span class="line">     * By using the conservative calculation, we subject ourself</span><br><span class="line">     * to at most one extra resize.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (numKeysToBeAdded &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">int</span> targetCapacity = (<span class="keyword">int</span>)(numKeysToBeAdded / loadFactor + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (targetCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            targetCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = table.length;</span><br><span class="line">        <span class="keyword">while</span> (newCapacity &lt; targetCapacity)</span><br><span class="line">            newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; table.length)</span><br><span class="line">            resize(newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内部方法">内部方法</h2><h3 id="roundUpToPowerOf2">roundUpToPowerOf2</h3><p>给定一个非负整数，给出大于等于这个数的2的指数幂</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">int</span> roundUpToPowerOf2(<span class="built_in">int</span> <span class="keyword">number</span>) &#123;</span><br><span class="line">    // assert <span class="keyword">number</span> &gt;= <span class="number">0</span> : <span class="string">"number must be non-negative"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">number</span> &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (<span class="keyword">number</span> &gt; <span class="number">1</span>) ? <span class="type">Integer</span>.highestOneBit((<span class="keyword">number</span> - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="inflateTable">inflateTable</h3><p>扩容，容量是2的指数幂。扩容后，设置下一次需要扩容的阈值。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">//设置阈值：当size达到这个值时，再次扩容</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initHashSeedAsNeeded">initHashSeedAsNeeded</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing</span><br><span class="line">            ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</span><br><span class="line">            : 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getEntry">getEntry</h3><p>查找指定key对应的Entry。查找时，根据hash值找到table的index，然后沿着下拉链表一次顺序查找。如果没有找到，返回null。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(<span class="keyword">Object</span> <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> hash = (<span class="variable">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(<span class="variable">key</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        <span class="keyword">Object</span> k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k)))) <span class="comment">// 注意条件判断</span></span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="containsNullValue">containsNullValue</h3><p>这个方法用来查找value为null的情况，这样做是为了不在每次迭代都做类似<code>if (value == e.value || (value != null &amp;&amp; value.equals(e.value)))</code>的复杂判断，代码清晰很多。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> private boolean containsNullValue() &#123;</span><br><span class="line">    Entry[] <span class="keyword">tab</span> = <span class="keyword">table</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; <span class="keyword">tab</span>.length ; i++)</span><br><span class="line">        <span class="keyword">for</span> (Entry <span class="keyword">e</span> = <span class="keyword">tab</span>[i] ; <span class="keyword">e</span> != null ; <span class="keyword">e</span> = <span class="keyword">e</span>.next)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">e</span>.value == null)</span><br><span class="line">                <span class="keyword">return</span> true;</span><br><span class="line">    <span class="keyword">return</span> false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getForNullKey">getForNullKey</h3><p>当key为null的时候，挂在<code>table[0]</code>上，只需要查找<code>table[0]</code>上，key为null的元素Entry即可。如果没有，返回null。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> e.<span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hash">hash</h3><p>这个方法保证hashCode改变常数被，在hash值每一位上冲突的可能性在默认的填装因子下，碰撞的次数最高位8</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final int hash(Object k) &#123;</span><br><span class="line">    int <span class="keyword">h</span> = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (0 != <span class="keyword">h</span> &amp;&amp; k instanceof String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">h</span> ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    <span class="keyword">h</span> ^= (<span class="keyword">h</span> &gt;&gt;&gt; 20) ^ (<span class="keyword">h</span> &gt;&gt;&gt; 12);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">h</span> ^ (<span class="keyword">h</span> &gt;&gt;&gt; 7) ^ (<span class="keyword">h</span> &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：JDK1.7 HashMap源码阅读<br><strong>Abstract</strong>: Source code analysis of JDK1.7</p>]]>
    
    </summary>
    
      <category term="HashMap" scheme="http://zuoqy.com/tags/HashMap/"/>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="Java" scheme="http://zuoqy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Java泛型]]></title>
    <link href="http://zuoqy.com/2015/05/19/java-generic/"/>
    <id>http://zuoqy.com/2015/05/19/java-generic/</id>
    <published>2015-05-19T13:34:22.000Z</published>
    <updated>2018-09-26T15:22:33.366Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：泛型可以将某些类型相关的错误从运行时提前到编译时显现，但Java的泛型有很多特点和限制。本文介绍了泛型类型、原始类型、泛型方法、有界类型参数、泛型的继承和子类型、类型推断、通配符、类型擦除、非具体化类型和泛型的限制，之前用到的和以后要用的，都在这里了。<br><strong>Abstract</strong>: Java generics add stability to your code by making some bugs about types be detected early on complie-time. This article gives a comprehensive introduction to the important points Java generics.</p>
<h2 id="写在最前面">写在最前面</h2><p>一说泛型，好像都会。但前些天在看源码的时候，发现一个警告，引出了好多泛型的问题，最终让我下定决心整理一下Java泛型的坑（感谢Oracle，有一个很全面的Tutorial，Java编程思想都没有它介绍的详尽）。如果你也觉得你掌握了泛型，不妨试试以下问题，这些问题的解释，就包含在本篇文章里。</p>
<p>先看几个问题：</p>
<a id="more"></a>
<ol>
<li>程序会出错吗？如果出错，是编译时还是运行时呢？</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.util.List;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        i.<span class="keyword">set</span>(<span class="number">0</span>, i.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>下面的程序正确吗？</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaturalNumber</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NaturalNumber</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">this</span>.i = i; &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EvenNumber</span> <span class="keyword">extends</span> <span class="title">NaturalNumber</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EvenNumber</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">super</span>(i); &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Sting[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;EvenNumber&gt; le = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;? extends NaturalNumber&gt; ln = le;</span><br><span class="line">        ln.add(<span class="keyword">new</span> NaturalNumber(<span class="number">35</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>下面的程序呢？</li>
</ol>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">List</span>&lt;<span class="keyword">Integer</span>&gt; li = new ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">List</span>&lt;<span class="keyword">Number</span>&gt;  ln = (<span class="keyword">List</span>&lt;<span class="keyword">Number</span>&gt;) li;</span><br></pre></td></tr></table></figure>
<ol>
<li>下面那个能编译通过呢？</li>
</ol>
<p>a)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">rtti</span><span class="params">(List&lt;E&gt; <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> instanceof ArrayList&lt;Integer&gt;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b)</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void rtti(<span class="keyword">List</span><span class="preprocessor">&lt;?</span>&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">list</span> <span class="keyword">instanceof</span> ArrayList<span class="preprocessor">&lt;?</span>&gt;) &#123;  </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>下面的程序正确吗？</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> processStringList(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; stringList) &#123;</span><br><span class="line">    <span class="comment">// process stringList</span></span><br><span class="line">&#125;</span><br><span class="line">processStringList(Collections.emptyList());</span><br></pre></td></tr></table></figure>
<p>如果不对，报什么错误呢？</p>
<ol>
<li>下面的程序可以编译通过吗？</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser&lt;T</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Exception&gt;</span> &#123;</span></span><br><span class="line">    public void parse(<span class="type">File</span> file) <span class="keyword">throws</span> <span class="type">T</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>List&lt;Number&gt;</code> 是 <code>List&lt;Integer&gt;</code>的父类型吗？</p>
</li>
<li><p>最后一个问题，为什么Map.get方法没有完全泛型化，而Map.put是完全泛型化的？</p>
</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V <span class="function"><span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line">V <span class="function"><span class="title">get</span><span class="params">(Object key)</span></span></span><br></pre></td></tr></table></figure>
<p>这个题的答案很有意思，见<a href="#refs">参考文献2</a></p>
<h2 id="为什么使用泛型">为什么使用泛型</h2><p>简而言之，泛型就是在定义类、接口、方法的时候，可以把类型（types）作为参数。类型参数使相同的逻辑能够复用在不同类型的输入上。</p>
<h3 id="使用泛型的好处：">使用泛型的好处：</h3><ul>
<li>编译期强类型检查（编译期错误排查难度小于运行时错误）</li>
<li>去除类型转换</li>
</ul>
<pre><code><span class="built_in">List</span> <span class="built_in">list</span> <span class="subst">=</span> <span class="literal">new</span> ArrayList();
<span class="built_in">list</span><span class="built_in">.</span>add(<span class="string">"hello"</span>);
<span class="built_in">String</span> s <span class="subst">=</span> (<span class="built_in">String</span>) <span class="built_in">list</span><span class="built_in">.</span>get(<span class="number">0</span>);

<span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span> <span class="built_in">list</span> <span class="subst">=</span> <span class="literal">new</span> ArrayList<span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span>();
<span class="built_in">list</span><span class="built_in">.</span>add(<span class="string">"hello"</span>);
<span class="built_in">String</span> s <span class="subst">=</span> <span class="built_in">list</span><span class="built_in">.</span>get(<span class="number">0</span>);   <span class="comment">// no cast</span>
</code></pre><ul>
<li>方便开发泛型算法</li>
</ul>
<h2 id="泛型类型（Generic_Types）">泛型类型（Generic Types）</h2><p>泛型类型是通用类或者接口的参数化类型。</p>
<h3 id="简单的Box类">简单的Box类</h3><pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Box</span> {
    <span class="keyword">private</span> Object <span class="keyword">object</span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object <span class="keyword">object</span>)</span> </span>{ <span class="keyword">this</span>.<span class="keyword">object</span> = <span class="keyword">object</span>; }
    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="keyword">object</span>; }
}
</code></pre><p>因为类中的方法接受的参数类型是Object，所以可以接受任何类型的输入参数，。但是在编译期没有办法验证Box类是否被正确的使用了。如果期望从Box中获得一个Integer而却往Box中放入String类型的值，则会出现运行时错误。</p>
<h3 id="泛型版本的Box类">泛型版本的Box类</h3><p>泛型类/接口的定义如下：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">name</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, ..., <span class="title">Tn</span>&gt; </span>{ <span class="comment">/* ... */</span> }
<span class="class"><span class="keyword">interface</span> <span class="title">name</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, ..., <span class="title">Tn</span>&gt; </span>{ <span class="comment">/* ... */</span> }
</code></pre><p>尖括号中包含类型参数声明，分别是T1,T2…Tn</p>
<pre><code><span class="comment">/**
 * Generic version of the Box class.
 * @param &lt;T&gt; the type of the value being boxed
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>{
    <span class="comment">// T stands for "Type"</span>
    <span class="keyword">private</span> T t;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">set</span>(T t) { <span class="keyword">this</span>.t = t; }
    <span class="keyword">public</span> T <span class="keyword">get</span>() { <span class="keyword">return</span> t; }
}
</code></pre><p>正如上面代码所示，Object类型被替换为T，T是一个类型变量，代表任意非基本类型（non-primitive）。 作为一个例子，并没有问题，但是结合JDK源码，get方法一般不限定泛型，<a href="http://stackoverflow.com/questions/857420/what-are-the-reasons-why-map-getobject-key-is-not-fully-generic" target="_blank" rel="external">详见这里</a>。不要滥用泛型！</p>
<h3 id="类型参数命名惯例">类型参数命名惯例</h3><ul>
<li>E - Element (used extensively by the Java Collections Framework)</li>
<li>K - Key</li>
<li>N - Number</li>
<li>T - Type</li>
<li>V - Value</li>
<li>S,U,V etc. - 2nd, 3rd, 4th types</li>
</ul>
<h3 id="调用和实例化泛型类型">调用和实例化泛型类型</h3><pre><code><span class="built_in">Box</span>&lt;<span class="built_in">Integer</span>&gt; integerBox = new <span class="built_in">Box</span>&lt;<span class="built_in">Integer</span>&gt;();
</code></pre><blockquote>
<p><strong>类型形参（Type Parameter）</strong>和<strong>类型实参（Type Argument）</strong>：<code>Box&lt;T&gt;</code>中的T时类型形参，<code>Box&lt;Integer&gt;</code>中的Integer时类型实参。在能区分两者的语境中，经常不做区分的称为类型参数。</p>
</blockquote>
<p><a id="the-diamond" href="#the-diamond"></a></p>
<h3 id="The_Diamond">The Diamond</h3><p>在JDK7及以后的版本，调用和初始化泛型可以省略构造方法类型实参：</p>
<pre><code><span class="built_in">Box</span>&lt;<span class="built_in">Integer</span>&gt; integerBox = new <span class="built_in">Box</span>&lt;&gt;();
</code></pre><p>更多内容请参见<a href="#type-inference">类型推断（Type Inference）</a></p>
<h3 id="多个类型参数">多个类型参数</h3><pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{
    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedPair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{

    <span class="keyword">private</span> K key;
    <span class="keyword">private</span> V value;

    <span class="function"><span class="keyword">public</span> <span class="title">OrderedPair</span><span class="params">(K key, V value)</span> </span>{
    <span class="keyword">this</span>.key = key;
    <span class="keyword">this</span>.value = value;
    }

    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span>    </span>{ <span class="keyword">return</span> key; }
    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>{ <span class="keyword">return</span> value; }
}
</code></pre><p>可以这样实例化OrderedPair：</p>
<pre><code><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span> p1 <span class="subst">=</span> <span class="literal">new</span> OrderedPair<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span>(<span class="string">"Even"</span>, <span class="number">8</span>);
<span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span>  p2 <span class="subst">=</span> <span class="literal">new</span> OrderedPair<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span>(<span class="string">"hello"</span>, <span class="string">"world"</span>);
</code></pre><p>正如在<a href="#the-diamond">The Diamond</a>一节中所述的，可以将初始化构造方法类型参数省略：</p>
<pre><code>OrderedPair<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span> p1 <span class="subst">=</span> <span class="literal">new</span> OrderedPair<span class="subst">&lt;&gt;</span>(<span class="string">"Even"</span>, <span class="number">8</span>);
OrderedPair<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span>  p2 <span class="subst">=</span> <span class="literal">new</span> OrderedPair<span class="subst">&lt;&gt;</span>(<span class="string">"hello"</span>, <span class="string">"world"</span>);
</code></pre><h3 id="参数化类型嵌套">参数化类型嵌套</h3><pre><code>OrderedPair<span class="subst">&lt;</span><span class="built_in">String</span>, Box<span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;&gt;</span> p <span class="subst">=</span> <span class="literal">new</span> OrderedPair<span class="subst">&lt;&gt;</span>(<span class="string">"primes"</span>, <span class="literal">new</span> Box<span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;</span>(<span class="attribute">...</span>));
</code></pre><p><a id="raw-types" href="#raw-types"></a></p>
<h2 id="原始类型（Raw_Types）">原始类型（Raw Types）</h2><p>原始类型是没有任何类型实参的泛型类或泛型接口。例如:Box类定义如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>{
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">set</span>(T t) { <span class="comment">/* ... */</span> }
    <span class="comment">// ...</span>
}
</code></pre><p>如果类型实参被省略，则创建一个原始类型的Box：</p>
<pre><code><span class="built_in">Box</span> rawBox = new <span class="built_in">Box</span>();
</code></pre><p>上面的代码中，Box是<code>Box&lt;T&gt;</code>的原始类型。但如果Box不是泛型类，创建的对象就不能叫做Box的原始类型。JDK5及之前的代码不支持泛型，为了向前兼容设置的。把一个泛型对象赋值给原始类型引用是被允许的。</p>
<pre><code><span class="built_in">Box</span>&lt;<span class="built_in">String</span>&gt; stringBox = new <span class="built_in">Box</span>&lt;&gt;();
<span class="built_in">Box</span> rawBox = stringBox;               // OK
</code></pre><p>但是如果你将原始类型赋值给泛型引用，则会产生警告：</p>
<pre><code><span class="built_in">Box</span> rawBox = new <span class="built_in">Box</span>();           // rawBox is a raw <span class="keyword">type</span> of <span class="built_in">Box</span>&lt;T&gt;
<span class="built_in">Box</span>&lt;<span class="built_in">Integer</span>&gt; intBox = rawBox;     // warning: unchecked conversion
</code></pre><p>使用原始类型的引用去调用泛型类对象的方法，同样会得到警告：</p>
<pre><code>Box<span class="variable">&lt;String&gt;</span> stringBox = new Box<span class="variable">&lt;&gt;</span>();
Box rawBox = stringBox;
rawBox.<span class="built_in">set</span>(<span class="number">8</span>);  // warning: unchecked invocation <span class="keyword">to</span> <span class="built_in">set</span>(T)
</code></pre><p>原因是使用原始类型的引用去调用泛型类对象的方法，把可能的类型错误推迟到了运行时才能发现。在<a href="#type-erasure">类型擦除</a>部分，将详细介绍编译器如何使用原始类型的。</p>
<h3 id="未检查错误信息（Unchecked_Error_Messages）">未检查错误信息（Unchecked Error Messages）</h3><p>如上面提到的，如果你将泛型代码与遗留的非泛型代码混合使用，就会出现类似下面的编译警告信息：</p>
<pre><code>Note: Example.java <span class="keyword">uses</span> unchecked <span class="keyword">or</span> <span class="keyword">unsafe</span> operations.
Note: Recompile <span class="keyword">with</span> -Xlint:unchecked <span class="keyword">for</span> details.
</code></pre><p>如下面所示，当代码试图使用原始类型引用操作泛型类的对象时：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WarningDemo</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{
        Box&lt;Integer&gt; bi;
        bi = createBox();
    }

    <span class="function"><span class="keyword">static</span> Box <span class="title">createBox</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Box();
    }
}
</code></pre><p><em>unchecked</em>的意思是编译器没有得到足够的类型信息做必要的的类型检查以确保类型安全。尽管编译器会做出提示，但是unchecked警告默认是关闭的，如果需要查看详细的unchecked警告信息，需要在编译时加上<em>-Xlint:unchecked选项</em>。<br>重新编译后会得到像下面这样详细的提示结果：</p>
<pre><code><span class="rule"><span class="attribute">WarningDemo.java</span>:<span class="value"><span class="number">4</span>: warning: [unchecked] unchecked conversion
found   : Box
required: Box&lt;java.lang.Integer&gt;
        bi = <span class="function">createBox</span>()</span></span>;
                      ^
1 <span class="tag">warning</span>
</code></pre><p>当不需要unchecked警告信息的时候，需要显式的使用-Xlint:-unchecked编译选项，或者使用@SuppressWarnings(“unchecked”)注解。</p>
<p><a id="generic-methods" href="#generic-methods"></a></p>
<h2 id="泛型方法（Generic_Methods）">泛型方法（Generic Methods）</h2><p>泛型方法是自身引入类型参数的方法。与泛型类和接口引入的泛型参数不同，其作用范围只在方法声明范围内有效。静态方法、非静态方法以及泛型类的构造方法都可以声明为泛型方法。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>{
    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)</span> </span>{ <span class="comment">//静态泛型方法</span>
        <span class="keyword">return</span> p1.getKey().equals(p2.getKey()) &amp;&amp;
               p1.getValue().equals(p2.getValue());
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{

    <span class="keyword">private</span> K key;
    <span class="keyword">private</span> V value;

    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K key, V value)</span> </span>{
        <span class="keyword">this</span>.key = key;
        <span class="keyword">this</span>.value = value;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span> </span>{ <span class="keyword">this</span>.key = key; }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>{ <span class="keyword">this</span>.value = value; }
    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span>   </span>{ <span class="keyword">return</span> key; }
    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>{ <span class="keyword">return</span> value; }
}
</code></pre><p>调用上述静态泛型方法的正确语法如下：</p>
<pre><code><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, <span class="built_in">String</span><span class="subst">&gt;</span> p1 <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;&gt;</span>(<span class="number">1</span>, <span class="string">"apple"</span>);
<span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, <span class="built_in">String</span><span class="subst">&gt;</span> p2 <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;&gt;</span>(<span class="number">2</span>, <span class="string">"pear"</span>);
<span class="built_in">boolean</span> same <span class="subst">=</span> Util<span class="built_in">.</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, <span class="built_in">String</span><span class="subst">&gt;</span>compare(p1, p2);  <span class="comment">//在.和方法名之间加入&lt;&gt;</span>
</code></pre><p>一般情况下，编译器会做<a href="#type-inference">类型推断</a>，调用泛型方法时可以不写全。</p>
<pre><code><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, <span class="built_in">String</span><span class="subst">&gt;</span> p1 <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;&gt;</span>(<span class="number">1</span>, <span class="string">"apple"</span>);
<span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, <span class="built_in">String</span><span class="subst">&gt;</span> p2 <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;&gt;</span>(<span class="number">2</span>, <span class="string">"pear"</span>);
<span class="built_in">boolean</span> same <span class="subst">=</span> Util<span class="built_in">.</span>compare(p1, p2);
</code></pre><h2 id="有界类型参数（Bounded_Type_Parameters）">有界类型参数（Bounded Type Parameters）</h2><p>在有些时候，我们想限制类型参数的范围，比如针对Numbers的泛型方法，想限制直接收Numbers和它的所有子类型。这就需要限定泛型参数的界限。<br>在声明类型参数的时候，可以使用<em>extends XXX</em>（对类和接口来说都应该使用该关键字）限定类型参数的上限是XXX。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>{

    <span class="keyword">private</span> T t;          

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">set</span>(T t) {
        <span class="keyword">this</span>.t = t;
    }

    <span class="keyword">public</span> T <span class="keyword">get</span>() {
        <span class="keyword">return</span> t;
    }

    <span class="keyword">public</span> &lt;U <span class="keyword">extends</span> Number&gt; <span class="keyword">void</span> inspect(U u){
        System.out.println(<span class="string">"T: "</span> + t.getClass().getName());
        System.out.println(<span class="string">"U: "</span> + u.getClass().getName());
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();
        integerBox.<span class="keyword">set</span>(<span class="keyword">new</span> Integer(<span class="number">10</span>));
        integerBox.inspect(<span class="string">"some text"</span>); <span class="comment">// error: this is still String!</span>
    }
}
</code></pre><p>编译器会提示如下的编译错误：</p>
<pre><code>Box.java:21: &lt;<span class="keyword">U</span>&gt;<span class="keyword">inspect</span>(<span class="keyword">U</span>) <span class="keyword">in</span> Box&lt;java.lang.Integer&gt; cannot
  be applied to (java.lang.String)
                        integerBox.<span class="keyword">inspect</span>(<span class="string">"some text"</span>);
                                  ^
1 <span class="keyword">error</span>
</code></pre><p>除了限定类型，你还可以实例化一个泛型类型。</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">NaturalNumber&lt;T</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Integer&gt;</span> {</span>

    <span class="keyword">private</span> <span class="type">T</span> n;

    public <span class="type">NaturalNumber</span>(<span class="type">T</span> n)  { <span class="keyword">this</span>.n = n; }

    public boolean isEven() {
        <span class="keyword">return</span> n.intValue() % <span class="number">2</span> == <span class="number">0</span>;
    }

    <span class="comment">// ...</span>
}
</code></pre><h3 id="多个界限（Multiple_Bounds）">多个界限（Multiple Bounds）</h3><p>一个类型参数可以有多个界限：</p>
<pre><code>&lt;T <span class="keyword">extends</span> B1 &amp; B2 &amp; B3&gt;
</code></pre><p>表示T的上界是B1或者B2或者B3，如果其中一个类型参数是类，则必须放在第一个：</p>
<pre><code><span class="type">Class</span> <span class="type">A</span> { <span class="comment">/* ... */</span> }
interface <span class="type">B</span> { <span class="comment">/* ... */</span> }
interface <span class="type">C</span> { <span class="comment">/* ... */</span> }
<span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="title">&lt;T</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">A</span> <span class="title">&amp;</span> <span class="title">B</span> <span class="title">&amp;</span> <span class="title">C&gt;</span> {</span> <span class="comment">/* ... */</span> }  <span class="comment">// OK</span>
<span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="title">&lt;T</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">B</span> <span class="title">&amp;</span> <span class="title">A</span> <span class="title">&amp;</span> <span class="title">C&gt;</span> {</span> <span class="comment">/* ... */</span> }  <span class="comment">// compile-time error</span>
</code></pre><h3 id="有界类型参数和泛型方法">有界类型参数和泛型方法</h3><pre><code><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">int</span> countGreaterThan(T[] anArray, T elem) {
    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
    <span class="keyword">for</span> (T e : anArray)
        <span class="keyword">if</span> (e &gt; elem)  <span class="comment">// compiler error</span>
            ++<span class="keyword">count</span>;
    <span class="keyword">return</span> <span class="keyword">count</span>;
}
</code></pre><p>上面的代码会产生编译错误，原因是&gt;运算符只能用于比较基本类型（Primitive Types）如：short, int, double, long, float, byte, 和 char。<br>解决这个问题，可以使用上界为<code>Comparable&lt;T&gt;</code>的类型参数：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> Comparable&lt;T&gt; {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">compareTo</span>(T o);
}

<span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Comparable&lt;T&gt;&gt; <span class="keyword">int</span> countGreaterThan(T[] anArray, T elem) {
    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
    <span class="keyword">for</span> (T e : anArray)
        <span class="keyword">if</span> (e.<span class="keyword">compareTo</span>(elem) &gt; <span class="number">0</span>)
            ++<span class="keyword">count</span>;
    <span class="keyword">return</span> <span class="keyword">count</span>;
}
</code></pre><p><a id="g-i-s" href="#g-i-s"></a></p>
<h2 id="泛型、继承和子类型（Generics,_Inheritance,_and_Subtypes）">泛型、继承和子类型（Generics, Inheritance, and Subtypes）</h2><p>如果两个类型兼容，可以把一个类型的对象赋予另个一类型的引用。例如：</p>
<pre><code><span class="built_in">Object</span> someObject = <span class="keyword">new</span> <span class="built_in">Object</span>();
Integer someInteger = <span class="keyword">new</span> Integer(<span class="number">10</span>);
someObject = someInteger;   <span class="comment">// OK</span>
</code></pre><p>在面向对象术语中成为：<em>“Is-a”</em>关系。因为Integer类型也是一种Object类型。下面的代码也成立，因为Double和Integer都是Number：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(Number n)</span> </span>{ <span class="comment">/* ... */</span> }

someMethod(<span class="keyword">new</span> Integer(<span class="number">10</span>));   <span class="comment">// OK</span>
someMethod(<span class="keyword">new</span> Double(<span class="number">10.1</span>));   <span class="comment">// OK</span>
</code></pre><p>以上继承规则对于类型参数来说也是成立的，你可以想Box中添加任何和Number兼容的子类型：</p>
<pre><code>Box&lt;Number&gt; <span class="built_in">box</span> = <span class="keyword">new</span> Box&lt;Number&gt;();
<span class="built_in">box</span>.<span class="built_in">add</span>(<span class="keyword">new</span> Integer(<span class="number">10</span>));   <span class="comment">// OK</span>
<span class="built_in">box</span>.<span class="built_in">add</span>(<span class="keyword">new</span> Double(<span class="number">10.1</span>));  <span class="comment">// OK</span>
</code></pre><p>但是考虑如下的方法：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">boxTest</span><span class="params">(Box&lt;Number&gt; n)</span> </span>{ <span class="comment">/* ... */</span> }
</code></pre><p>boxTest方法会接受什么类型的参数？如果传入<code>Box&lt;Integer&gt;</code>或者<code>Box&lt;Double&gt;</code>可以吗？答案是<em>不可以</em>，因为<strong><code>Box&lt;Integer&gt;</code>和<code>Box&lt;Double&gt;</code>不是<code>Box&lt;Number&gt;</code>的子类型</strong>！</p>
<p><img src="http://zuoqy.com/images/2015-05-19/1.png" alt="generic subtypes"></p>
<blockquote>
<p>注意：给定两个具体类型A和B（如：Integer和Double），无论A，B两个类有什么样的关系，<code>MyClass&lt;A&gt;</code> 和 <code>MyClass&lt;B&gt;</code> 两个类没有任何关系，他们唯一相同的父类就是Object。关于如何创建一个泛型类的子类型，参见<a href="#wildcards-and-subtyping">通配符和子类型</a></p>
</blockquote>
<h3 id="泛型类和子类型">泛型类和子类型</h3><p>你可以通过继承泛型类或者实现泛型接口来创建一个泛型类或者泛型接口的子类型（subtype）。以Java集合类为例：</p>
<p><img src="http://zuoqy.com/images/2015-05-19/2.png" alt="Collections hierarchy"></p>
<p>若自己实现一个PayloadList类：</p>
<pre><code><span class="class"><span class="keyword">interface</span> <span class="title">PayloadList</span>&lt;<span class="title">E</span>,<span class="title">P</span>&gt; <span class="keyword">extends</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>{
  <span class="keyword">void</span> setPayload(<span class="keyword">int</span> <span class="keyword">index</span>, P val);
  ...
}
</code></pre><p>以下类型实参的PayLoadList是ListString&gt;的子类型（subtype）：</p>
<pre><code>PayloadList&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt;
PayloadList&lt;<span class="built_in">String</span>,<span class="built_in">Integer</span>&gt;
PayloadList&lt;<span class="built_in">String</span>,<span class="built_in">Exception</span>&gt;
</code></pre><p>而任何<code>PayloadList&lt;XXX,...&gt;</code>都不是<code>List&lt;String&gt;</code>的子类型。</p>
<p><a id="type-inference" href="#type-inference"></a></p>
<h2 id="类型推断（Type_Inference）">类型推断（Type Inference）</h2><p>类型推断是Java编译器根据方法调用和相应的声明去推断类型实参的过程。类型推断算法往往取决于实参类型、赋值操作等号右边的类型或返回值类型。最后，类型推断算法会找到适合所有条件的最具体的类型作为推断结果。<br>例如，下面的例子，类型推断的结果是Serializable：</p>
<pre><code>static &lt;<span class="literal">T</span>&gt; <span class="literal">T</span> pick(<span class="literal">T</span> a1, <span class="literal">T</span> a2) { <span class="keyword">return</span> a2; }
Serializable s = pick(<span class="string">"d"</span>, new ArrayList&lt;String&gt;());
</code></pre><h3 id="泛型方法的类型推断">泛型方法的类型推断</h3><p><a href="#generic-methods">泛型方法</a>引入了类型推断，类型推断使你能够像调用普通方法那样调用泛型方法，如下代码所示：</p>
<pre><code><span class="keyword">public</span> class BoxDemo {

  <span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="keyword">void</span> addBox(U u, 
      java.util.List&lt;Box&lt;U&gt;&gt; boxes) {
    Box&lt;U&gt; <span class="built_in">box</span> = <span class="keyword">new</span> Box&lt;&gt;();
    <span class="built_in">box</span>.<span class="built_in">set</span>(u);
    boxes.<span class="built_in">add</span>(<span class="built_in">box</span>);
  }

  <span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="keyword">void</span> outputBoxes(java.util.List&lt;Box&lt;U&gt;&gt; boxes) {
    <span class="built_in">int</span> counter = <span class="number">0</span>;
    <span class="keyword">for</span> (Box&lt;U&gt; <span class="built_in">box</span>: boxes) {
      U boxContents = <span class="built_in">box</span>.<span class="built_in">get</span>();
      System.out.<span class="built_in">println</span>(<span class="string">"Box #"</span> + counter + <span class="string">" contains ["</span> +
             boxContents.toString() + <span class="string">"]"</span>);
      counter++;
    }
  }

  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {
    java.util.ArrayList&lt;Box&lt;Integer&gt;&gt; listOfIntegerBoxes =
      <span class="keyword">new</span> java.util.ArrayList&lt;&gt;();
    BoxDemo.&lt;Integer&gt;addBox(Integer.valueOf(<span class="number">10</span>), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(<span class="number">20</span>), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(<span class="number">30</span>), listOfIntegerBoxes);
    BoxDemo.outputBoxes(listOfIntegerBoxes);
  }
}
</code></pre><p>代码输出：</p>
<pre><code><span class="tag">Box</span> <span class="id">#0</span> <span class="tag">contains</span> <span class="attr_selector">[10]</span>
<span class="tag">Box</span> <span class="id">#1</span> <span class="tag">contains</span> <span class="attr_selector">[20]</span>
<span class="tag">Box</span> <span class="id">#2</span> <span class="tag">contains</span> <span class="attr_selector">[30]</span>
</code></pre><p>泛型方法<em>addBox</em>定义了类型形参U，通常Java编译器可以通过方法调用推断类型实参，所以在多数情况下，不需要指定类型实参。例如调用方法addBox时，可以像这样指定类型实参：</p>
<pre><code>BoxDemo.&lt;<span class="type">Integer</span>&gt;addBox(<span class="type">Integer</span>.valueOf(<span class="number">10</span>), listOfIntegerBoxes);
</code></pre><p>也可以不指定，由编译器根据参数类型推断类型实参为Integer：</p>
<pre><code>BoxDemo.addBox(<span class="type">Integer</span>.valueOf(<span class="number">20</span>), listOfIntegerBoxes);
</code></pre><h3 id="构造方法的类型推断">构造方法的类型推断</h3><p>如果编译器可以根据上下文推断类型实参，则可以在调用构造方法时省略类型实参，例如：</p>
<pre><code><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; myMap = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt;();
</code></pre><p>也可以写成这样：</p>
<pre><code><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; myMap = <span class="keyword">new</span> HashMap&lt;&gt;();
</code></pre><p>但是为了能够使编译器进行类型推断，调用构造方法的时候必须使用<a href="#the-diamond">the diamond</a>，否则编译器报编译警告：</p>
<pre><code><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; myMap = <span class="keyword">new</span> HashMap(); <span class="comment">// unchecked conversion warning</span>
</code></pre><p>原因是HashMap()构造方法是HashMap<string, list<string="">&gt;的原始类型（<a href="#raw-types">raw types</a>）</string,></p>
<blockquote>
<p>无论在泛型类还是在非泛型类中，都可以存在泛型构造方法：</p>
</blockquote>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="inheritance">&lt;<span class="parent">X</span></span>&gt; {</span>
  &lt;<span class="constant">T</span>&gt; <span class="constant">MyClass</span>(<span class="constant">T</span> t) {
    <span class="regexp">//</span> ...
  }
}
</code></pre><p>初始化MyClass实例：</p>
<pre><code><span class="keyword">new</span> <span class="keyword">MyClass</span>&lt;<span class="built_in">Integer</span>&gt;(<span class="string">""</span>)
</code></pre><p>上面的语句创建了<code>MyClass&lt;Integer&gt;</code>的对象，显式的指明泛型类<code>MyClass&lt;X&gt;</code>的类型实参是Integer。但是MyClass的构造方法包含类型形参T并没有被显式的赋值。编译器通过传入构造方法的String类型的参数推断类型参数T的实参是String类型。<br>在Java SE 7 之前的版本，编译器已经具备推断泛型构造方法类型实参的能力，Java SE 7及之后的版本，编译器可以推断泛型类的类型实参（必须使用<a href="#the-diamond">the diamond</a>）</p>
<pre><code><span class="keyword">MyClass</span>&lt;<span class="built_in">Integer</span>&gt; myObject = <span class="keyword">new</span> <span class="keyword">MyClass</span>&lt;&gt;(<span class="string">""</span>);
</code></pre><p>上面的语句，编译器既可以推断出泛型类的类型实参，也可以推断出泛型构造方法的类型实参。</p>
<blockquote>
<p>注意：类型推断算法只使用<em>调用参数</em>、<em>目标类型</em>和<em>明显知道类型的返回值</em>来推断类型实参，推断算法不会使用当前程序之后的程序段对类型做推断。</p>
</blockquote>
<h3 id="目标类型">目标类型</h3><p>Java编译器利用目标类型推断泛型方法调用时的参数类型。表达式的目标类型是Java编译器根据表达式出现的位置，<strong>期望的表达式的类型</strong>。例如：有Collections.emptyList()方法的声明如下：</p>
<pre><code>static <span class="tag">&lt;<span class="title">T</span>&gt;</span> List<span class="tag">&lt;<span class="title">T</span>&gt;</span> emptyList();
</code></pre><p>若有以下的赋值语句：</p>
<pre><code><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; listOne = Collections.emptyList();
</code></pre><p>则期望的结果类型是<code>List&lt;String&gt;</code>；此类型即为目标类型。因为方法emptyList返回一个<code>List&lt;T&gt;</code>类型的值，编译器推断类型形参T一定是String。此机制Java SE 7 和 Java SE 8 都适用当然你也可以显示的指定泛型方法的类型参数：</p>
<pre><code><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; listOne = Collections.&lt;<span class="built_in">String</span>&gt;emptyList();
</code></pre><p>当然，这在上下文语境中并<strong>不是必须的</strong>。但在下面的情况下：</p>
<pre><code><span class="keyword">void</span> processStringList(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; stringList) {
    <span class="comment">// process stringList</span>
}
</code></pre><p>将设你想调用方法processStringList，传入一个空list，在Java SE 7中，下面的语句会出现编译错误：</p>
<pre><code>processStringList<span class="list">(<span class="keyword">Collections</span>.emptyList<span class="list">()</span>)</span><span class="comment">;</span>
</code></pre><p>错误大致是：</p>
<pre><code><span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; cannot be converted to <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;
</code></pre><p>编译器需要类型实参T，所以被默认当成<code>List&lt;Object&gt;</code>，进而emptyList方法返回<code>List&lt;Object&gt;</code>类型的结果，和processStringList方法的参数类型不兼容。因此，在Java SE 7中，必须指定类型参数的值的值：</p>
<pre><code>processStringList<span class="list">(<span class="keyword">Collections</span>.&lt;String&gt;emptyList<span class="list">()</span>)</span><span class="comment">;</span>
</code></pre><p>这种情况在Java SE 8中将不复存在，在Java SE 8中，<em>目标类型</em>的范围被扩展到包括方法参数。即可以通过形参的类型参数推断返回值的类型参数。<br>因为形参是<code>List&lt;String&gt;</code>,Collections.emptyList返回<code>List&lt;T&gt;</code>类型的结果，<code>List&lt;String&gt;</code>被作为目标类型，编译器推断T为String类型。因此，下面的语句在Java SE 8中可以编译通过：</p>
<pre><code>processStringList<span class="list">(<span class="keyword">Collections</span>.emptyList<span class="list">()</span>)</span><span class="comment">;</span>
</code></pre><h2 id="通配符（Wildcard）">通配符（Wildcard）</h2><p>泛型编程中，把问号（?）称为<em>通配符</em>，表示未知类型。通配符在很多情况下会用到：类型参数、属性、局部变量，甚至是返回类型（尽管明确的返回值类型才是好的编程习惯）。但<em>绝不会用于</em>：泛型方法调用的类型实参、泛型类实例化、超类型（supertype）。</p>
<h3 id="有上界的通配符">有上界的通配符</h3><p>你可以通过上界通配符减轻泛型对变量类型的限制。例如，你希望一个泛型方法同时能处理<code>List&lt;Integer&gt;</code>, <code>List&lt;Double&gt;</code> 和 <code>List&lt;Number&gt;</code>，你可以使用上界通配符。<br>应使用<em>?</em>和<em>extends</em>关键字（无论接口还是类），例如<code>List&lt;? extends Number&gt;</code>。 <code>List&lt;Number&gt;</code> 比<code>List&lt;? extends Number&gt;</code>的限制更严格。因为前者的匹配类型只有Number类型，而后者任何Number和Number的子类型都适用。<br>下面的process方法可以处理类型是任何Foo类或者Foo类的子类型。</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;? extends Foo&gt; <span class="built_in">list</span>)</span> </span>{
    <span class="keyword">for</span> (Foo elem : <span class="built_in">list</span>) {
        <span class="comment">// ...</span>
    }
}
</code></pre><p>下面的sumOfList方法, <code>List&lt;Integer&gt;</code> 和 <code>List&lt;Double&gt;</code>都适用：</p>
<pre><code>public static double sumOfList(<span class="keyword">List</span>&lt;? extends Number&gt; <span class="keyword">list</span>) {
    double s = 0.0;
    <span class="keyword">for</span> (Number <span class="keyword">n</span> : <span class="keyword">list</span>)
        s += <span class="keyword">n</span>.doubleValue();
    <span class="keyword">return</span> s;
}

<span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">li</span> = Arrays.asList(1, 2, 3);
System.<span class="keyword">out</span>.println(<span class="string">"sum = "</span> + sumOfList(<span class="keyword">li</span>));

<span class="keyword">List</span>&lt;Double&gt; ld = Arrays.asList(1.2, 2.3, 3.5);
System.<span class="keyword">out</span>.println(<span class="string">"sum = "</span> + sumOfList(ld));
</code></pre><h3 id="无界通配符">无界通配符</h3><p>无界通配符用一个单独的<em>?</em>表示，例如<code>List&lt;?&gt;</code>表示未知类型的List，一般无界通配符用于以下两个场景：</p>
<ul>
<li>如果你正在写可以使用Object类提供的功能来实现的方法。</li>
<li>当使用泛型类中的不依赖于类型参数的方法时，例如List.size和List.clear. <code>Class&lt;?&gt;</code>经常被使用，因为<code>Class&lt;T&gt;</code>类中的大部分方法和类型参数T无关。</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> printList(List&lt;<span class="keyword">Object</span>&gt; list) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">Object</span> elem : list)</span><br><span class="line">        System.out.<span class="built_in">println</span>(elem + <span class="string">" "</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上面的printList目的是打印任何类型的对象列表的话，是实现不了的。原因是<code>List&lt;Integer&gt;</code>, <code>List&lt;String&gt;</code>, <code>List&lt;Double&gt;</code>等都不是<code>List&lt;Object&gt;</code>的子类型。如果需要打印任何类型的对象，需要使用通配符：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> void printList(<span class="keyword">List</span><span class="preprocessor">&lt;?</span>&gt; <span class="keyword">list</span>) {
    <span class="keyword">for</span> (Object elem: <span class="keyword">list</span>)
        System.out.<span class="keyword">print</span>(elem + <span class="string">" "</span>);
    System.out.println();
}
</code></pre><p>因为对于任意的具体类型T来说，<code>List&lt;T&gt;</code>是<code>List&lt;?&gt;</code>的子类型，你可以使用printList方法打印任意类型的对象列表。</p>
<pre><code><span class="keyword">List</span>&lt;<span class="keyword">Integer</span>&gt; li = <span class="keyword">Arrays</span>.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);
<span class="keyword">List</span>&lt;<span class="keyword">String</span>&gt;  ls = <span class="keyword">Arrays</span>.asList(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>);
printList(li);
printList(ls);
</code></pre><blockquote>
<p>需要注意<code>List&lt;Object&gt;</code> 和 <code>List&lt;?&gt;</code>是不同的，你可以向<code>List&lt;Object&gt;</code>中插入任何Object的子类型的对象，但是你只能向<code>List&lt;?&gt;</code>中插入null。更多关于通配符应该在什么情况下使用，请参见<a href="#wildcards-guideline">通配符使用指南</a></p>
</blockquote>
<h3 id="有下界的通配符">有下界的通配符</h3><p>和有上界的通配符相反，有下界的通配符使用<code>&lt;? super A&gt;</code> 表示通配符的下界是A。</p>
<blockquote>
<p>注意，你可以指定上界，也可以指定下界，但是不同同时指定两者。</p>
</blockquote>
<p>如果你想要一个方法能够处理Integer类型以及所有Integer类型的父类，则可以使用有下界的通配符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNumbers</span><span class="params">(List&lt;? super Integer&gt; <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="wildcards-and-subtyping" href="#wildcards-and-subtyping"></a></p>
<h3 id="通配符和子类型">通配符和子类型</h3><p>在<a href="#g-i-s">泛型、继承和子类型</a>一节，我们曾经说过，仅仅类型参数有继承关系的泛型类或者泛型接口之间没有任何继承关系。但是你可以通过通配符建立泛型类和接口之间的继承关系。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">A</span> &#123;</span> <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>则你可以这样写代码：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B b = new B()<span class="comment">;</span></span><br><span class="line"><span class="literal">A</span> <span class="literal">a</span> = b<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>对于普通的类来说，子类型规则是成立的：如果B继承A，那么B是A的子类型。但是这个规则对于泛型类型来说，不适用。</p>
<p>Integer是Number类的子类，<code>List&lt;Integer&gt;</code>和<code>List&lt;Number&gt;</code>是什么关系？</p>
<p><img src="http://zuoqy.com/images/2015-05-19/3.png" alt="subtype"></p>
<p>尽管Integer是Number的子类型，但是<code>List&lt;Integer&gt;</code>和<code>List&lt;Number&gt;</code>并没有继承关系。它们之间仅有的关系就是共同的父类是<code>List&lt;?&gt;</code>.<br>下图说明了有上下界通配符的泛型类之间的继承关系：</p>
<p><img src="http://zuoqy.com/images/2015-05-19/4.png" alt="subtype-wildcard"></p>
<p>在<a href="#wildcards-guidline">通配符使用指南</a>一节，将介绍更多关于上下界通配符的使用方法。</p>
<h3 id="通配符捕获和辅助方法">通配符捕获和辅助方法</h3><p>在某些情况下，编译器会推断通配符的类型。例如，一个列表被定义为<code>List&lt;?&gt;</code>，当计算表达式的值的时候，编译器会根据代码推断出特定的类型。这种场景就叫做<em>通配符捕获（Wildcard Capture）</em>。<br>在大部分情况下，你都不需要关注通配符捕获，除非你得到包含<em>capture of</em>的错误提示。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.util.List;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardError</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        i.<span class="keyword">set</span>(<span class="number">0</span>, i.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，编译器处理输入参数i时，把它的类型参数当成Object，当触发<code>List.set(int,E)</code>时，编译器无法确定set进list中的对象类型，从而报错。当有类型错误提示的时候，往往是编译器认为你对变量设置了错误的类型。添加泛型，正是为了解决编译期类型检查。<br>例如使用JDK 7编译上面的代码的时候，会提示如下的错误：</p>
<pre><code>WildcardError.java:<span class="number">6</span>: error: <span class="function"><span class="keyword">method</span> <span class="title">set</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="title">cannot</span> <span class="title">be</span> <span class="title">applied</span> <span class="title">to</span> <span class="title">given</span> <span class="title">types</span>;</span>
    i.<span class="keyword">set</span>(<span class="number">0</span>, i.get(<span class="number">0</span>));
     ^
  required: int,CAP<span class="string">#1</span>
  found: int,Object
  reason: actual argument Object cannot be converted <span class="keyword">to</span> CAP<span class="string">#1</span> <span class="keyword">by</span> <span class="function"><span class="keyword">method</span> <span class="title">invocation</span> <span class="title">conversion</span>
  <span class="title">where</span> <span class="title">E</span> <span class="title">is</span> <span class="title">a</span> <span class="title">type</span>-<span class="title">variable</span>:</span>
    E extends Object declared <span class="keyword">in</span> <span class="keyword">interface</span> List
  <span class="keyword">where</span> CAP<span class="string">#1</span> <span class="keyword">is</span> a fresh <span class="keyword">type</span>-variable:
    CAP<span class="string">#1</span> extends Object <span class="keyword">from</span> capture <span class="keyword">of</span> ?
<span class="number">1</span> error
</code></pre><p>你可以写一个私有的辅助方法来解决上面的错误：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WildcardFixed</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(List&lt;?&gt; i)</span> </span>&#123;</span><br><span class="line">        fooHelper(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helper method created so that the wildcard can be captured</span></span><br><span class="line">    <span class="comment">// through type inference.</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fooHelper</span><span class="params">(List&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        l.<span class="keyword">set</span>(<span class="number">0</span>, l.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>辅助方法使编译器能够通过类型推断，得到T的类型是<code>CAP#1</code>。辅助方法惯例命名方式<code>originalMethodNameHelper</code>。<br>再看一个稍微复杂的例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">import</span> java.util.<span class="built_in">List</span>;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">WildcardErrorBad</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> swapFirst(<span class="built_in">List</span>&lt;? <span class="keyword">extends</span> Number&gt; l1, <span class="built_in">List</span>&lt;? <span class="keyword">extends</span> Number&gt; l2) &#123;</span><br><span class="line">      Number temp = l1.<span class="literal">get</span>(<span class="number">0</span>);</span><br><span class="line">      l1.<span class="literal">set</span>(<span class="number">0</span>, l2.<span class="literal">get</span>(<span class="number">0</span>)); <span class="comment">// expected a CAP#1 extends Number,</span></span><br><span class="line">                            <span class="comment">// got a CAP#2 extends Number;</span></span><br><span class="line">                            <span class="comment">// same bound, but different types</span></span><br><span class="line">      l2.<span class="literal">set</span>(<span class="number">0</span>, temp);	    <span class="comment">// expected a CAP#1 extends Number,</span></span><br><span class="line">                            <span class="comment">// got a Number</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子尝试不安全的操作，例如用下面的方式调用<code>swapFirst</code>方法：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">List</span>&lt;<span class="keyword">Integer</span>&gt; li = <span class="keyword">Arrays</span>.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">List</span>&lt;Double&gt;  ld = <span class="keyword">Arrays</span>.asList(<span class="number">10.10</span>, <span class="number">20.20</span>, <span class="number">30.30</span>);</span><br><span class="line">swapFirst(li, ld);</span><br></pre></td></tr></table></figure>
<p>尽管<code>List&lt;Integer&gt;</code>和<code>List&lt;Double&gt;</code>都满足<code>List&lt;? extends Number&gt;</code>的类型限制，但试图把Integer列表中的元素放入Double类型的列表中肯定是错误的。<br>JDk javac程序编译以上代码会报类似下面的错误：</p>
<pre><code>WildcardErrorBad.java:<span class="number">7</span>: error: <span class="function"><span class="keyword">method</span> <span class="title">set</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="title">cannot</span> <span class="title">be</span> <span class="title">applied</span> <span class="title">to</span> <span class="title">given</span> <span class="title">types</span>;</span>
      l1.<span class="keyword">set</span>(<span class="number">0</span>, l2.get(<span class="number">0</span>)); <span class="comment">// expected a CAP#1 extends Number,</span>
        ^
  required: int,CAP<span class="string">#1</span>
  found: int,Number
  reason: actual argument Number cannot be converted <span class="keyword">to</span> CAP<span class="string">#1</span> <span class="keyword">by</span> <span class="function"><span class="keyword">method</span> <span class="title">invocation</span> <span class="title">conversion</span>
  <span class="title">where</span> <span class="title">E</span> <span class="title">is</span> <span class="title">a</span> <span class="title">type</span>-<span class="title">variable</span>:</span>
    E extends Object declared <span class="keyword">in</span> <span class="keyword">interface</span> List
  <span class="keyword">where</span> CAP<span class="string">#1</span> <span class="keyword">is</span> a fresh <span class="keyword">type</span>-variable:
    CAP<span class="string">#1</span> extends Number <span class="keyword">from</span> capture <span class="keyword">of</span> ? extends Number
WildcardErrorBad.java:<span class="number">10</span>: error: <span class="function"><span class="keyword">method</span> <span class="title">set</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="title">cannot</span> <span class="title">be</span> <span class="title">applied</span> <span class="title">to</span> <span class="title">given</span> <span class="title">types</span>;</span>
      l2.<span class="keyword">set</span>(<span class="number">0</span>, temp);      <span class="comment">// expected a CAP#1 extends Number,</span>
        ^
  required: int,CAP<span class="string">#1</span>
  found: int,Number
  reason: actual argument Number cannot be converted <span class="keyword">to</span> CAP<span class="string">#1</span> <span class="keyword">by</span> <span class="function"><span class="keyword">method</span> <span class="title">invocation</span> <span class="title">conversion</span>
  <span class="title">where</span> <span class="title">E</span> <span class="title">is</span> <span class="title">a</span> <span class="title">type</span>-<span class="title">variable</span>:</span>
    E extends Object declared <span class="keyword">in</span> <span class="keyword">interface</span> List
  <span class="keyword">where</span> CAP<span class="string">#1</span> <span class="keyword">is</span> a fresh <span class="keyword">type</span>-variable:
    CAP<span class="string">#1</span> extends Number <span class="keyword">from</span> capture <span class="keyword">of</span> ? extends Number
WildcardErrorBad.java:<span class="number">15</span>: error: <span class="function"><span class="keyword">method</span> <span class="title">set</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="title">cannot</span> <span class="title">be</span> <span class="title">applied</span> <span class="title">to</span> <span class="title">given</span> <span class="title">types</span>;</span>
        i.<span class="keyword">set</span>(<span class="number">0</span>, i.get(<span class="number">0</span>));
         ^
  required: int,CAP<span class="string">#1</span>
  found: int,Object
  reason: actual argument Object cannot be converted <span class="keyword">to</span> CAP<span class="string">#1</span> <span class="keyword">by</span> <span class="function"><span class="keyword">method</span> <span class="title">invocation</span> <span class="title">conversion</span>
  <span class="title">where</span> <span class="title">E</span> <span class="title">is</span> <span class="title">a</span> <span class="title">type</span>-<span class="title">variable</span>:</span>
    E extends Object declared <span class="keyword">in</span> <span class="keyword">interface</span> List
  <span class="keyword">where</span> CAP<span class="string">#1</span> <span class="keyword">is</span> a fresh <span class="keyword">type</span>-variable:
    CAP<span class="string">#1</span> extends Object <span class="keyword">from</span> capture <span class="keyword">of</span> ?
<span class="number">3</span> errors
</code></pre><p>没有辅助方法能够解决上面的问题，因为代码压根是错误的。</p>
<p><a id="wildcards-guideline" href="#wildcards-guideline"></a></p>
<h3 id="通配符使用指南">通配符使用指南</h3><p>使用带上下界的通配符是Java泛型中最容易让人产生迷惑的地方，这一节将提供一些代码设计上的指南。<br>为了方便后续讨论，读者应该理解一个变量有如下的两个功能：</p>
<ul>
<li><strong>传入参数（An “In” Variable）：</strong> 传入参数在代码中往往作为数据使用，例如<code>copy(src,dest)</code>函数有两个参数，src作为被拷贝的对象，是传入变量，习惯上叫做<em>入参</em>。</li>
<li><strong>传出参数（An “Out” Variable)：</strong> 传出参数在代码中往往作为结果使用，例如<code>copy(src,dest)</code>函数中的dest就是传出参数，习惯上称为<em>传出参数</em>。</li>
</ul>
<p>当然有些变量既被用做传入变量又被用作传出变量，这种情况在这一小节中也有讨论。<br>你可以结合<em>in</em>和<em>out</em>的原则，用下面列表中的tips作为决定使用哪种泛型通配符的依据：</p>
<blockquote>
<p><strong>通配符使用指南</strong></p>
<ul>
<li>传入参数用上界通配符extends关键字</li>
<li>传出参数用下界通配符super关键字</li>
<li>传入参数在代码中可被当做Object对象访问时，使用无界通配符</li>
<li>既是传入参数又是传出参数时，不要使用通配符</li>
</ul>
<p>注：上面的这些规则不适用与方法的返回类型，应该避免在返回值中使用通配符，因为这样强迫方法使用者去写额外的代码处理通配符。</p>
</blockquote>
<p>如果列表定义为<code>List&lt;? extends ...&gt;</code>则非正规的定义了一个只读的列表，但不严格保证列表是只读的。<br>假设有如下的两个类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaturalNumber</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> int i;</span><br><span class="line"></span><br><span class="line">    public <span class="type">NaturalNumber</span>(int i) &#123; <span class="keyword">this</span>.i = i; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvenNumber</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">NaturalNumber</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    public <span class="type">EvenNumber</span>(int i) &#123; <span class="keyword">super</span>(i); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码会产生编译错误：：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;EvenNumber&gt; <span class="keyword">le</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;? extends NaturalNumber&gt; <span class="keyword">ln</span> = <span class="keyword">le</span>;</span><br><span class="line"><span class="keyword">ln</span>.<span class="built_in">add</span>(<span class="keyword">new</span> NaturalNumber(<span class="number">35</span>));  // compile-time error</span><br></pre></td></tr></table></figure>
<p>因为<code>List&lt;EvenNumber&gt;</code>是<code>List&lt;? extends NaturalNumber&gt;</code>的子类型，你可以把le赋值给ln，但是你不能向<code>EvenNumber</code>列表中添加<code>NaturalNumber</code>。你可以对<code>List&lt;? extends ...&gt;</code>列表做如下的操作：</p>
<ul>
<li>add null</li>
<li>调用 <code>clear()</code></li>
<li>得到列表的Iterator并调用<code>remove()</code>方法</li>
<li>捕获通配符类型并把从列表读取的元素添加到列表</li>
</ul>
<p>可以看到含有通配符的列表并非是只读的，但你无法添加新的非空元素，也无法改变已有元素。</p>
<p><a id="type-erasure" href="#type-inference"></a></p>
<h2 id="类型擦除（Type_Erasure）">类型擦除（Type Erasure）</h2><p>Java语言通过引入泛型来提供更严格的编译期类型检查，为了实现泛型，Java编译器应用类型擦除：</p>
<ul>
<li>将所有类型参数替换为通配符的界限或Object（如果无界限），产生的字节码只包含普通的那个的类、接口和方法。</li>
<li>如果需要保证类型安全，还需要插入类型转换。</li>
<li>生成桥接方法来保持泛型类型的多态性。</li>
</ul>
<p>类型擦除确保了没有任何新的类型创建，从而不会造成任何运行时的开销。</p>
<h3 id="泛型类的类型擦除">泛型类的类型擦除</h3><p>在类型擦除过程中，Java编译器将删除所有类型参数，并替换类型参数为他的界限，如果没有界限，将替换为Object。<br>例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node(T data, Node&lt;T&gt; <span class="keyword">next</span>) &#125;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T getData() &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为类型参数没有界限，编译器将类型参数替换为Object。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Node &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node(Object data, Node <span class="keyword">next</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object getData() &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类型参数有界限：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;T</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Comparable&lt;T&gt;&gt;</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">T</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span>&lt;<span class="type">T</span>&gt; next;</span><br><span class="line"></span><br><span class="line">    public <span class="type">Node</span>(<span class="type">T</span> data, <span class="type">Node</span>&lt;<span class="type">T</span>&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">T</span> getData() &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java编译器把有界限的类型参数<code>T</code>替换为第一个有界类型<code>Comparable</code>：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Node &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Comparable data;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node(Comparable data, Node <span class="keyword">next</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Comparable getData() &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法的类型擦除">泛型方法的类型擦除</h3><p>Java编译器也会擦除泛型方法实参中的类型参数：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counts the number of occurrences of elem in anArray.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(T[] anArray, T elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T e : anArray)</span><br><span class="line">        <span class="keyword">if</span> (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>T</code>没有界限限制，所以类型参数会被替换为<code>Object</code>：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Object[] anArray, Object elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object e : anArray)</span><br><span class="line">        <span class="keyword">if</span> (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如下面的三个类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span> <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Shape</span> &#123;</span> <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Shape</span> &#123;</span> <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>你可以写一个泛型方法来画出不同的图形：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Shape&gt; <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(T shape)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>Java编译器将<code>T</code>替换为Shape：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw</span>(Shape <span class="built_in">shape</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型擦除和桥接方法的影响">类型擦除和桥接方法的影响</h3><p>有的时候类型擦除会引发预料不到的情况，在下面的<a href="#bridge-methods">桥接方法</a>展示了编译器在某些时候会创建合成方法（<em>桥接方法</em>）。桥接方法是类型擦除处理过程的一部分。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="type">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node(T <span class="type">data</span>) &#123; this.<span class="type">data</span> = <span class="type">data</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setData(T <span class="type">data</span>) &#123;</span><br><span class="line">        System.<span class="type">out</span>.println(<span class="string">"Node.setData"</span>);</span><br><span class="line">        this.<span class="type">data</span> = <span class="type">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyNode <span class="keyword">extends</span> Node&lt;<span class="type">Integer</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> MyNode(<span class="type">Integer</span> <span class="type">data</span>) &#123; super(<span class="type">data</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setData(<span class="type">Integer</span> <span class="type">data</span>) &#123;</span><br><span class="line">        System.<span class="type">out</span>.println(<span class="string">"MyNode.setData"</span>);</span><br><span class="line">        super.setData(<span class="type">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn <span class="subst">=</span> <span class="literal">new</span> MyNode(<span class="number">5</span>);</span><br><span class="line">Node n <span class="subst">=</span> mn;            <span class="comment">// A raw type - compiler throws an unchecked warning</span></span><br><span class="line">n<span class="built_in">.</span>setData(<span class="string">"Hello"</span>);     </span><br><span class="line"><span class="built_in">Integer</span> x <span class="subst">=</span> mn<span class="built_in">.</span><span class="built_in">data</span>;    <span class="comment">// Causes a ClassCastException to be thrown.</span></span><br></pre></td></tr></table></figure>
<p>类型擦除之后，上面的代码变为：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn <span class="subst">=</span> <span class="literal">new</span> MyNode(<span class="number">5</span>);</span><br><span class="line">Node n <span class="subst">=</span> (MyNode)mn;         <span class="comment">// A raw type - compiler throws an unchecked warning</span></span><br><span class="line">n<span class="built_in">.</span>setData(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="built_in">Integer</span> x <span class="subst">=</span> (<span class="built_in">String</span>)mn<span class="built_in">.</span><span class="built_in">data</span>; <span class="comment">// Causes a ClassCastException to be thrown.</span></span><br></pre></td></tr></table></figure>
<p>当代码运行时：</p>
<ul>
<li><code>n.setData(&quot;Hello&quot;);</code> 实际上调用了MyNode对象的<code>setData(Object)</code>方法（<code>MyNode</code>继承了<code>Node</code>的<code>setData(Object)</code>方法）</li>
<li>引用<code>n</code>指向的对象的成员变量data被赋予<code>String</code>类型的值</li>
<li>引用<code>mn</code>指向的相同的对象的成员预期是Integer类型</li>
<li>试图将String类型的值赋给Integer类型，抛出<code>ClassCastException</code>异常</li>
</ul>
<p><a id="bridge-methods" href="#bridge-methods"></a></p>
<h3 id="桥接方法（Bridge_Methods）">桥接方法（Bridge Methods）</h3><p>当一个类继承自有类型参数的类或实现有类型参数的接口时，编译器在编译它时一般需要生成桥接方法，作为类型擦除处理的一部分。一般你不需要担心桥接方法，但是如果它出现在堆栈跟踪中，会使人感到迷惑。<br>类型擦除过后，<code>Node</code>类和<code>MyNode</code>类如下所示：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Node &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="type">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node(Object <span class="type">data</span>) &#123; this.<span class="type">data</span> = <span class="type">data</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setData(Object <span class="type">data</span>) &#123;</span><br><span class="line">        System.<span class="type">out</span>.println(<span class="string">"Node.setData"</span>);</span><br><span class="line">        this.<span class="type">data</span> = <span class="type">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyNode <span class="keyword">extends</span> Node &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyNode(<span class="type">Integer</span> <span class="type">data</span>) &#123; super(<span class="type">data</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setData(<span class="type">Integer</span> <span class="type">data</span>) &#123;</span><br><span class="line">        System.<span class="type">out</span>.println(<span class="string">"MyNode.setData"</span>);</span><br><span class="line">        super.setData(<span class="type">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见类型擦除之后，方法签名不再匹配，<code>Node</code>中<code>setData(Object)</code>方法在<code>MyNode</code>中变成<code>setData(Integer)</code>，这样子类的方法不再覆盖父类的方法。<br>为了解决这个问题，并且能够在类型擦除之后，仍然保持多态性，Java编译器生成一个桥接方法来保证子类型工作正常。对于<code>MyNode</code>类，编译器生成下面的桥接方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Node</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bridge method generated by the compiler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    public void setData(<span class="type">Object</span> data) &#123;</span><br><span class="line">        setData((<span class="type">Integer</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(<span class="type">Integer</span> data) &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"MyNode.setData"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>产生的桥接方法能够覆盖父类的<code>setData(Object data)</code>方法，并把真正的实现代理给了原有的<code>setData(Integer data)</code>方法。</p>
<h2 id="非具体化类型（Non-Reifiable_Types）">非具体化类型（Non-Reifiable Types）</h2><p>类型擦除还和具有非具体化类型的可变参数方法同时使用，会产生一些问题。本小节将详细介绍以下内容：</p>
<ul>
<li>非具体化类型</li>
<li>堆污染</li>
<li>可变参数方法与非具体化类型的潜在漏洞</li>
<li>防止非具体化类型的可变参数方法产生的警告</li>
</ul>
<h3 id="非具体化类型（Non-Reifiable_Types）-1">非具体化类型（Non-Reifiable Types）</h3><p>具体化类型（Reifiable types）是在在运行时可以得到其全部类型信息的类型。包括基本类型（primitives），非泛型类型，原始类型（raw types）和无界通配符的调用。<br>非具体化类型（Non-Reifiable Types）是类型信息在编译期间被类型擦除的类型——对没有定义为无界通配符的泛型类型的调用。非具体化类型的类型信息在运行时不是全部可见的。例如：<code>List&lt;String&gt;</code>和<code>List&lt;Numbuer&gt;</code>JVM在运行时不能区分这两种类型。正如在<a href="#restrictions-on-generics">泛型的限制</a>中描述的，有些机制在非具体化类型上不能使用，比如<code>instanceof</code>。</p>
<h3 id="堆污染（Heap_Pollution）">堆污染（Heap Pollution）</h3><p>当包含类型参数的引用指向一个并非这种类型的对象的时候，就会发生堆污染。一般在这种情形下，编译器在编译器会报未检查警告（unchecked warning）。当无论编译期类型检查还是运行时都无法验证一个包含类型参数的操作（类型转换或者方法调用）是否正确的时候，就会产生未检查警告。混用原始类型（raw types）和泛型参数或者执行未检查的类型转换时都会产生堆污染。<br>一般情况下，如果所有代码都同时编译，编译器利用未检查警告提醒你留意潜在的堆污染；如果不同部分的代码分开编译，则编译器很难检测到潜在的堆污染。<br>当然，如果你能确保代码没有任何未检查警告，则不可能发生堆污染。</p>
<h3 id="可变参数方法与非具体化类型的潜在漏洞（Potential_Vulnerabilities_of_Varargs_Methods_with_Non-Reifiable_Formal_Parameters）">可变参数方法与非具体化类型的潜在漏洞（Potential Vulnerabilities of Varargs Methods with Non-Reifiable Formal Parameters）</h3><p>泛型方法包含可变长度参数时可能造成堆污染。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArrayBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addToList</span> <span class="params">(List&lt;T&gt; listArg, T... elements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T x : elements) &#123;</span><br><span class="line">      listArg.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">faultyMethod</span><span class="params">(List&lt;String&gt;... l)</span> </span>&#123;</span><br><span class="line">    Object[] objectArray = l;     <span class="comment">// Valid</span></span><br><span class="line">    objectArray[<span class="number">0</span>] = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">    String s = l[<span class="number">0</span>].<span class="keyword">get</span>(<span class="number">0</span>);       <span class="comment">// ClassCastException thrown here</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HeapPollutionExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  public <span class="literal">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; stringListA = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; stringListB = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.addToList(stringListA, <span class="string">"Seven"</span>, <span class="string">"Eight"</span>, <span class="string">"Nine"</span>);</span><br><span class="line">    ArrayBuilder.addToList(stringListB, <span class="string">"Ten"</span>, <span class="string">"Eleven"</span>, <span class="string">"Twelve"</span>);</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; listOfStringLists =</span><br><span class="line">      <span class="keyword">new</span> ArrayList&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt;();</span><br><span class="line">    ArrayBuilder.addToList(listOfStringLists,</span><br><span class="line">      stringListA, stringListB);</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.faultyMethod(Arrays.asList(<span class="string">"Hello!"</span>), Arrays.asList(<span class="string">"World!"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当编译上面代码的时候，编译器会产生关于<code>ArrayBuilder.addToList</code>方法的警告：</p>
<pre><code>warning: [varargs] Possible heap pollution from parameterized vararg <span class="class"><span class="keyword">type</span> <span class="title">T</span></span>
</code></pre><p>当遇到可变参数的方法时，编译器将可变参数转换成数组，但是Java不允许创建泛型数组（例如<code>new T[]</code>），在<code>ArrayBuilder.addToList</code>方法中，编译器将可变参数<code>T...</code>转换为<code>T[]</code>。但由于类型擦除，参数数组最终的类型是<code>Object[]</code>,因此可能会出现堆污染。</p>
<p>下面的语句将参数数组赋值给Object数组：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>[] objectArray = l;</span><br></pre></td></tr></table></figure>
<p>上面的语句会产生堆污染。参数数组可以赋值给Object类型的数组，但是此赋值语句编译器不会产生未检查警告，因为已经在将可变参数<code>List&lt;String&gt;... l</code>转换为<code>List[] l</code>的时候产生过警告。赋值语句是合法的，因为<code>List[]</code>是<code>Object[]</code>的子类型。</p>
<p>这样，当你把任何类型的列表赋值给<code>objectArray</code>数组中的元素的时候，编译器不会产生任何的错误或者警告，例如下面的语句：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">objectArray[0] </span>=<span class="string"> Arrays.asList(42);</span></span><br></pre></td></tr></table></figure>
<p>将<code>objectArray</code>数组中的第一个元素赋值为<code>List&lt;Integer&gt;</code>类型的值。</p>
<p>假设你用如下的方式调用<code>ArrayBuilder.faultyMethod</code>方法：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBuilder.faultyMethod(Arrays.<span class="keyword">asList</span>(<span class="string">"Hello!"</span>), Arrays.<span class="keyword">asList</span>(<span class="string">"World!"</span>));</span><br></pre></td></tr></table></figure>
<p>在运行时，JVM会抛出<code>ClassCastException</code>异常：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassCastException thrown here</span></span><br><span class="line"><span class="built_in">String</span> s = l[<span class="number">0</span>].<span class="literal">get</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>存储在<code>l</code>中是<code>List&lt;Integer&gt;</code>类型，但上面的语句期待的类型是<code>List&lt;String&gt;</code>。</p>
<h3 id="防止非具体化类型的可变参数方法产生的警告（Prevent_Warnings_from_Varargs_Methods_with_Non-Reifiable_Formal_Parameters）">防止非具体化类型的可变参数方法产生的警告（Prevent Warnings from Varargs Methods with Non-Reifiable Formal Parameters）</h3><p>如果你声明了一个参数化类型的可变参数的方法，并且可以确保该方法体不抛出ClassCastException或其他类似的异常，可以通过对方法增加如下注解来防止编译器警告：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SafeVarargs</span></span><br></pre></td></tr></table></figure>
<p><code>@SafeVarargs</code>注解声明在这个方法内部不会错误的处理可变参数实参的类型。</p>
<p>使用以下的方法注解也可以消除编译器关于参数化类型的可变参数的警告，虽然效果并不理想:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function"><span class="title">SuppressWarnings</span><span class="params">(&#123;<span class="string">"unchecked"</span>, <span class="string">"varargs"</span>&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>这种方式不能消除方法调用方的编译警告。</p>
<p><a id="restrictions-on-generics"><a></a></a></p>
<h2 id="泛型的限制（Restrictions_on_Generics）">泛型的限制（Restrictions on Generics）</h2><h3 id="无法用基本类型实例化泛型类型参数">无法用基本类型实例化泛型类型参数</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Pair&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K <span class="variable">key</span>;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pair(K <span class="variable">key</span>, V value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="variable">key</span> = <span class="variable">key</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们无法用基本类型去实例化类型实参：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">8</span>, <span class="string">'a'</span>);  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<p>只能通过对象类型实例化：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, Character<span class="subst">&gt;</span> p <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;&gt;</span>(<span class="number">8</span>, <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>
<p>Java自动装箱，相当于如下的实例化方式：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, Character<span class="subst">&gt;</span> p <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;&gt;</span>(<span class="built_in">Integer</span><span class="built_in">.</span>valueOf(<span class="number">8</span>), <span class="literal">new</span> Character(<span class="string">'a'</span>));</span><br></pre></td></tr></table></figure>
<h3 id="不能创建类型参数的对象">不能创建类型参数的对象</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;<span class="keyword">E</span>&gt; void <span class="keyword">append</span>(<span class="keyword">List</span>&lt;<span class="keyword">E</span>&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">    <span class="keyword">E</span> elem = new <span class="literal">E</span>();  <span class="comment">// compile-time error</span></span><br><span class="line">    <span class="keyword">list</span>.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法是可以使用反射来创建类型参数的对象：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;<span class="keyword">E</span>&gt; void <span class="keyword">append</span>(<span class="keyword">List</span>&lt;<span class="keyword">E</span>&gt; <span class="keyword">list</span>, <span class="keyword">Class</span>&lt;<span class="keyword">E</span>&gt; cls) throws Exception &#123;</span><br><span class="line">    <span class="keyword">E</span> elem = cls.newInstance();   <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">list</span>.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>append</code>方法可以用如下方式调用：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">append(ls, <span class="built_in">String</span>.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure>
<h3 id="无法创建泛型类型的静态属性">无法创建泛型类型的静态属性</h3><p>以下泛型类型的静态属性声明是不允许的：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileDevice</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T os;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为如果允许静态属性是泛型参数类型，则对不同的实例化会产生歧义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MobileDevice<span class="tag">&lt;<span class="title">Smartphone</span>&gt;</span> phone = new MobileDevice<span class="tag">&lt;&gt;</span>();</span><br><span class="line">MobileDevice<span class="tag">&lt;<span class="title">Pager</span>&gt;</span> pager = new MobileDevice<span class="tag">&lt;&gt;</span>();</span><br><span class="line">MobileDevice<span class="tag">&lt;<span class="title">TabletPC</span>&gt;</span> pc = new MobileDevice<span class="tag">&lt;&gt;</span>();</span><br></pre></td></tr></table></figure>
<p>静态属性只跟随类存在一份，多个类型参数的对象创建时，无法设置静态成员os。</p>
<h3 id="不能对类型参数使用类型转换或instanceof">不能对类型参数使用类型转换或<code>instanceof</code></h3><p>由于类型擦除，无法验证泛型参数的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">rtti</span><span class="params">(List&lt;E&gt; <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> instanceof ArrayList&lt;Integer&gt;) &#123;  <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设传入<code>rtti</code>方法的参数结合为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = &#123; ArrayList<span class="tag">&lt;<span class="title">Integer</span>&gt;</span>, ArrayList<span class="tag">&lt;<span class="title">String</span>&gt;</span> LinkedList<span class="tag">&lt;<span class="title">Character</span>&gt;</span>, ... &#125;</span><br></pre></td></tr></table></figure>
<p>在运行时不会跟踪类型参数，所以JVM无法区分<code>ArrayList&lt;Integer&gt;</code> 和 <code>ArrayList&lt;String&gt;</code>，最多我们可以使用无界通配符来验证实参是否是<code>ArrayList</code>：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void rtti(<span class="keyword">List</span><span class="preprocessor">&lt;?</span>&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">list</span> <span class="keyword">instanceof</span> ArrayList<span class="preprocessor">&lt;?</span>&gt;) &#123;  <span class="comment">// OK; instanceof requires a reifiable type</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除非使用无界通配符，否则无法对泛型参数类型进行强制类型转换：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;</span> li <span class="subst">=</span> <span class="literal">new</span> ArrayList<span class="subst">&lt;&gt;</span>();</span><br><span class="line"><span class="built_in">List</span><span class="subst">&lt;</span>Number<span class="subst">&gt;</span>  ln <span class="subst">=</span> (<span class="built_in">List</span><span class="subst">&lt;</span>Number<span class="subst">&gt;</span>) li;  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<p>在某些情况下，编译器明确知道类型参数一定匹配的情况下，才允许类型转换，例如：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span> l1 <span class="subst">=</span> <span class="attribute">...</span>;</span><br><span class="line">ArrayList<span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span> l2 <span class="subst">=</span> (ArrayList<span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span>)l1;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h3 id="不能创建泛型类型的数组：">不能创建泛型类型的数组：</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Integer&gt;[] arrayOfLists = <span class="keyword">new</span> <span class="built_in">List</span>&lt;Integer&gt;[<span class="number">2</span>];  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<p>当向一个数组中插入不同类型的值时，会出现什么情况？</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>[] strings = <span class="keyword">new</span> <span class="built_in">String</span>[<span class="number">2</span>];</span><br><span class="line">strings[<span class="number">0</span>] = <span class="string">"hi"</span>;   <span class="comment">// OK</span></span><br><span class="line">strings[<span class="number">1</span>] = <span class="number">100</span>;    <span class="comment">// An ArrayStoreException is thrown.</span></span><br></pre></td></tr></table></figure>
<p>同样，如果在泛型List上尝试插入不同类型会怎么样？</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>[] stringLists = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;[];  <span class="comment">// compiler error, but pretend it's allowed</span></span><br><span class="line">stringLists[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();   <span class="comment">// OK</span></span><br><span class="line">stringLists[<span class="number">1</span>] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  <span class="comment">// An ArrayStoreException should be thrown,</span></span><br><span class="line">                                            <span class="comment">// but the runtime can't detect it.</span></span><br></pre></td></tr></table></figure>
<h3 id="无法创建、捕获或抛出泛型类型的异常">无法创建、捕获或抛出泛型类型的异常</h3><p>泛型类无法直接或者间接的继承<code>Throwable</code>类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extends Throwable indirectly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathException&lt;T&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Exception</span> &#123;</span> <span class="comment">/* ... */</span> &#125;    <span class="comment">// compile-time error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extends Throwable directly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueFullException&lt;T&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Throwable</span> &#123;</span> <span class="comment">/* ... */</span> <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure></p>
<p>也无法捕获泛型类型：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Exception, J&gt; <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(List&lt;J&gt; jobs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (J job : jobs)</span><br><span class="line">            // ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123;   <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是你可以声明一个方法抛出泛型类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser&lt;T</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Exception&gt;</span> &#123;</span></span><br><span class="line">    public void parse(<span class="type">File</span> file) <span class="keyword">throws</span> <span class="type">T</span> &#123;     <span class="comment">// OK</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无法通过不同的泛型参数类型重载方法">无法通过不同的泛型参数类型重载方法</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;String&gt; strSet)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;Integer&gt; intSet)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为类型擦除导致两个方法的参数类型是一样的。</p>
<p><a id="refs" href="#refs"></a></p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html" target="_blank" rel="external">https://docs.oracle.com/javase/tutorial/java/generics/index.html</a></li>
<li><a href="http://stackoverflow.com/questions/857420/what-are-the-reasons-why-map-getobject-key-is-not-fully-generic" target="_blank" rel="external">What are the reasons why Map.get(Object key) is not (fully) generic</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：泛型可以将某些类型相关的错误从运行时提前到编译时显现，但Java的泛型有很多特点和限制。本文介绍了泛型类型、原始类型、泛型方法、有界类型参数、泛型的继承和子类型、类型推断、通配符、类型擦除、非具体化类型和泛型的限制，之前用到的和以后要用的，都在这里了。<br><strong>Abstract</strong>: Java generics add stability to your code by making some bugs about types be detected early on complie-time. This article gives a comprehensive introduction to the important points Java generics.</p>
<h2 id="写在最前面">写在最前面</h2><p>一说泛型，好像都会。但前些天在看源码的时候，发现一个警告，引出了好多泛型的问题，最终让我下定决心整理一下Java泛型的坑（感谢Oracle，有一个很全面的Tutorial，Java编程思想都没有它介绍的详尽）。如果你也觉得你掌握了泛型，不妨试试以下问题，这些问题的解释，就包含在本篇文章里。</p>
<p>先看几个问题：</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="generic" scheme="http://zuoqy.com/tags/generic/"/>
    
      <category term="Java" scheme="http://zuoqy.com/categories/Java/"/>
    
  </entry>
  
</feed>