<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Q.Y Zuo Believes]]></title>
  <subtitle><![CDATA[Qiyang Zuo's Blog]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zuoqy.com/"/>
  <updated>2016-05-23T15:52:16.000Z</updated>
  <id>http://zuoqy.com/</id>
  
  <author>
    <name><![CDATA[Qiyang Zuo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[HTTP重定向状态码的区别]]></title>
    <link href="http://zuoqy.com/2016/05/23/HTTP-redirect-codes/"/>
    <id>http://zuoqy.com/2016/05/23/HTTP-redirect-codes/</id>
    <published>2016-05-23T10:13:53.000Z</published>
    <updated>2016-05-23T15:52:16.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：<br><strong>Abstract</strong>:<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left">资源被永久移除。客户端后续应该请求到新的URI上（相应报文首部给出），客户端需要向新的URI重新发起请求。后续的请求也都应该请求新的URI。</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">临时重定向。客户端后续请求仍然使用原有的URI。</td>
</tr>
<tr>
<td style="text-align:left">303</td>
<td style="text-align:left">See Other(since HTTP/1.1)</td>
<td style="text-align:left">告诉客户端，用Get方法请求给定的新URI中的资源。对于POST/PUT/DELETE请求，客户端应该假定服务器已经收到并处理了该请求，应该向新的URI再发一次GET请求来获取结果。后续请求还需要请求到老URI上。</td>
</tr>
<tr>
<td style="text-align:left">307</td>
<td style="text-align:left">Temporary Redirect (since HTTP/1.1)</td>
<td style="text-align:left">临时重定向。对于所有POST/PUT/DELETE请求，客户端<strong>应当重新发起本次请求</strong>。后续的请求还应该使用老的URI。</td>
</tr>
</tbody>
</table>
<p><code>302 Found</code>标准与实现有偏差，The HTTP/1.0（RFC 1945）规定客户端需要做临时重定向，原始的描述是<code>&quot;Moved Temporarily&quot;</code>,但是主流的浏览器实现成了类似303 See Other的功能。因此在HTTP/1.1中，增加了303和307两个状态码来区分两种不同的行为。</p>
<h2 id="参考">参考</h2><ul>
<li>1 <a href="http://stackoverflow.com/questions/4764297/difference-between-http-redirect-codes" target="_blank" rel="external">Difference between HTTP redirect codes</a></li>
<li>2 Gourley, David, and Brian Totty. HTTP: the definitive guide. “ O’Reilly Media, Inc.”, 2002.</li>
<li>3 <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection" target="_blank" rel="external">List of HTTP status codes</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：<br><strong>Abstract</strong>:<br>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://zuoqy.com/tags/HTTP/"/>
    
      <category term="redirect" scheme="http://zuoqy.com/tags/redirect/"/>
    
      <category term="重定向" scheme="http://zuoqy.com/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java对象的共享]]></title>
    <link href="http://zuoqy.com/2016/05/22/sharing-objects/"/>
    <id>http://zuoqy.com/2016/05/22/sharing-objects/</id>
    <published>2016-05-22T07:48:56.000Z</published>
    <updated>2016-05-22T09:40:12.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：Java内存可见性、对象的发布和逸出以及不变性<br><strong>Abstract</strong>:Visibility、publish and escape、immutable。<br><a id="more"></a></p>
<h2 id="可见性">可见性</h2><p>可见性是指某个线程对变量写入的值，其他线程是否总能够正确的读取。通常，为了确保多线程之间对内存写入操作的可见性，必须使用同步机制。</p>
<h3 id="重排序">重排序</h3><p>在多线程情况下，存在指令重排序的情况，因此在没有同步的情况下，不能假定多线程程序的指令执行顺序。</p>
<h3 id="失效数据">失效数据</h3><p>在没有同步保证的多线程程序中，一个线程可能读取到某个变量的新值，也可能读取到其已经失效的值。</p>
<h3 id="非原子的64位操作">非原子的64位操作</h3><p>在多线程程序中使用共享且可变的long和double等类型的变量是不安全的，除非用volatile声明或者用锁保护起来。因为JVM允许将64位的操作分解为两个32位的操作。</p>
<h3 id="加锁与可见性">加锁与可见性</h3><p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读写操作的线程都必须在同一个锁上进行同步。</p>
<h3 id="volatile变量">volatile变量</h3><p>volatile变量不会被缓存在寄存器中或者对其他处理器不可见的地方，因此在读取volatile类型的变量时，总会返回最新写入的值。<br>仅当volatile变量能简化代码实现以及对同步策略的验证时，才应该使用它们。使用方式包括：确保变量自身状态的可见性、确保所引用对象状态的可见性、标识一些重要的程序生命周期事件的发生（如初始化或关闭）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断某个状态，决定是否退出循环</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> asleep;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(!asleep) &#123;</span><br><span class="line">    countSomeSheep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：volatile语义不足以保证递增操作（count++）的原子性，因为递增是读-修改-写操作。<strong>加锁机制既可以确保可见性，又可以确保原子性，而volatile变量只能确保可见性</strong>。</p>
<p><strong>当且仅当满足以下所有条件时，才应该使用volatile变量</strong>：</p>
<ul>
<li>对变量的写入操作比依赖变量当前的值，或者确保只有一个线程更新变量的值。</li>
<li>该变量不会与其他状态变量一起纳入不变性条件。</li>
<li>访问该变量时不需要加锁。</li>
</ul>
<h2 id="发布与逸出">发布与逸出</h2><p><strong>发布（publish）</strong>对象，是指是对象能够在当前作用域之外的代码中使用。例如将对象的引用保存到其他类的代码中，或者将引用传递到其他类的方法中。<br><strong>逸出（escape）</strong>：当不应该发布的对象被发布，则成为逸出。</p>
<h3 id="this逸出">this逸出</h3><p>在一个类的构造函数中发布对象时，只是发布了一个尚未构造完成的对象，即使发布对象的语句位于构造函数的最后一行。如果this引用在构造函数中逸出，这种对象的创建就是不正确的构造。<strong>不要在函数构造方法中，使this逸出</strong></p>
<h4 id="错误1：在构造方法内发布内部类对象">错误1：在构造方法内发布内部类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不正确的构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        source.registerListener() &#123;</span><br><span class="line">            <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                    doSomeThing(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上例中，假设EventListener是ThisEscape类的内部类，在发布内部类的对象时，this隐含的也被发布了。</p>
<h4 id="错误2：在构造函数中启动线程">错误2：在构造函数中启动线程</h4><p>如果想在构造器中启动线程或者设置事件监听，应该使用一个私有构造方法和一个公共的静态工厂方法，从而避免不正确的构造过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        listener = <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        SafeListener safe = <span class="keyword">new</span> SafeListener();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程封闭（Thread_Confinement）">线程封闭（Thread Confinement）</h2><p>当某个对象封闭在一个线程中时，将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。</p>
<h3 id="Ad-hoc线程封闭">Ad-hoc线程封闭</h3><p>Ad-hoc线程封闭是指维护线程封闭性的职责完全有程序实现来承担。例如在volatile变量上的读-修改-写操作确保只有一个线程来完成。<br>这种线程封闭较脆弱，应该尽量避免使用。</p>
<h3 id="栈封闭">栈封闭</h3><p>栈封闭：是指只能通过局部变量才能访问对象。</p>
<h3 id="ThreadLocal类">ThreadLocal类</h3><p>ThreadLocal是维持线程封闭性的一种更规范的方法，ThreadLocal对象通常用于防止可变的单例或者全局变量进行共享。静态的ThreadLocal对象可以将包含在其中的全局变量为每个使用它的线程都保存一份，当线程终结时，会被垃圾回收掉。运用此机制，可以很好的实现线程上下文的保存。</p>
<h2 id="不变性">不变性</h2><p>不可变对象一定是线程安全的，当满足下面的条件时，对象才是不可变的：</p>
<ul>
<li>对象创建以后其状态不可修改</li>
<li>对象所有域都是final类型</li>
<li>对象是正确被创建的（在构造方法中没有this逸出）</li>
</ul>
<h3 id="final域">final域</h3><p>final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象。</p>
<h3 id="安全发布的常用模式">安全发布的常用模式</h3><ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到volatile类型的域或者AtomicReference对象中。</li>
<li>将对象的引用保存到某个正确构造对象的final类型的域中</li>
<li>将兑现给的引用保存到一个由锁保护的域中。</li>
</ul>
<h2 id="参考">参考</h2><ul>
<li>1 Goetz, Brian, and Tim Peierls. Java concurrency in practice. Pearson Education, 2006.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：Java内存可见性、对象的发布和逸出以及不变性<br><strong>Abstract</strong>:Visibility、publish and escape、immutable。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="concurrency" scheme="http://zuoqy.com/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二阶段提交协议]]></title>
    <link href="http://zuoqy.com/2016/03/27/2-phase-commit/"/>
    <id>http://zuoqy.com/2016/03/27/2-phase-commit/</id>
    <published>2016-03-27T03:55:25.000Z</published>
    <updated>2016-03-27T08:04:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：简要介绍二阶段提交协议的思想<br><strong>Abstract</strong>:Main ideas of 2 phase commit.<br><a id="more"></a></p>
<h2 id="两阶段提交协议（Two_Phase_Commit_Protocol）">两阶段提交协议（Two Phase Commit Protocol）</h2><p>两阶段提交协议是分布式事务处理使用的一种一致性协议。它用来协调分布式事务中的每个参与者，应对系统分布式系统执行事务过程中的短暂系统异常（如：节点失败、网络通信异常等）。</p>
<h2 id="前提">前提</h2><ul>
<li>系统有存在一个协调者（coordinator）节点，其他节点为参与者（cohorts）</li>
<li>系统中有稳定的存储，用来记录事务日志（预写日志WAL，Write-ahead logging），预写日志不会因为节点宕机而丢失。</li>
<li>系统中，任意两个节点之间都可以相互通信。（相比前两条，可放宽一些）</li>
</ul>
<h2 id="算法描述">算法描述</h2><h3 id="第一阶段：请求提交阶段Commit_Request_Phase（投票阶段_voting_phase）">第一阶段：请求提交阶段Commit Request Phase（投票阶段 voting phase）</h3><ul>
<li>协调者向所有参与值发起事务提交请求，等待所有参与者的投票响应。</li>
<li>所有参与者执行协调者发起的事务，记录Undo和Redo log。</li>
<li>所有参与者投票给协调者（事务可以执行成功，回复<em>Yes</em>，否则回复<em>No</em>）。任何一个参数者没有回复yes都会导致事务回滚。</li>
</ul>
<h3 id="第二阶段：事务提交阶段（Commit_Phase）">第二阶段：事务提交阶段（Commit Phase）</h3><h4 id="执行成功：">执行成功：</h4><ul>
<li>协调者向所有参与者发送commit命令</li>
<li>所有参与者完成事务提交，并释放事务处理期间所占用的锁和资源</li>
<li>参与者发送ACK给协调者</li>
<li>当协调者收到所有参与者的ACK之后，事务执行成功</li>
</ul>
<h4 id="执行失败：">执行失败：</h4><ul>
<li>任何一个参与者投票No或者超时，都导致事务回滚</li>
<li>每个参与者根据WAL日志回滚</li>
<li>每个参与者发送ACK给协调者</li>
<li>协调者收到所有ACK后，事务回滚完成</li>
</ul>
<p>时序图：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Coordinator                                         Cohort&#10;                              QUERY TO COMMIT&#10;                --------------------------------&#62;&#10;                              VOTE YES/NO           prepare*/abort*&#10;                &#60;-------------------------------&#10;commit*/abort*                COMMIT/ROLLBACK&#10;                --------------------------------&#62;&#10;                              ACKNOWLEDGMENT        commit*/abort*&#10;                &#60;--------------------------------  &#10;end</span><br></pre></td></tr></table></figure>
<p><code>*</code>表示改操作需要依赖稳定的存储</p>
<h2 id="算法缺陷">算法缺陷</h2><ul>
<li>同步阻塞：两阶段提交最大的缺点，等待其他参与者响应的过程中是阻塞的，无法进行其他操作。如果在阶段二协调者失败，则参与者永远处于阻塞状态，直到收到commit命令或者abort命令。</li>
<li>单点问题：协调者存在单点问题</li>
<li>太过保守：任何参与者错误或者超时，都会导致整个分布式事务失败。</li>
</ul>
<h2 id="参考">参考</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="external">https://en.wikipedia.org/wiki/Two-phase_commit_protocol</a></li>
<li><a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00RECRKPK" target="_blank" rel="external">从paxos到zookeeper——分布式一致性原理与实践</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：简要介绍二阶段提交协议的思想<br><strong>Abstract</strong>:Main ideas of 2 phase commit.<br>]]>
    
    </summary>
    
      <category term="2 Phase Commit" scheme="http://zuoqy.com/tags/2-Phase-Commit/"/>
    
      <category term="2PC" scheme="http://zuoqy.com/tags/2PC/"/>
    
      <category term="一致性协议" scheme="http://zuoqy.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="二阶段提交" scheme="http://zuoqy.com/tags/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java ClassLoader]]></title>
    <link href="http://zuoqy.com/2016/02/05/classloader/"/>
    <id>http://zuoqy.com/2016/02/05/classloader/</id>
    <published>2016-02-05T13:53:45.000Z</published>
    <updated>2016-03-27T03:50:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：Java类加载器<br><strong>Abstract</strong>: An overview of Java ClassLoaders<br><a id="more"></a></p>
<h2 id="走进CLassLoader">走进CLassLoader</h2><p>每个类加载器（classloader）自身都是一个扩展自<code>java.lang.ClassLoader</code>类的实例。那么如果类加载器本身也有类型，并且每类都是由classloader加载的，那么加载的顺序是怎样的？我们需要了解classloader的机制和JVM类加载体系。首先看一下classloader的API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Class de <span class="title">neClass</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> URL <span class="title">getResource</span><span class="params">(String name)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Enumeration <span class="title">getResources</span><span class="params">(String name)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getParent</span><span class="params">()</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>loadClass</code>方法是<code>java.lang.ClassLoader</code>类中最重要的方法，接收类的全名，返回改类型的实例对象。<br><code>defineClass</code>方法，参数为byte数组，一般是从磁盘或其他地方加载的Java字节码。<br><code>getResource</code>和<code>getResources</code>返回资源的URL，它有类似于<code>loadClass</code>方法的<strong>委托机制</strong>，首先委托给父类加载，然后再在本地查找。<code>loadClass</code>方法等同于<code>defineClass(getResource(name).getBytes())</code>.<br><code>getParent</code>方法返回父类加载器（parent classloader），在下一节中我们将详细描述。<br>由于Java的晚期绑定，类型加载延迟到最晚时刻进行。一个类只有在第一次调用其构造方法、static方法或static属性时，才会被加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    b.doSomethingElse();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>B b = new B();</code>在语义上等同于<code>getClassLoader().loadClass(&quot;B&quot;).newInstance();</code><br>在Java中，所有的对象都和他们的类关联，而所有的类都和该类的加载器关联。<br>当我们实例化一个<code>ClassLoader</code>，我们可以通过构造方法指定其父类加载器（<code>parent ClassLoader</code>），如果没有显式的指定，则JVM会指定一个默认的parent classloader。那么默认的parent classloader是什么呢？这取决于JVM的ClassLoader继承体系。</p>
<h2 id="JVM的类加载委托体系（classloader_delegation_hierarchy）">JVM的类加载委托体系（classloader delegation hierarchy）</h2><p>JVM在启动时，会首先加载<strong>bootstrap classloader</strong>，bootstrap classloader是所有类加载器的parent，负责加载重要的Java基础类（如java.lang package）和其他运行时类型。<em>bootstrap类加载器是JVM中，唯一一个没有parent的类加载器</em>。<br>接着是加载<strong>extension classloader</strong>。它的parent是bootstrap classloader，负责加载<code>java.ext.dirs</code>路径下的所有jar包。<br>第三步，也是最重要的一步，就是加载<strong>system classpath classloader</strong>,该classloader的直接父节点是extention classloader。它负责从<code>CLASSPATH</code>变量指定的路径、<code>java.class.path</code>系统变量或<code>-classpath</code>命令行参数指定的路径中加载类。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10; +---------------------+&#10; |bootstrap classloader|&#10; +---------------------+&#10;           |&#10;           v&#10; +---------------------+&#10; |extention classloader|&#10; +---------------------+&#10;           |&#10;           v&#10;+----------------------------+&#10;|system classpath classloader|&#10;+----------------------------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是，以上JVM的类加载体系并非一个继承体系，而是一个委托体系（delegation hierarchy）。</p>
</blockquote>
<p>大部分的classloader在加载自己本地classpath种的资源和类之前，优先委托给他们的parent。如果parent classloader不能找到目标类或者资源，classloader才会尝试在本地的classpath中搜索并加载资源。也就是说，classloader只加载它的parent无法加载的类或资源。相反，被处于委托体系下层的classloader加载的class不能被委托体系上层的类访问。</p>
<blockquote>
<p>最初建立这样的类加载委托体系的初衷是为了避免相同类型可能被加载数次。回到1995年，当时Java平台的主要应用是Web Applet。当时网络带宽的限制，决定了JVM需要延迟加载类型。但后来证明Java在服务端程序和JavaEE中表现优异，在服务端程序中，classloader理想的加载顺序是相反的——优先在本地查找并加载class，没有找到时，再向parant中去查找。</p>
</blockquote>
<h2 id="JavaEE类型加载委托体系">JavaEE类型加载委托体系</h2><p>下面是一个典型的web容器classloader体系：每个EAR（J2EE Enterprise Archive）module和WAR都有自己的类加载器。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;                   +-----------+&#10;                   | container |&#10;                   +-----------+&#10;                         |&#10;           +---------------+----------+&#10;           |               |          |&#10;      +--------+       +--------+ +--------+&#10;      |App1.ear|       |App2.ear| |App3.ear|&#10;      +--------+       +--------+ +--------+&#10;          |                |          |&#10;    +-----------+          |          |&#10;    |           |          |          |&#10;+-------+   +-------+  +-------+  +-------+&#10;| WAR1  |   | WAR2  |  | WAR3  |  | WAR4  |&#10;+-------+   +-------+  +-------+  +-------+</span><br></pre></td></tr></table></figure>
<p>Java Servlet规范建议web模块的classloader优先加载类加载器本地的内容。之后当没有找到目标类时，才委托parent加载。</p>
<blockquote>
<p>颠倒委托顺序的原因是：应用容器中的加载的众多类库都有自己的发布周期，不一定适用于开发者。典型的例子就是log4j类库，在container中使用的是一个版本，而在应用中使用的是另一个版本。</p>
</blockquote>
<p>然而这带来了问题：</p>
<blockquote>
<p>JEVGENI KABANOV:The reversed behavior of web module classloader has caused more problems with classloaders than anything else… ever.</p>
</blockquote>
<h3 id="JavaEE类加载错误">JavaEE类加载错误</h3><p>JavaEE的委托模型又是会出现以下几种有趣的错误。<code>NoClassDefFoundError</code>, <code>LinkageError</code>, <code>ClassNotFoundException</code>, <code>NoSuchMethodError</code>, <code>ClassCastException</code>.</p>
<h4 id="NoClassDefFoundError">NoClassDefFoundError</h4><p><code>NoClassDefFoundError</code> 是上述错误中最常见的一种，排错分析的复杂程度取决于你Web项目的复杂性和规模。Java文档中是这样描述的：</p>
<blockquote>
<p>NoClassDefFoundError is thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the de nition of a class and no de nition of the class could be found.</p>
</blockquote>
<p>也就是说，类型定义在编译期存在，而在运行时无法找到。这就是你不能完全依赖IDE的错误信息提示，许多运行时的错误IDE并帮不上忙。</p>
<blockquote>
<p>JEVGENI KABANOV: All classloading happens at runtime, which makes the IDE results irrelevant.</p>
</blockquote>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoClassDefFoundErrorServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.print(StringUtils.defaultString(<span class="string">"hello"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NoClassDefFoundErrorServlet</code> 调用<code>StringUtils</code>类的defaultString方法，打印一条信息。但是在运行时会发生如下错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;java.lang.NoClassDefFoundError: org/apache/commons/lang3/StringUtils&#10;&#9;com.zuoqy.classloader.NoClassDefFoundErrorServlet.doGet(NoClassDefFoundErrorServlet.java:20)&#10;&#9;javax.servlet.http.HttpServlet.service(HttpServlet.java:620)&#10;&#9;javax.servlet.http.HttpServlet.service(HttpServlet.java:727)&#10;&#9;org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)</span><br></pre></td></tr></table></figure>
<p>如何排除这个错误？ 很显然你需要检查<code>StringUtils</code>这个类是否真的被引入到了package里。由于maven依赖的<code>commons-lang3</code>的scope是provided，因此在编译期间并不会出错。由于运行时tomcat的lib目录中没有对应的jar包，才会产生运行时错误。</p>
<p>这里有一个技巧，就是打印出classloader加载类的classpath：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoClassDefFoundErrorServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.print(Arrays.toString(((URLClassLoader) NoClassDefFoundErrorServlet.class.getClassLoader()).getURLs()));</span><br><span class="line">        <span class="comment">//writer.print(StringUtils.defaultString("hello"));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会看到类似下面的输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;[file:/opt/tomcat/deploy/ROOT/WEB-INF/classes/, file:/opt/tomcat/deploy/ROOT/]</span><br></pre></td></tr></table></figure>
<p>但打印classpath的方法不是在所有情况下都可以，我们还可以使用<code>jconsole</code>命令连接到tomcat进程上查看classpath信息以及在运行时加载了哪些类。</p>
<h4 id="NoSuchMethodError">NoSuchMethodError</h4><p>产生<code>NoSuchMethodError</code>的原因一般是被引用的class存在，但是不是正确的版本。首先需要知道这个版本不正确的class是从哪加载的。可以通过设置JVM参数<code>‘-verbose:class</code>查看类的加载和卸载日志。确定所加载的class路径之后，可以使用<code>javap -private classfile</code>命令来查看此class文件中是否有目标方法。</p>
<p>如果是maven项目，还可以通过在项目根目录下运行 <code>mvn clean dependency:tree</code> 命令查看是否存在依赖冲突。然后把错误版本的jar包在依赖中排除掉即可。</p>
<p>未完待续…</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://zeroturnaround.com/rebellabs/rebel-labs-tutorial-do-you-really-get-classloaders/" target="_blank" rel="external">http://zeroturnaround.com/rebellabs/rebel-labs-tutorial-do-you-really-get-classloaders/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：Java类加载器<br><strong>Abstract</strong>: An overview of Java ClassLoaders<br>]]>
    
    </summary>
    
      <category term="ClassLoader" scheme="http://zuoqy.com/tags/ClassLoader/"/>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="Java" scheme="http://zuoqy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vmstat用法]]></title>
    <link href="http://zuoqy.com/2015/12/01/vmstat/"/>
    <id>http://zuoqy.com/2015/12/01/vmstat/</id>
    <published>2015-12-01T04:37:58.000Z</published>
    <updated>2015-12-01T07:04:34.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：vmstat用法<br><strong>Abstract</strong>: usage of vmstat<br><a id="more"></a></p>
<h2 id="注记">注记</h2><p>vmstat - virtual memory statistics</p>
<h2 id="概要">概要</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">vmstat</span> [-<span class="atom">a</span>] [-<span class="atom">n</span>] [-<span class="name">S</span> <span class="atom">unit</span>] [<span class="atom">delay</span> [ <span class="atom">count</span>]]</span><br><span class="line">       <span class="atom">vmstat</span> [-<span class="atom">s</span>] [-<span class="atom">n</span>] [-<span class="name">S</span> <span class="atom">unit</span>]</span><br><span class="line">       <span class="atom">vmstat</span> [-<span class="atom">m</span>] [-<span class="atom">n</span>] [<span class="atom">delay</span> [ <span class="atom">count</span>]]</span><br><span class="line">       <span class="atom">vmstat</span> [-<span class="atom">d</span>] [-<span class="atom">n</span>] [<span class="atom">delay</span> [ <span class="atom">count</span>]]</span><br><span class="line">       <span class="atom">vmstat</span> [-<span class="atom">p</span> <span class="atom">disk</span> <span class="atom">partition</span>] [-<span class="atom">n</span>] [<span class="atom">delay</span> [ <span class="atom">count</span>]]</span><br><span class="line">       <span class="atom">vmstat</span> [-<span class="atom">f</span>]</span><br><span class="line">       <span class="atom">vmstat</span> [-<span class="name">V</span>]</span><br></pre></td></tr></table></figure>
<h2 id="描述">描述</h2><p>vmstat命令打印关于进程，内存，分页，块IO，陷阱和CPU活动的信息。</p>
<h2 id="选项说明">选项说明</h2><ul>
<li><code>-a</code>: 显示活跃/非活跃内存</li>
<li><code>-f</code>: 不与其他选项同时使用，显示系统从启动到现在fork（包含fork、vfork、clone系统调用）次数，等同于创建的任务数。不重复显示。</li>
<li><code>-m</code>: 显示板子（网卡等）信息</li>
<li><code>-n</code>: 让表头在刷新显示过程中只显示一次</li>
<li><code>-s</code>: 显示一系列事件总数和内存统计，不重复显示</li>
<li><code>delay</code>: 更新时间，如果没有设置这个参数，则显示的是从系统启动到现在的均值</li>
<li><code>count</code>: 刷新次数</li>
<li><code>-d</code>: 磁盘统计信息</li>
<li><code>-w</code>: 扩大打印列宽</li>
<li><code>-p</code>: 指定磁盘分区，获得更详细的统计信息。</li>
<li><code>-S</code>: 指定单位<code>k/K/m/M</code> 分别表示：<code>1000/1024/1000000/1048576</code> </li>
<li><code>-V</code>: 显示版本信息</li>
</ul>
<h2 id="VM模式显示字段说明">VM模式显示字段说明</h2><h3 id="Procs">Procs</h3><ul>
<li><code>r</code>: 等待运行的进程数</li>
<li><code>b</code>: 不可中断的休眠进程数</li>
</ul>
<h3 id="Memory">Memory</h3><ul>
<li><code>swpd</code>: 虚拟内存使用量</li>
<li><code>free</code>: 空闲内存</li>
<li><code>buff</code>: 作为缓冲区的内存数</li>
<li><code>cache</code>: 作为加速缓存的内存数</li>
<li><code>inactive</code>: 不活跃的内存</li>
<li><code>active</code>: 活跃内存</li>
</ul>
<h3 id="Swap">Swap</h3><ul>
<li><code>si</code>: 从磁盘换入占用内存数</li>
<li><code>so</code>: 换出到磁盘的内存数</li>
</ul>
<h3 id="IO">IO</h3><ul>
<li><code>bi</code>: 从块设备输入的块数</li>
<li><code>bo</code>: 从块设备输出的块数</li>
</ul>
<h3 id="System">System</h3><ul>
<li><code>in</code>: 每秒中断次数（包含时钟中断）</li>
<li><code>cs</code>: 每秒上下文切换次数</li>
</ul>
<h3 id="CPU">CPU</h3><p>下面的指标是CPU时间的百分比</p>
<ul>
<li><code>us</code>: 用户区代码CPU时间</li>
<li><code>sy</code>: 内核代码CPU时间</li>
<li><code>id</code>: 空闲CPU时间</li>
<li><code>wa</code>: IO等待时间</li>
<li><code>st</code>: 从虚拟机偷的CPU时间</li>
</ul>
<h2 id="磁盘模式显示选项说明">磁盘模式显示选项说明</h2><h3 id="Reads">Reads</h3><ul>
<li><code>total</code>: 成功读出的总量</li>
<li><code>merged</code>: 单次I/O读操作的量（合并到一次）</li>
<li><code>sectors</code>: 成功读取的扇区数</li>
<li><code>ms</code>: 读操作的时间</li>
</ul>
<h3 id="Writes">Writes</h3><ul>
<li><code>total</code>: 成功写入的总量</li>
<li><code>merged</code>: 单次I/O写操作的量（合并到一次）</li>
<li><code>sectors</code>: 成功写入的扇区数</li>
<li><code>ms</code>: 写操作的时间</li>
</ul>
<h3 id="IO-1">IO</h3><ul>
<li><code>cur</code>: 当前正在进行的I/O </li>
<li><code>s</code>: I/O消耗的时间（秒）</li>
</ul>
<h2 id="重要">重要</h2><p>vmstat不需要特殊的权限。当前所有linux的块大小都是1024 bytes。旧版内核可能是512 bytes 2048 bytes 或 4096bytes。</p>
<h2 id="示例：">示例：</h2><p>在CPU密集型机器上：</p>
<p><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-12-01/1.png" alt="vmstat1"></p>
<p>在GPU机器上：</p>
<p><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-12-01/2.png" alt="vmstat2"></p>
<h2 id="参考">参考</h2><ul>
<li><em>vmstat man page</em></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：vmstat用法<br><strong>Abstract</strong>: usage of vmstat<br>]]>
    
    </summary>
    
      <category term="vmstat" scheme="http://zuoqy.com/tags/vmstat/"/>
    
      <category term="性能监控" scheme="http://zuoqy.com/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    
      <category term="performance" scheme="http://zuoqy.com/categories/performance/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Hbase in Action》读书笔记]]></title>
    <link href="http://zuoqy.com/2015/11/04/hbase-in-action/"/>
    <id>http://zuoqy.com/2015/11/04/hbase-in-action/</id>
    <published>2015-11-04T12:38:18.000Z</published>
    <updated>2015-11-05T14:20:53.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：<em>Hbase in Action</em> 读书笔记。</p>
<p><strong>Abstract</strong>: <em>HBase in Action</em> notes.<br><a id="more"></a></p>
<h2 id="使用场景和成功案例">使用场景和成功案例</h2><h3 id="抓取增量数据">抓取增量数据</h3><ul>
<li>抓取监控指标 OpenTSDB：采集机器监控指标和日志信息，并支持按照时间序列进行查询</li>
<li>抓取用户交互数据：Facebook 和 StumbleUpon</li>
<li>遥测技术：Mozillahe Trend Micro: 收集软件崩溃报告</li>
<li>广告效果和点击流：</li>
</ul>
<h3 id="内容服务">内容服务</h3><ul>
<li>URL短连接：存储短连接和原始连接之间的映射关系</li>
<li>runa.com用户模型服务：实时报价。</li>
</ul>
<h3 id="信息交换">信息交换</h3><ul>
<li>Facebook的短信交换系统</li>
</ul>
<h2 id="概要">概要</h2><h3 id="五个基本命令">五个基本命令</h3><ul>
<li>Get</li>
<li>Put</li>
<li>Delete</li>
<li>Scan</li>
<li>Increment</li>
</ul>
<h3 id="数据存储">数据存储</h3><h4 id="无模式">无模式</h4><p>Hbase是无模式的，不需要事先定义Schema，不需要提前指定列和数据类型，只需要在写数据时给出列的名字。</p>
<h3 id="工作机制">工作机制</h3><h4 id="写机制">写机制</h4><ul>
<li><strong>持久化保证</strong>写入时会写到两个地方：预写式日志（WAL）和MemStore，只有这两个地方写完成才算写成功。</li>
<li><strong>写速度</strong>：Memstore是内存缓冲区，缓冲区满才刷磁盘（HFile）。HFile是磁盘文件，对应列族。<strong>列族和HFile之间是一对多的关系。一个列族可以有多个HFile，但一个HFile只对应一个列族</strong>。</li>
<li><strong>崩溃恢复</strong>：在写动作完成之前先写WAL，HBase集群中的每台服务器维护一个WAL，服务器宕机情况下，可以通过回放WAL的方式来恢复。跳过WAL可以提高写性能，但可能会产生数据丢失。</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Put p = <span class="keyword">new</span> Put();</span><br><span class="line"><span class="comment">//禁用预写日志</span></span><br><span class="line">p.setWriteToWAL(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h4 id="读机制">读机制</h4><ul>
<li><strong>毫秒级读</strong>：Hbase在读操作上使用了LRU缓存BlockCache（与MemStore在同一个JVM堆里），每个列族都有自己的BlockCache。</li>
<li><strong>Block设置</strong>：Block是简历索引和从磁盘读的最小单位，默认是64KB。根据查询方式是Scan居多还是KV查询居多可以调整Block大小。scan居多时，调大block可以增大读取速度。并减少索引所占空间。</li>
</ul>
<h4 id="删除机制">删除机制</h4><ul>
<li><strong>合并</strong>：Delete命令之后，并不是立即删除内容，而是针对被删除内容写入一条新的墓碑记录（tombstone）来标记删除。墓碑记录不能在scan和get时返回结果。直到执行一次大合并（major compaction）这些墓碑记录占用的空间才被释放。</li>
<li><strong>小合并</strong>：合并分为大合并和小合并，小合并把多个HFile合并成一个大HFile。然后把新Hfile标记为激活状态，合并前的旧HFile被删除。</li>
<li><strong>大合并</strong>：处理给定region一个列族的所有HFile。大合并消耗资源，不会频繁发生，但是清理被删除记录的唯一机会。</li>
</ul>
<h4 id="时间版本">时间版本</h4><p>Hbase中的数据有时间版本的概念，Hbase中的时间版本是long类型的，以毫秒为单位的当前时间。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;KeyValue&gt; kv = r.getColumn(Bytes.toBytes(<span class="string">"family"</span>),Bytes.toBytes(<span class="string">"col1"</span>));</span><br><span class="line">kv.<span class="literal">get</span>(<span class="number">0</span>).getValue();</span><br><span class="line">kv.<span class="literal">get</span>(<span class="number">1</span>).getValue();</span><br></pre></td></tr></table></figure>
<h3 id="数据模型">数据模型</h3><ul>
<li><strong>表（Table）</strong>：Hbase使用table组织数据，表名是字符串，由可以在文件系统路径里使用的字符构成。</li>
<li><strong>行（Row)</strong>: 在表里，数据按行存储，行由行键（Rowkey）作为唯一标识。行键没有数据类型，总是视为<code>byte[]</code>.</li>
<li><strong>列族（column family）</strong>：行里的数据按照列族分组，列族影响到Hbase数据的物理存放。他们必须事先定义好并且不轻易修改。</li>
<li><strong>列限定符（column qualifier）</strong>：列族里的数据通过列限定符或列来定位。列限定符不必实现定义，不必再不同行之间保持一致。列限定符都是<code>byte[]</code>。</li>
<li><strong>单元（cell）</strong>：行键、列族和列限定符一起确定一个单元。存储在单元中的数据成为<em>值（value）</em>。值都是<code>byte[]</code>.</li>
<li><strong>时间版本</strong>：单元值有时间版本，时间版本用long型时间戳标识。时间版本的数量基于列族配置，默认数量是3.</li>
</ul>
<p>关系型数据库中的数据是<em>结构化数据</em>，Hbase中的数据是<em>半结构化数据</em>。Hbase是专门为半结构化数据和水平可扩展性设计的数据库。</p>
<h3 id="数据坐标">数据坐标</h3><p>Hbase依次使用：行键、列族、列限定符和时间版本作为数据的坐标。基于非键值查询Hbase的唯一办法就是带过滤器的扫描。</p>
<h3 id="事务特性">事务特性</h3><p>Hbase不是ACID兼容数据库。</p>
<ul>
<li>同一行上的<code>Put()</code>操作具有原子性。要么整体成功，要么整体失败。</li>
<li>行间的<code>Put()</code>操作不是原子性的。</li>
<li><code>Get()</code>操作返回当时所保存的完整行数据。</li>
<li><code>Scan()</code>操作不是扫描快照，在扫描过程中如果有行更新，则扫描到的结果包含更新后的完整的行</li>
</ul>
<h2 id="Hbase表设计">Hbase表设计</h2><h3 id="IO优化">IO优化</h3><h4 id="写优化">写优化</h4><ul>
<li>散列：通过散列行键（如取Md5或SHA1）来避免Region热点的问题。</li>
<li>salting：通过在行键上加上前缀，将数据分散到各个Region。</li>
</ul>
<p>但以上两种方案会使Scan性能下降(连续的记录被打散到多个Region中)。</p>
<h4 id="读优化">读优化</h4><p>例：推贴按照倒序时间戳和用户id组成的复合行键可以scan出最近n条用户推贴。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：<em>Hbase in Action</em> 读书笔记。</p>
<p><strong>Abstract</strong>: <em>HBase in Action</em> notes.<br>]]>
    
    </summary>
    
      <category term="Hbase" scheme="http://zuoqy.com/tags/Hbase/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则表达式参考手册]]></title>
    <link href="http://zuoqy.com/2015/07/24/regex/"/>
    <id>http://zuoqy.com/2015/07/24/regex/</id>
    <published>2015-07-24T02:14:45.000Z</published>
    <updated>2015-07-26T12:39:51.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：正则表达式参考手册<br><strong>Abstract</strong>: Regular Expression Reference<br><a id="more"></a></p>
<h2 id="Character_classes">Character classes</h2><table>
<thead>
<tr>
<th style="text-align:left">Exp.</th>
<th style="text-align:left">Match</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">Matches any character except line breaks. Equivalent to <code>[^\n\r]</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>\w</code></td>
<td style="text-align:left">Matches any word character (alphanumeric &amp; underscore). Only matches low-ascii characters (no accented or non-roman characters). Equivalent to <code>[A-Za-z0-9_]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\W</code></td>
<td style="text-align:left">Matches any character that is not a word character (alphanumeric <code>&amp;</code> underscore). Equivalent to <code>[^A-Za-z0-9_]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\d</code></td>
<td style="text-align:left">Matches any digit character (0-9). Equivalent to <code>[0-9]</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>\D</code></td>
<td style="text-align:left">Matches any character that is not a digit character (0-9). Equivalent to <code>[^0-9]</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>\s</code></td>
<td style="text-align:left">Matches any whitespace character (spaces, tabs, line breaks).</td>
</tr>
<tr>
<td style="text-align:left"><code>\S</code></td>
<td style="text-align:left">Matches any character that is not a whitespace character (spaces, tabs, line breaks).</td>
</tr>
<tr>
<td style="text-align:left"><code>[ABC]</code></td>
<td style="text-align:left">Match any character in the set.</td>
</tr>
<tr>
<td style="text-align:left"><code>[^ABC]</code></td>
<td style="text-align:left">Match any character that is not in the set.</td>
</tr>
<tr>
<td style="text-align:left"><code>a-z</code></td>
<td style="text-align:left">Matches a character having a character code between the two specified characters inclusive.</td>
</tr>
</tbody>
</table>
<h2 id="Anchors">Anchors</h2><table>
<thead>
<tr>
<th style="text-align:left">Exp.</th>
<th style="text-align:left">Match</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">Matches the beginning of the string, or the beginning of a line if the multiline flag (m) is enabled. This matches a position, not a character.</td>
</tr>
<tr>
<td style="text-align:left"><code>$</code></td>
<td style="text-align:left">Matches the end of the string, or the end of a line if the multiline flag (m) is enabled. This matches a position, not a character.</td>
</tr>
<tr>
<td style="text-align:left"><code>\b</code></td>
<td style="text-align:left">Matches a word boundary position such as whitespace, punctuation, or the start/end of the string. This matches a position, not a character.</td>
</tr>
<tr>
<td style="text-align:left"><code>\B</code></td>
<td style="text-align:left">Matches any position that is not a word boundary. This matches a position, not a character.</td>
</tr>
</tbody>
</table>
<h2 id="Escape_charactors">Escape charactors</h2><table>
<thead>
<tr>
<th style="text-align:left">Exp.</th>
<th style="text-align:left">Match</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\.</code> <code>\*</code> <code>\\</code> <code>\+</code> <code>\*</code> <code>\?</code> <code>\{</code> <code>\(</code> <code>\[</code></td>
<td style="text-align:left">escaped special characters</td>
</tr>
<tr>
<td style="text-align:left"><code>\t</code> <code>\v</code> <code>\n</code> <code>\r</code> <code>\f</code></td>
<td style="text-align:left">tab, vertical tab, linefeed, carriage return, FORM FEED character (char code 12).</td>
</tr>
<tr>
<td style="text-align:left"><code>\u00A9</code></td>
<td style="text-align:left">unicode escaped ©</td>
</tr>
<tr>
<td style="text-align:left"><code>\000</code></td>
<td style="text-align:left">Octal escaped character in the form <code>\000</code>(null). Value must be less than 255 (<code>\377</code>).</td>
</tr>
<tr>
<td style="text-align:left"><code>\xFF</code></td>
<td style="text-align:left">Hexadecimal escaped character in the form <code>\xFF</code>.</td>
</tr>
</tbody>
</table>
<h2 id="Groups_and_Lookaround">Groups and Lookaround</h2><p>Quantifiers indicate that the preceding token must be matched a certain number of times. By default, quantifiers are greedy, and will match as many characters as possible.<br>Alternation acts like a boolean OR, matching one sequence or another.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Exp.</th>
<th style="text-align:left">Match</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(abc)</td>
<td style="text-align:left">capture group</td>
</tr>
<tr>
<td style="text-align:left"><code>\1</code></td>
<td style="text-align:left">Back reference. Matches the results of a previous capture group. For example \1 matches the results of the first capture group <code>&amp;</code> \3 matches the third.</td>
</tr>
<tr>
<td style="text-align:left"><code>(?:abc)</code></td>
<td style="text-align:left">Non-capturing group. Groups multiple tokens together without creating a capture group.</td>
</tr>
<tr>
<td style="text-align:left"><code>(?=abc)</code></td>
<td style="text-align:left">Positive lookahead. Matches a group after the main expression without including it in the result.</td>
</tr>
<tr>
<td style="text-align:left"><code>(?!abc)</code></td>
<td style="text-align:left">Negative lookahead. Specifies a group that can not match after the main expression (if it matches, the result is discarded).</td>
</tr>
<tr>
<td style="text-align:left"><code>(?&lt;=ABC)</code></td>
<td style="text-align:left">Positive lookbehind. Matches a group before the main expression without including it in the result.</td>
</tr>
<tr>
<td style="text-align:left"><code>(?&lt;!ABC)</code></td>
<td style="text-align:left">Negative lookbhind. Specifies a group that can not match before the main expression (if it matches, the result is discarded).</td>
</tr>
</tbody>
</table>
<h2 id="Quantifiers_and_Alternation">Quantifiers and Alternation</h2><table>
<thead>
<tr>
<th style="text-align:left">Exp.</th>
<th style="text-align:left">Match</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">Matches 1 or more of the preceding token.</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">Matches 0 or more of the preceding token.</td>
</tr>
<tr>
<td style="text-align:left"><code>{1,3}</code></td>
<td style="text-align:left">Quantifier.Matches the specified quantity of the previous token. <code>{1,3}</code> will match 1 to 3. <code>{3}</code> will match exactly 3. <code>{3,}</code> will match 3 or more.</td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left">Optional. Matches 0 or 1 of the preceding token, effectively making it optional.</td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left">Makes the preceding quantifier lazy, causing it to match as few characters as possible. By default, quantifiers are greedy, and will match as many characters as possible.</td>
</tr>
</tbody>
</table>
<p>Note:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| Acts like <span class="operator">a</span> boolean OR. Matches <span class="operator">the</span> expression <span class="keyword">before</span> <span class="operator">or</span> <span class="keyword">after</span> <span class="operator">the</span> |.It can operate <span class="operator">within</span> <span class="operator">a</span> group, <span class="operator">or</span> <span class="command"><span class="keyword">on</span> <span class="title">a</span> <span class="title">whole</span> <span class="title">expression</span>. <span class="title">The</span> <span class="title">patterns</span> <span class="title">will</span> <span class="title">be</span> <span class="title">tested</span> <span class="title">in</span> <span class="title">order</span>.</span></span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2><ul>
<li><a href="http://regexr.com/" target="_blank" rel="external">http://regexr.com/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：正则表达式参考手册<br><strong>Abstract</strong>: Regular Expression Reference<br>]]>
    
    </summary>
    
      <category term="Regular Expression" scheme="http://zuoqy.com/tags/Regular-Expression/"/>
    
      <category term="json" scheme="http://zuoqy.com/tags/json/"/>
    
      <category term="正则表达式" scheme="http://zuoqy.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入HashMap]]></title>
    <link href="http://zuoqy.com/2015/06/22/java-hashmap/"/>
    <id>http://zuoqy.com/2015/06/22/java-hashmap/</id>
    <published>2015-06-22T13:51:04.000Z</published>
    <updated>2015-12-01T06:46:11.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：JDK1.7 HashMap源码阅读<br><strong>Abstract</strong>: Source code analysis of JDK1.7</p>
<a id="more"></a>
<h2 id="概述">概述</h2><p>HashMap实现了Map接口，HashMap和Hashtable唯一的区别就是HashMap不是线程安全的，并且允许插入空值。影响HashMap性能的参数有两个：<em>初始大小</em>和<em>填装因子（Load Factor）</em>，初始大小设置HashMap中初始有多少个bucket，填装因子则设置HashMap中的元素占总容量的最大比例，超过这一比例时，HashMap将自动扩容。当Entry数量超过容量乘以填装因子时，HashMap中的元素将会被rehash到一个二倍于原来容量的新哈希表中。<br>一般情况下，填装因子默认设置为0.75，这个数值是空间和时间的折中。填装因子增大会减少HashMap所占空间，但会增加查找时间。为了保证效率，最好能对放入HashMap中的元素总数有一个预估，设置适当的初始大小从而避免<em>rehash</em>发生。<br>需要注意的是，HashMap不是线程安全的，当多个线程同时改变同一个HashMap实例的结构时（structural modification），必须有额外的同步。所谓改变HashMap的结构，就是添加或者删除Mapping。只是改变key对应的value的值，不能算改变结构。同步操作可以在额外的Object实例上同步，也可以使用<code>Map m = Collections.synchronizedMap(new HashMap(...));</code>，如果没有做正确的同步，HashMap上的并发操作会<em>快速失败（fail-fast）</em>（事实上，它并不能保证未经同步的并发修改操作绝对能够快速失败），并抛出<code>ConcurrentModificationException</code>，这个异常机制只能用来检查程序是否有潜在的BUG，不能依赖这个异常去做程序逻辑的其他判断。</p>
<p><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-06-22/1.png" alt="HashMap-dia"></p>
<h2 id="结构">结构</h2><p>HashMap最基本的构成单位是Entry，在HashMap内部，所有的键值对都存储在Entry数组中，如果放入HashMap的键值对有冲突，则用拉链法，把具有相同哈希值的Entry存放在一个链表中，如下图所示：</p>
<p><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-06-22/2.png" alt="HashMap-structure"></p>
<p>Entry类的定义如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K <span class="variable">key</span>;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="built_in">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates new entry.</span><br><span class="line">     */</span></span><br><span class="line">    Entry(<span class="built_in">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        <span class="variable">key</span> = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K getKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">key</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V getValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> o) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        <span class="keyword">Object</span> k1 = getKey();</span><br><span class="line">        <span class="keyword">Object</span> k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            <span class="keyword">Object</span> v1 = getValue();</span><br><span class="line">            <span class="keyword">Object</span> v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">int</span> hashCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This method is invoked whenever the value in an entry is</span><br><span class="line">     * overwritten by an invocation of put(k,v) for a key k that's already</span><br><span class="line">     * in the HashMap.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">void</span> recordAccess(<span class="keyword">HashMap</span>&lt;K,V&gt; m) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This method is invoked whenever the entry is</span><br><span class="line">     * removed from the table.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">void</span> recordRemoval(<span class="keyword">HashMap</span>&lt;K,V&gt; m) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重要的属性和常量">重要的属性和常量</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量，必须是2的指数幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap的最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认填装因子load factor</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75</span>f;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空哈希表 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表，长度必须是2的整数指数幂</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阈值（capacity * load factor），当键值对数量超过该值时扩容</span></span><br><span class="line"><span class="comment">// 当表为空表时，该值是默认初始大小</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填装因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表结构改变（Structurally Modified）的次数</span></span><br><span class="line"><span class="comment">// 结构改变：键值对数量变化、rehash</span></span><br><span class="line"><span class="comment">// 用于快速未经同步的并发操作的失败</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用替代hash算法的阈值</span></span><br><span class="line"> <span class="comment">// 替代Hash算法降低了String类型的key的冲突的可能性</span></span><br><span class="line"> <span class="comment">// 容量超过这个阈值的时候，将使用替代Hash算法</span></span><br><span class="line"> <span class="comment">// 这个值可由系统参数jdk.map.althashing.threshold指定</span></span><br><span class="line"> <span class="comment">// 当此系统参数为1时，确保总是使用替代hash算法</span></span><br><span class="line"> <span class="comment">// 为-1时，确保永远不适用替代hash算法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * A randomizing value associated with this instance that is applied to</span><br><span class="line"> * hash code of keys to make hash collisions harder to find. If 0 then</span><br><span class="line"> * alternative hashing is disabled.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 用于减少key的hash code冲突</span></span><br><span class="line"><span class="comment">// 如果是0，表示不使用替代的hash算法</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> hashSeed = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><code>ALTERNATIVE_HASHING_THRESHOLD_DEFAULT</code>初始化代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放虚拟机启动后才能初始化的内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> &#123;</span></span><br><span class="line">    <span class="comment">// 使用替代hash算法的容量阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="typename">int</span> ALTERNATIVE_HASHING_THRESHOLD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        String altThreshold = java.security.AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> sun.security.action.GetPropertyAction(</span><br><span class="line">                <span class="string">"jdk.map.althashing.threshold"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="typename">int</span> threshold;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threshold = (<span class="literal">null</span> != altThreshold)</span><br><span class="line">                    ? Integer.parseInt(altThreshold)</span><br><span class="line">                    : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// disable alternative hashing if -1</span></span><br><span class="line">            <span class="keyword">if</span> (threshold == -<span class="number">1</span>) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (threshold &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"value must be positive integer."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException failed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Illegal value for 'jdk.map.althashing.threshold'"</span>, failed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ALTERNATIVE_HASHING_THRESHOLD = threshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法">构造方法</h2><p>指定初始大小和填装因子，创建HashMap：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity; <span class="comment">// 这里并没有设置table，而是设置阈值</span></span><br><span class="line">    init(); <span class="comment">// 空方法，用于继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定初始大小，创建HashMap，填装因子使用默认值 0.75</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认初始大小和填装因子，创建HashMap：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据已有的Hashmap创建，使用默认的填装因子，和根据填装因子计算出的容量：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重要内部类">重要内部类</h2><h3 id="Entry类"><code>Entry</code>类</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K <span class="variable">key</span>;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="built_in">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates new entry.</span><br><span class="line">     */</span></span><br><span class="line">    Entry(<span class="built_in">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        <span class="variable">key</span> = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K getKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">key</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V getValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> o) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        <span class="keyword">Object</span> k1 = getKey();</span><br><span class="line">        <span class="keyword">Object</span> k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            <span class="keyword">Object</span> v1 = getValue();</span><br><span class="line">            <span class="keyword">Object</span> v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">int</span> hashCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This method is invoked whenever the value in an entry is</span><br><span class="line">     * overwritten by an invocation of put(k,v) for a key k that's already</span><br><span class="line">     * in the HashMap.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">void</span> recordAccess(<span class="keyword">HashMap</span>&lt;K,V&gt; m) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This method is invoked whenever the entry is</span><br><span class="line">     * removed from the table.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">void</span> recordRemoval(<span class="keyword">HashMap</span>&lt;K,V&gt; m) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Iterators">Iterators</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator&lt;E&gt;</span> <span class="title">implements</span> <span class="title">Iterator&lt;E&gt;</span> &#123;</span></span><br><span class="line">    <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    int expectedModCount;   <span class="comment">// For fast-fail</span></span><br><span class="line">    int index;              <span class="comment">// current slot</span></span><br><span class="line">    <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; current;     <span class="comment">// current entry</span></span><br><span class="line"></span><br><span class="line">    <span class="type">HashIterator</span>() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// 设置next为第一个entry</span></span><br><span class="line">            <span class="type">Entry</span>[] t = table;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">final</span> boolean hasNext() &#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; nextEntry() &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((next = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Entry</span>[] t = table;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">        current = e;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ConcurrentModificationException</span>();</span><br><span class="line">        <span class="type">Object</span> k = current.key;</span><br><span class="line">        current = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">HashMap</span>.<span class="keyword">this</span>.removeEntryForKey(k);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HashIterator&lt;V&gt;</span> &#123;</span></span><br><span class="line">    public <span class="type">V</span> next() &#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry().value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HashIterator&lt;K&gt;</span> &#123;</span></span><br><span class="line">    public <span class="type">K</span> next() &#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry().getKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HashIterator&lt;Map</span>.<span class="title">Entry&lt;K</span>,<span class="title">V&gt;&gt;</span> &#123;</span></span><br><span class="line">    public <span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next() &#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KeySet">KeySet</h3><p>这个集合是一个代理集合，真正的数据对象是map，所以map的改动会反映在Set上，反之亦然。<br>此集合支持：<code>Iterator.remove()</code>、<code>Set.remove()</code>、<code>removeAll()</code>、<code>clear()</code><br>不支持：<code>add()</code>和<code>addAll()</code></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;K&gt; iterator() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">newKeyIterator</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">containsKey</span><span class="params">(o)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HashMap.<span class="keyword">this</span>.removeEntryForKey(o) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似<code>HashMap.this.xxx()</code>是内部类调用外部类对象非静态方法时需要明确给出的，否则会调用内部类本身的<code>xxx()</code>方法。</p>
<h3 id="Values">Values</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;V&gt; iterator() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">newValueIterator</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">containsValue</span><span class="params">(o)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主要方法">主要方法</h2><h3 id="clear">clear</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Removes all of the mappings from this map.</span><br><span class="line"> * The map will be empty after this call returns.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">clear</span>() &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    Arrays.<span class="built_in">fill</span>(table, <span class="keyword">null</span>);</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="clone">clone</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">Object</span> clone() &#123;</span><br><span class="line">    <span class="type">HashMap</span>&lt;K,V&gt; <span class="literal">result</span> = null;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="literal">result</span> = (<span class="type">HashMap</span>&lt;K,V&gt;)super.clone();</span><br><span class="line">    &#125; catch (<span class="type">CloneNotSupportedException</span> e) &#123;</span><br><span class="line">        // assert <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">result</span>.table != <span class="type">EMPTY_TABLE</span>) &#123;</span><br><span class="line">        <span class="literal">result</span>.inflateTable(<span class="type">Math</span>.min(</span><br><span class="line">            (<span class="type">int</span>) <span class="type">Math</span>.min(</span><br><span class="line">                size * <span class="type">Math</span>.min(<span class="number">1</span> / loadFactor, <span class="number">4</span>.<span class="number">0</span>f),</span><br><span class="line">                // we have limits...</span><br><span class="line">                <span class="type">HashMap</span>.<span class="type">MAXIMUM_CAPACITY</span>),</span><br><span class="line">           table.length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">result</span>.entrySet = null;</span><br><span class="line">    <span class="literal">result</span>.modCount = <span class="number">0</span>;</span><br><span class="line">    <span class="literal">result</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="literal">result</span>.init();</span><br><span class="line">    <span class="literal">result</span>.putAllForCreate(this);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="containsKey">containsKey</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> containsKey(<span class="keyword">Object</span> <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> getEntry(<span class="variable">key</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="containsValue">containsValue</h3><p>顺序查找每一个slot的下拉链表</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">containsValue</span><span class="params">(Object <span class="keyword">value</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> containsNullValue();</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span>.equals(e.<span class="keyword">value</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="entrySet">entrySet</h3><p>返回的是HashMap的成员变量，如果是null，新建一个空集合。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">Set</span><span class="subst">&lt;</span><span class="built_in">Map</span><span class="built_in">.</span>Entry<span class="subst">&lt;</span>K,V<span class="subst">&gt;&gt;</span> entrySet() &#123;</span><br><span class="line">    <span class="keyword">return</span> entrySet0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">Set</span><span class="subst">&lt;</span><span class="built_in">Map</span><span class="built_in">.</span>Entry<span class="subst">&lt;</span>K,V<span class="subst">&gt;&gt;</span> entrySet0() &#123;</span><br><span class="line">    <span class="built_in">Set</span><span class="subst">&lt;</span><span class="built_in">Map</span><span class="built_in">.</span>Entry<span class="subst">&lt;</span>K,V<span class="subst">&gt;&gt;</span> es <span class="subst">=</span> entrySet;</span><br><span class="line">    <span class="keyword">return</span> es <span class="subst">!=</span> <span class="built_in">null</span> <span class="subst">?</span> es : (entrySet <span class="subst">=</span> <span class="literal">new</span> EntrySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get">get</h3><p>如果key为null，在<code>table[0]</code>链表上查找，否则调用getEntry方法</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(<span class="variable">key</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="isEmpty">isEmpty</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="keySet">keySet</h3><p>返回map中的所有的key的集合 详见类<a href="#KeySet">KeySet</a></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="built_in">Set</span><span class="subst">&lt;</span>K<span class="subst">&gt;</span> keySet() &#123;</span><br><span class="line">    <span class="built_in">Set</span><span class="subst">&lt;</span>K<span class="subst">&gt;</span> ks <span class="subst">=</span> keySet;</span><br><span class="line">    <span class="keyword">return</span> (ks <span class="subst">!=</span> <span class="built_in">null</span> <span class="subst">?</span> ks : (keySet <span class="subst">=</span> <span class="literal">new</span> KeySet()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="put">put</h3><p>将k-v放入map，如果key在map中已经存在，则用新值替换旧值。注意，HashMap允许key value为null。<br>如果key为null，则指定在<code>table[0]</code>拉链。<br>因此，条件<code>get(xxx) == null</code> 并不能判断key-value不存在HashMap中。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V put(K <span class="variable">key</span>, V value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">key</span> == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="built_in">int</span> hash = hash(<span class="variable">key</span>);</span><br><span class="line">    <span class="built_in">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">Object</span> k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.<span class="variable">key</span>) == <span class="variable">key</span> || <span class="variable">key</span>.equals(k))) &#123; <span class="comment">// 注意判断条件</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, <span class="variable">key</span>, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="putAll">putAll</h3><p>这里注意以下HashMap扩容的条件并不是<code>(m.size() + size) &gt;= threshold</code>，如果<code>m</code>中的key和hashmap中的key有重复，则可能导致不必要的扩容操作。<br>在这个方法里，扩容的条件计算非常保守，使得最多进行一次扩容一次。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeysToBeAdded = m.size();</span><br><span class="line">    <span class="keyword">if</span> (numKeysToBeAdded == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable((<span class="keyword">int</span>) Math.max(numKeysToBeAdded * loadFactor, threshold));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Expand the map if the map if the number of mappings to be added</span><br><span class="line">     * is greater than or equal to threshold.  This is conservative; the</span><br><span class="line">     * obvious condition is (m.size() + size) &gt;= threshold, but this</span><br><span class="line">     * condition could result in a map with twice the appropriate capacity,</span><br><span class="line">     * if the keys to be added overlap with the keys already in this map.</span><br><span class="line">     * By using the conservative calculation, we subject ourself</span><br><span class="line">     * to at most one extra resize.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (numKeysToBeAdded &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">int</span> targetCapacity = (<span class="keyword">int</span>)(numKeysToBeAdded / loadFactor + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (targetCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            targetCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = table.length;</span><br><span class="line">        <span class="keyword">while</span> (newCapacity &lt; targetCapacity)</span><br><span class="line">            newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; table.length)</span><br><span class="line">            resize(newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内部方法">内部方法</h2><h3 id="roundUpToPowerOf2">roundUpToPowerOf2</h3><p>给定一个非负整数，给出大于等于这个数的2的指数幂</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="built_in">int</span> roundUpToPowerOf2(<span class="built_in">int</span> <span class="keyword">number</span>) &#123;</span><br><span class="line">    // assert <span class="keyword">number</span> &gt;= <span class="number">0</span> : <span class="string">"number must be non-negative"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">number</span> &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (<span class="keyword">number</span> &gt; <span class="number">1</span>) ? <span class="type">Integer</span>.highestOneBit((<span class="keyword">number</span> - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="inflateTable">inflateTable</h3><p>扩容，容量是2的指数幂。扩容后，设置下一次需要扩容的阈值。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">//设置阈值：当size达到这个值时，再次扩容</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initHashSeedAsNeeded">initHashSeedAsNeeded</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing</span><br><span class="line">            ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</span><br><span class="line">            : 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getEntry">getEntry</h3><p>查找指定key对应的Entry。查找时，根据hash值找到table的index，然后沿着下拉链表一次顺序查找。如果没有找到，返回null。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(<span class="keyword">Object</span> <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> hash = (<span class="variable">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(<span class="variable">key</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        <span class="keyword">Object</span> k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.<span class="variable">key</span>) == <span class="variable">key</span> || (<span class="variable">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="variable">key</span>.equals(k)))) <span class="comment">// 注意条件判断</span></span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="containsNullValue">containsNullValue</h3><p>这个方法用来查找value为null的情况，这样做是为了不在每次迭代都做类似<code>if (value == e.value || (value != null &amp;&amp; value.equals(e.value)))</code>的复杂判断，代码清晰很多。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> private boolean containsNullValue() &#123;</span><br><span class="line">    Entry[] <span class="keyword">tab</span> = <span class="keyword">table</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; <span class="keyword">tab</span>.length ; i++)</span><br><span class="line">        <span class="keyword">for</span> (Entry <span class="keyword">e</span> = <span class="keyword">tab</span>[i] ; <span class="keyword">e</span> != null ; <span class="keyword">e</span> = <span class="keyword">e</span>.next)</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">e</span>.value == null)</span><br><span class="line">                <span class="keyword">return</span> true;</span><br><span class="line">    <span class="keyword">return</span> false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getForNullKey">getForNullKey</h3><p>当key为null的时候，挂在<code>table[0]</code>上，只需要查找<code>table[0]</code>上，key为null的元素Entry即可。如果没有，返回null。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> e.<span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hash">hash</h3><p>这个方法保证hashCode改变常数被，在hash值每一位上冲突的可能性在默认的填装因子下，碰撞的次数最高位8</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final int hash(Object k) &#123;</span><br><span class="line">    int <span class="keyword">h</span> = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (0 != <span class="keyword">h</span> &amp;&amp; k instanceof String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">h</span> ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    <span class="keyword">h</span> ^= (<span class="keyword">h</span> &gt;&gt;&gt; 20) ^ (<span class="keyword">h</span> &gt;&gt;&gt; 12);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">h</span> ^ (<span class="keyword">h</span> &gt;&gt;&gt; 7) ^ (<span class="keyword">h</span> &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：JDK1.7 HashMap源码阅读<br><strong>Abstract</strong>: Source code analysis of JDK1.7</p>]]>
    
    </summary>
    
      <category term="HashMap" scheme="http://zuoqy.com/tags/HashMap/"/>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="Java" scheme="http://zuoqy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入Java泛型]]></title>
    <link href="http://zuoqy.com/2015/05/19/java-generic/"/>
    <id>http://zuoqy.com/2015/05/19/java-generic/</id>
    <published>2015-05-19T13:34:22.000Z</published>
    <updated>2015-06-10T14:15:14.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：泛型可以将某些类型相关的错误从运行时提前到编译时显现，但Java的泛型有很多特点和限制。本文介绍了泛型类型、原始类型、泛型方法、有界类型参数、泛型的继承和子类型、类型推断、通配符、类型擦除、非具体化类型和泛型的限制，之前用到的和以后要用的，都在这里了。<br><strong>Abstract</strong>: Java generics add stability to your code by making some bugs about types be detected early on complie-time. This article gives a comprehensive introduction to the important points Java generics.</p>
<h2 id="写在最前面">写在最前面</h2><p>一说泛型，好像都会。但前些天在看源码的时候，发现一个警告，引出了好多泛型的问题，最终让我下定决心整理一下Java泛型的坑（感谢Oracle，有一个很全面的Tutorial，Java编程思想都没有它介绍的详尽）。如果你也觉得你掌握了泛型，不妨试试以下问题，这些问题的解释，就包含在本篇文章里。</p>
<p>先看几个问题：</p>
<a id="more"></a>
<ol>
<li>程序会出错吗？如果出错，是编译时还是运行时呢？</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.util.List;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        i.<span class="keyword">set</span>(<span class="number">0</span>, i.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>下面的程序正确吗？</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaturalNumber</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NaturalNumber</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">this</span>.i = i; &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EvenNumber</span> <span class="keyword">extends</span> <span class="title">NaturalNumber</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EvenNumber</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">super</span>(i); &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Sting[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;EvenNumber&gt; le = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;? extends NaturalNumber&gt; ln = le;</span><br><span class="line">        ln.add(<span class="keyword">new</span> NaturalNumber(<span class="number">35</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>下面的程序呢？</li>
</ol>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">List</span>&lt;<span class="keyword">Integer</span>&gt; li = new ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">List</span>&lt;<span class="keyword">Number</span>&gt;  ln = (<span class="keyword">List</span>&lt;<span class="keyword">Number</span>&gt;) li;</span><br></pre></td></tr></table></figure>
<ol>
<li>下面那个能编译通过呢？</li>
</ol>
<p>a)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">rtti</span><span class="params">(List&lt;E&gt; <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> instanceof ArrayList&lt;Integer&gt;) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b)</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void rtti(<span class="keyword">List</span><span class="preprocessor">&lt;?</span>&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">list</span> <span class="keyword">instanceof</span> ArrayList<span class="preprocessor">&lt;?</span>&gt;) &#123;  </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>下面的程序正确吗？</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> processStringList(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; stringList) &#123;</span><br><span class="line">    <span class="comment">// process stringList</span></span><br><span class="line">&#125;</span><br><span class="line">processStringList(Collections.emptyList());</span><br></pre></td></tr></table></figure>
<p>如果不对，报什么错误呢？</p>
<ol>
<li>下面的程序可以编译通过吗？</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser&lt;T</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Exception&gt;</span> &#123;</span></span><br><span class="line">    public void parse(<span class="type">File</span> file) <span class="keyword">throws</span> <span class="type">T</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>List&lt;Number&gt;</code> 是 <code>List&lt;Integer&gt;</code>的父类型吗？</p>
</li>
<li><p>最后一个问题，为什么Map.get方法没有完全泛型化，而Map.put是完全泛型化的？</p>
</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V <span class="function"><span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line">V <span class="function"><span class="title">get</span><span class="params">(Object key)</span></span></span><br></pre></td></tr></table></figure>
<p>这个题的答案很有意思，见<a href="#refs">参考文献2</a></p>
<h2 id="为什么使用泛型">为什么使用泛型</h2><p>简而言之，泛型就是在定义类、接口、方法的时候，可以把类型（types）作为参数。类型参数使相同的逻辑能够复用在不同类型的输入上。</p>
<h3 id="使用泛型的好处：">使用泛型的好处：</h3><ul>
<li>编译期强类型检查（编译期错误排查难度小于运行时错误）</li>
<li>去除类型转换</li>
</ul>
<pre><code><span class="built_in">List</span> <span class="built_in">list</span> <span class="subst">=</span> <span class="literal">new</span> ArrayList();
<span class="built_in">list</span><span class="built_in">.</span>add(<span class="string">"hello"</span>);
<span class="built_in">String</span> s <span class="subst">=</span> (<span class="built_in">String</span>) <span class="built_in">list</span><span class="built_in">.</span>get(<span class="number">0</span>);

<span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span> <span class="built_in">list</span> <span class="subst">=</span> <span class="literal">new</span> ArrayList<span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span>();
<span class="built_in">list</span><span class="built_in">.</span>add(<span class="string">"hello"</span>);
<span class="built_in">String</span> s <span class="subst">=</span> <span class="built_in">list</span><span class="built_in">.</span>get(<span class="number">0</span>);   <span class="comment">// no cast</span>
</code></pre><ul>
<li>方便开发泛型算法</li>
</ul>
<h2 id="泛型类型（Generic_Types）">泛型类型（Generic Types）</h2><p>泛型类型是通用类或者接口的参数化类型。</p>
<h3 id="简单的Box类">简单的Box类</h3><pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Box</span> {
    <span class="keyword">private</span> Object <span class="keyword">object</span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object <span class="keyword">object</span>)</span> </span>{ <span class="keyword">this</span>.<span class="keyword">object</span> = <span class="keyword">object</span>; }
    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="keyword">object</span>; }
}
</code></pre><p>因为类中的方法接受的参数类型是Object，所以可以接受任何类型的输入参数，。但是在编译期没有办法验证Box类是否被正确的使用了。如果期望从Box中获得一个Integer而却往Box中放入String类型的值，则会出现运行时错误。</p>
<h3 id="泛型版本的Box类">泛型版本的Box类</h3><p>泛型类/接口的定义如下：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">name</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, ..., <span class="title">Tn</span>&gt; </span>{ <span class="comment">/* ... */</span> }
<span class="class"><span class="keyword">interface</span> <span class="title">name</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, ..., <span class="title">Tn</span>&gt; </span>{ <span class="comment">/* ... */</span> }
</code></pre><p>尖括号中包含类型参数声明，分别是T1,T2…Tn</p>
<pre><code><span class="comment">/**
 * Generic version of the Box class.
 * @param &lt;T&gt; the type of the value being boxed
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>{
    <span class="comment">// T stands for "Type"</span>
    <span class="keyword">private</span> T t;

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">set</span>(T t) { <span class="keyword">this</span>.t = t; }
    <span class="keyword">public</span> T <span class="keyword">get</span>() { <span class="keyword">return</span> t; }
}
</code></pre><p>正如上面代码所示，Object类型被替换为T，T是一个类型变量，代表任意非基本类型（non-primitive）。 作为一个例子，并没有问题，但是结合JDK源码，get方法一般不限定泛型，<a href="http://stackoverflow.com/questions/857420/what-are-the-reasons-why-map-getobject-key-is-not-fully-generic" target="_blank" rel="external">详见这里</a>。不要滥用泛型！</p>
<h3 id="类型参数命名惯例">类型参数命名惯例</h3><ul>
<li>E - Element (used extensively by the Java Collections Framework)</li>
<li>K - Key</li>
<li>N - Number</li>
<li>T - Type</li>
<li>V - Value</li>
<li>S,U,V etc. - 2nd, 3rd, 4th types</li>
</ul>
<h3 id="调用和实例化泛型类型">调用和实例化泛型类型</h3><pre><code><span class="built_in">Box</span>&lt;<span class="built_in">Integer</span>&gt; integerBox = new <span class="built_in">Box</span>&lt;<span class="built_in">Integer</span>&gt;();
</code></pre><blockquote>
<p><strong>类型形参（Type Parameter）</strong>和<strong>类型实参（Type Argument）</strong>：<code>Box&lt;T&gt;</code>中的T时类型形参，<code>Box&lt;Integer&gt;</code>中的Integer时类型实参。在能区分两者的语境中，经常不做区分的称为类型参数。</p>
</blockquote>
<p><a id="the-diamond" href="#the-diamond"></a></p>
<h3 id="The_Diamond">The Diamond</h3><p>在JDK7及以后的版本，调用和初始化泛型可以省略构造方法类型实参：</p>
<pre><code><span class="built_in">Box</span>&lt;<span class="built_in">Integer</span>&gt; integerBox = new <span class="built_in">Box</span>&lt;&gt;();
</code></pre><p>更多内容请参见<a href="#type-inference">类型推断（Type Inference）</a></p>
<h3 id="多个类型参数">多个类型参数</h3><pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{
    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedPair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{

    <span class="keyword">private</span> K key;
    <span class="keyword">private</span> V value;

    <span class="function"><span class="keyword">public</span> <span class="title">OrderedPair</span><span class="params">(K key, V value)</span> </span>{
    <span class="keyword">this</span>.key = key;
    <span class="keyword">this</span>.value = value;
    }

    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span>    </span>{ <span class="keyword">return</span> key; }
    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>{ <span class="keyword">return</span> value; }
}
</code></pre><p>可以这样实例化OrderedPair：</p>
<pre><code><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span> p1 <span class="subst">=</span> <span class="literal">new</span> OrderedPair<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span>(<span class="string">"Even"</span>, <span class="number">8</span>);
<span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span>  p2 <span class="subst">=</span> <span class="literal">new</span> OrderedPair<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span>(<span class="string">"hello"</span>, <span class="string">"world"</span>);
</code></pre><p>正如在<a href="#the-diamond">The Diamond</a>一节中所述的，可以将初始化构造方法类型参数省略：</p>
<pre><code>OrderedPair<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span> p1 <span class="subst">=</span> <span class="literal">new</span> OrderedPair<span class="subst">&lt;&gt;</span>(<span class="string">"Even"</span>, <span class="number">8</span>);
OrderedPair<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span>  p2 <span class="subst">=</span> <span class="literal">new</span> OrderedPair<span class="subst">&lt;&gt;</span>(<span class="string">"hello"</span>, <span class="string">"world"</span>);
</code></pre><h3 id="参数化类型嵌套">参数化类型嵌套</h3><pre><code>OrderedPair<span class="subst">&lt;</span><span class="built_in">String</span>, Box<span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;&gt;</span> p <span class="subst">=</span> <span class="literal">new</span> OrderedPair<span class="subst">&lt;&gt;</span>(<span class="string">"primes"</span>, <span class="literal">new</span> Box<span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;</span>(<span class="attribute">...</span>));
</code></pre><p><a id="raw-types" href="#raw-types"></a></p>
<h2 id="原始类型（Raw_Types）">原始类型（Raw Types）</h2><p>原始类型是没有任何类型实参的泛型类或泛型接口。例如:Box类定义如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>{
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">set</span>(T t) { <span class="comment">/* ... */</span> }
    <span class="comment">// ...</span>
}
</code></pre><p>如果类型实参被省略，则创建一个原始类型的Box：</p>
<pre><code><span class="built_in">Box</span> rawBox = new <span class="built_in">Box</span>();
</code></pre><p>上面的代码中，Box是<code>Box&lt;T&gt;</code>的原始类型。但如果Box不是泛型类，创建的对象就不能叫做Box的原始类型。JDK5及之前的代码不支持泛型，为了向前兼容设置的。把一个泛型对象赋值给原始类型引用是被允许的。</p>
<pre><code><span class="built_in">Box</span>&lt;<span class="built_in">String</span>&gt; stringBox = new <span class="built_in">Box</span>&lt;&gt;();
<span class="built_in">Box</span> rawBox = stringBox;               // OK
</code></pre><p>但是如果你将原始类型赋值给泛型引用，则会产生警告：</p>
<pre><code><span class="built_in">Box</span> rawBox = new <span class="built_in">Box</span>();           // rawBox is a raw <span class="keyword">type</span> of <span class="built_in">Box</span>&lt;T&gt;
<span class="built_in">Box</span>&lt;<span class="built_in">Integer</span>&gt; intBox = rawBox;     // warning: unchecked conversion
</code></pre><p>使用原始类型的引用去调用泛型类对象的方法，同样会得到警告：</p>
<pre><code>Box<span class="variable">&lt;String&gt;</span> stringBox = new Box<span class="variable">&lt;&gt;</span>();
Box rawBox = stringBox;
rawBox.<span class="built_in">set</span>(<span class="number">8</span>);  // warning: unchecked invocation <span class="keyword">to</span> <span class="built_in">set</span>(T)
</code></pre><p>原因是使用原始类型的引用去调用泛型类对象的方法，把可能的类型错误推迟到了运行时才能发现。在<a href="#type-erasure">类型擦除</a>部分，将详细介绍编译器如何使用原始类型的。</p>
<h3 id="未检查错误信息（Unchecked_Error_Messages）">未检查错误信息（Unchecked Error Messages）</h3><p>如上面提到的，如果你将泛型代码与遗留的非泛型代码混合使用，就会出现类似下面的编译警告信息：</p>
<pre><code>Note: Example.java <span class="keyword">uses</span> unchecked <span class="keyword">or</span> <span class="keyword">unsafe</span> operations.
Note: Recompile <span class="keyword">with</span> -Xlint:unchecked <span class="keyword">for</span> details.
</code></pre><p>如下面所示，当代码试图使用原始类型引用操作泛型类的对象时：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WarningDemo</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{
        Box&lt;Integer&gt; bi;
        bi = createBox();
    }

    <span class="function"><span class="keyword">static</span> Box <span class="title">createBox</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Box();
    }
}
</code></pre><p><em>unchecked</em>的意思是编译器没有得到足够的类型信息做必要的的类型检查以确保类型安全。尽管编译器会做出提示，但是unchecked警告默认是关闭的，如果需要查看详细的unchecked警告信息，需要在编译时加上<em>-Xlint:unchecked选项</em>。<br>重新编译后会得到像下面这样详细的提示结果：</p>
<pre><code><span class="rule"><span class="attribute">WarningDemo.java</span>:<span class="value"><span class="number">4</span>: warning: [unchecked] unchecked conversion
found   : Box
required: Box&lt;java.lang.Integer&gt;
        bi = <span class="function">createBox</span>()</span></span>;
                      ^
1 <span class="tag">warning</span>
</code></pre><p>当不需要unchecked警告信息的时候，需要显式的使用-Xlint:-unchecked编译选项，或者使用@SuppressWarnings(“unchecked”)注解。</p>
<p><a id="generic-methods" href="#generic-methods"></a></p>
<h2 id="泛型方法（Generic_Methods）">泛型方法（Generic Methods）</h2><p>泛型方法是自身引入类型参数的方法。与泛型类和接口引入的泛型参数不同，其作用范围只在方法声明范围内有效。静态方法、非静态方法以及泛型类的构造方法都可以声明为泛型方法。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>{
    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)</span> </span>{ <span class="comment">//静态泛型方法</span>
        <span class="keyword">return</span> p1.getKey().equals(p2.getKey()) &amp;&amp;
               p1.getValue().equals(p2.getValue());
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{

    <span class="keyword">private</span> K key;
    <span class="keyword">private</span> V value;

    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K key, V value)</span> </span>{
        <span class="keyword">this</span>.key = key;
        <span class="keyword">this</span>.value = value;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span> </span>{ <span class="keyword">this</span>.key = key; }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>{ <span class="keyword">this</span>.value = value; }
    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span>   </span>{ <span class="keyword">return</span> key; }
    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>{ <span class="keyword">return</span> value; }
}
</code></pre><p>调用上述静态泛型方法的正确语法如下：</p>
<pre><code><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, <span class="built_in">String</span><span class="subst">&gt;</span> p1 <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;&gt;</span>(<span class="number">1</span>, <span class="string">"apple"</span>);
<span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, <span class="built_in">String</span><span class="subst">&gt;</span> p2 <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;&gt;</span>(<span class="number">2</span>, <span class="string">"pear"</span>);
<span class="built_in">boolean</span> same <span class="subst">=</span> Util<span class="built_in">.</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, <span class="built_in">String</span><span class="subst">&gt;</span>compare(p1, p2);  <span class="comment">//在.和方法名之间加入&lt;&gt;</span>
</code></pre><p>一般情况下，编译器会做<a href="#type-inference">类型推断</a>，调用泛型方法时可以不写全。</p>
<pre><code><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, <span class="built_in">String</span><span class="subst">&gt;</span> p1 <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;&gt;</span>(<span class="number">1</span>, <span class="string">"apple"</span>);
<span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, <span class="built_in">String</span><span class="subst">&gt;</span> p2 <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;&gt;</span>(<span class="number">2</span>, <span class="string">"pear"</span>);
<span class="built_in">boolean</span> same <span class="subst">=</span> Util<span class="built_in">.</span>compare(p1, p2);
</code></pre><h2 id="有界类型参数（Bounded_Type_Parameters）">有界类型参数（Bounded Type Parameters）</h2><p>在有些时候，我们想限制类型参数的范围，比如针对Numbers的泛型方法，想限制直接收Numbers和它的所有子类型。这就需要限定泛型参数的界限。<br>在声明类型参数的时候，可以使用<em>extends XXX</em>（对类和接口来说都应该使用该关键字）限定类型参数的上限是XXX。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>{

    <span class="keyword">private</span> T t;          

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">set</span>(T t) {
        <span class="keyword">this</span>.t = t;
    }

    <span class="keyword">public</span> T <span class="keyword">get</span>() {
        <span class="keyword">return</span> t;
    }

    <span class="keyword">public</span> &lt;U <span class="keyword">extends</span> Number&gt; <span class="keyword">void</span> inspect(U u){
        System.out.println(<span class="string">"T: "</span> + t.getClass().getName());
        System.out.println(<span class="string">"U: "</span> + u.getClass().getName());
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();
        integerBox.<span class="keyword">set</span>(<span class="keyword">new</span> Integer(<span class="number">10</span>));
        integerBox.inspect(<span class="string">"some text"</span>); <span class="comment">// error: this is still String!</span>
    }
}
</code></pre><p>编译器会提示如下的编译错误：</p>
<pre><code>Box.java:21: &lt;<span class="keyword">U</span>&gt;<span class="keyword">inspect</span>(<span class="keyword">U</span>) <span class="keyword">in</span> Box&lt;java.lang.Integer&gt; cannot
  be applied to (java.lang.String)
                        integerBox.<span class="keyword">inspect</span>(<span class="string">"some text"</span>);
                                  ^
1 <span class="keyword">error</span>
</code></pre><p>除了限定类型，你还可以实例化一个泛型类型。</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">NaturalNumber&lt;T</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Integer&gt;</span> {</span>

    <span class="keyword">private</span> <span class="type">T</span> n;

    public <span class="type">NaturalNumber</span>(<span class="type">T</span> n)  { <span class="keyword">this</span>.n = n; }

    public boolean isEven() {
        <span class="keyword">return</span> n.intValue() % <span class="number">2</span> == <span class="number">0</span>;
    }

    <span class="comment">// ...</span>
}
</code></pre><h3 id="多个界限（Multiple_Bounds）">多个界限（Multiple Bounds）</h3><p>一个类型参数可以有多个界限：</p>
<pre><code>&lt;T <span class="keyword">extends</span> B1 &amp; B2 &amp; B3&gt;
</code></pre><p>表示T的上界是B1或者B2或者B3，如果其中一个类型参数是类，则必须放在第一个：</p>
<pre><code><span class="type">Class</span> <span class="type">A</span> { <span class="comment">/* ... */</span> }
interface <span class="type">B</span> { <span class="comment">/* ... */</span> }
interface <span class="type">C</span> { <span class="comment">/* ... */</span> }
<span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="title">&lt;T</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">A</span> <span class="title">&amp;</span> <span class="title">B</span> <span class="title">&amp;</span> <span class="title">C&gt;</span> {</span> <span class="comment">/* ... */</span> }  <span class="comment">// OK</span>
<span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="title">&lt;T</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">B</span> <span class="title">&amp;</span> <span class="title">A</span> <span class="title">&amp;</span> <span class="title">C&gt;</span> {</span> <span class="comment">/* ... */</span> }  <span class="comment">// compile-time error</span>
</code></pre><h3 id="有界类型参数和泛型方法">有界类型参数和泛型方法</h3><pre><code><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">int</span> countGreaterThan(T[] anArray, T elem) {
    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
    <span class="keyword">for</span> (T e : anArray)
        <span class="keyword">if</span> (e &gt; elem)  <span class="comment">// compiler error</span>
            ++<span class="keyword">count</span>;
    <span class="keyword">return</span> <span class="keyword">count</span>;
}
</code></pre><p>上面的代码会产生编译错误，原因是&gt;运算符只能用于比较基本类型（Primitive Types）如：short, int, double, long, float, byte, 和 char。<br>解决这个问题，可以使用上界为<code>Comparable&lt;T&gt;</code>的类型参数：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> Comparable&lt;T&gt; {
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">compareTo</span>(T o);
}

<span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Comparable&lt;T&gt;&gt; <span class="keyword">int</span> countGreaterThan(T[] anArray, T elem) {
    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
    <span class="keyword">for</span> (T e : anArray)
        <span class="keyword">if</span> (e.<span class="keyword">compareTo</span>(elem) &gt; <span class="number">0</span>)
            ++<span class="keyword">count</span>;
    <span class="keyword">return</span> <span class="keyword">count</span>;
}
</code></pre><p><a id="g-i-s" href="#g-i-s"></a></p>
<h2 id="泛型、继承和子类型（Generics,_Inheritance,_and_Subtypes）">泛型、继承和子类型（Generics, Inheritance, and Subtypes）</h2><p>如果两个类型兼容，可以把一个类型的对象赋予另个一类型的引用。例如：</p>
<pre><code><span class="built_in">Object</span> someObject = <span class="keyword">new</span> <span class="built_in">Object</span>();
Integer someInteger = <span class="keyword">new</span> Integer(<span class="number">10</span>);
someObject = someInteger;   <span class="comment">// OK</span>
</code></pre><p>在面向对象术语中成为：<em>“Is-a”</em>关系。因为Integer类型也是一种Object类型。下面的代码也成立，因为Double和Integer都是Number：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(Number n)</span> </span>{ <span class="comment">/* ... */</span> }

someMethod(<span class="keyword">new</span> Integer(<span class="number">10</span>));   <span class="comment">// OK</span>
someMethod(<span class="keyword">new</span> Double(<span class="number">10.1</span>));   <span class="comment">// OK</span>
</code></pre><p>以上继承规则对于类型参数来说也是成立的，你可以想Box中添加任何和Number兼容的子类型：</p>
<pre><code>Box&lt;Number&gt; <span class="built_in">box</span> = <span class="keyword">new</span> Box&lt;Number&gt;();
<span class="built_in">box</span>.<span class="built_in">add</span>(<span class="keyword">new</span> Integer(<span class="number">10</span>));   <span class="comment">// OK</span>
<span class="built_in">box</span>.<span class="built_in">add</span>(<span class="keyword">new</span> Double(<span class="number">10.1</span>));  <span class="comment">// OK</span>
</code></pre><p>但是考虑如下的方法：</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">boxTest</span><span class="params">(Box&lt;Number&gt; n)</span> </span>{ <span class="comment">/* ... */</span> }
</code></pre><p>boxTest方法会接受什么类型的参数？如果传入<code>Box&lt;Integer&gt;</code>或者<code>Box&lt;Double&gt;</code>可以吗？答案是<em>不可以</em>，因为<strong><code>Box&lt;Integer&gt;</code>和<code>Box&lt;Double&gt;</code>不是<code>Box&lt;Number&gt;</code>的子类型</strong>！</p>
<p><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-05-19/1.png" alt="generic subtypes"></p>
<blockquote>
<p>注意：给定两个具体类型A和B（如：Integer和Double），无论A，B两个类有什么样的关系，<code>MyClass&lt;A&gt;</code> 和 <code>MyClass&lt;B&gt;</code> 两个类没有任何关系，他们唯一相同的父类就是Object。关于如何创建一个泛型类的子类型，参见<a href="#wildcards-and-subtyping">通配符和子类型</a></p>
</blockquote>
<h3 id="泛型类和子类型">泛型类和子类型</h3><p>你可以通过继承泛型类或者实现泛型接口来创建一个泛型类或者泛型接口的子类型（subtype）。以Java集合类为例：</p>
<p><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-05-19/2.png" alt="Collections hierarchy"></p>
<p>若自己实现一个PayloadList类：</p>
<pre><code><span class="class"><span class="keyword">interface</span> <span class="title">PayloadList</span>&lt;<span class="title">E</span>,<span class="title">P</span>&gt; <span class="keyword">extends</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>{
  <span class="keyword">void</span> setPayload(<span class="keyword">int</span> <span class="keyword">index</span>, P val);
  ...
}
</code></pre><p>以下类型实参的PayLoadList是ListString&gt;的子类型（subtype）：</p>
<pre><code>PayloadList&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt;
PayloadList&lt;<span class="built_in">String</span>,<span class="built_in">Integer</span>&gt;
PayloadList&lt;<span class="built_in">String</span>,<span class="built_in">Exception</span>&gt;
</code></pre><p>而任何<code>PayloadList&lt;XXX,...&gt;</code>都不是<code>List&lt;String&gt;</code>的子类型。</p>
<p><a id="type-inference" href="#type-inference"></a></p>
<h2 id="类型推断（Type_Inference）">类型推断（Type Inference）</h2><p>类型推断是Java编译器根据方法调用和相应的声明去推断类型实参的过程。类型推断算法往往取决于实参类型、赋值操作等号右边的类型或返回值类型。最后，类型推断算法会找到适合所有条件的最具体的类型作为推断结果。<br>例如，下面的例子，类型推断的结果是Serializable：</p>
<pre><code>static &lt;<span class="literal">T</span>&gt; <span class="literal">T</span> pick(<span class="literal">T</span> a1, <span class="literal">T</span> a2) { <span class="keyword">return</span> a2; }
Serializable s = pick(<span class="string">"d"</span>, new ArrayList&lt;String&gt;());
</code></pre><h3 id="泛型方法的类型推断">泛型方法的类型推断</h3><p><a href="#generic-methods">泛型方法</a>引入了类型推断，类型推断使你能够像调用普通方法那样调用泛型方法，如下代码所示：</p>
<pre><code><span class="keyword">public</span> class BoxDemo {

  <span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="keyword">void</span> addBox(U u, 
      java.util.List&lt;Box&lt;U&gt;&gt; boxes) {
    Box&lt;U&gt; <span class="built_in">box</span> = <span class="keyword">new</span> Box&lt;&gt;();
    <span class="built_in">box</span>.<span class="built_in">set</span>(u);
    boxes.<span class="built_in">add</span>(<span class="built_in">box</span>);
  }

  <span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="keyword">void</span> outputBoxes(java.util.List&lt;Box&lt;U&gt;&gt; boxes) {
    <span class="built_in">int</span> counter = <span class="number">0</span>;
    <span class="keyword">for</span> (Box&lt;U&gt; <span class="built_in">box</span>: boxes) {
      U boxContents = <span class="built_in">box</span>.<span class="built_in">get</span>();
      System.out.<span class="built_in">println</span>(<span class="string">"Box #"</span> + counter + <span class="string">" contains ["</span> +
             boxContents.toString() + <span class="string">"]"</span>);
      counter++;
    }
  }

  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {
    java.util.ArrayList&lt;Box&lt;Integer&gt;&gt; listOfIntegerBoxes =
      <span class="keyword">new</span> java.util.ArrayList&lt;&gt;();
    BoxDemo.&lt;Integer&gt;addBox(Integer.valueOf(<span class="number">10</span>), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(<span class="number">20</span>), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(<span class="number">30</span>), listOfIntegerBoxes);
    BoxDemo.outputBoxes(listOfIntegerBoxes);
  }
}
</code></pre><p>代码输出：</p>
<pre><code><span class="tag">Box</span> <span class="id">#0</span> <span class="tag">contains</span> <span class="attr_selector">[10]</span>
<span class="tag">Box</span> <span class="id">#1</span> <span class="tag">contains</span> <span class="attr_selector">[20]</span>
<span class="tag">Box</span> <span class="id">#2</span> <span class="tag">contains</span> <span class="attr_selector">[30]</span>
</code></pre><p>泛型方法<em>addBox</em>定义了类型形参U，通常Java编译器可以通过方法调用推断类型实参，所以在多数情况下，不需要指定类型实参。例如调用方法addBox时，可以像这样指定类型实参：</p>
<pre><code>BoxDemo.&lt;<span class="type">Integer</span>&gt;addBox(<span class="type">Integer</span>.valueOf(<span class="number">10</span>), listOfIntegerBoxes);
</code></pre><p>也可以不指定，由编译器根据参数类型推断类型实参为Integer：</p>
<pre><code>BoxDemo.addBox(<span class="type">Integer</span>.valueOf(<span class="number">20</span>), listOfIntegerBoxes);
</code></pre><h3 id="构造方法的类型推断">构造方法的类型推断</h3><p>如果编译器可以根据上下文推断类型实参，则可以在调用构造方法时省略类型实参，例如：</p>
<pre><code><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; myMap = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt;();
</code></pre><p>也可以写成这样：</p>
<pre><code><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; myMap = <span class="keyword">new</span> HashMap&lt;&gt;();
</code></pre><p>但是为了能够使编译器进行类型推断，调用构造方法的时候必须使用<a href="#the-diamond">the diamond</a>，否则编译器报编译警告：</p>
<pre><code><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; myMap = <span class="keyword">new</span> HashMap(); <span class="comment">// unchecked conversion warning</span>
</code></pre><p>原因是HashMap()构造方法是HashMap<string, list<string="">&gt;的原始类型（<a href="#raw-types">raw types</a>）</string,></p>
<blockquote>
<p>无论在泛型类还是在非泛型类中，都可以存在泛型构造方法：</p>
</blockquote>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="inheritance">&lt;<span class="parent">X</span></span>&gt; {</span>
  &lt;<span class="constant">T</span>&gt; <span class="constant">MyClass</span>(<span class="constant">T</span> t) {
    <span class="regexp">//</span> ...
  }
}
</code></pre><p>初始化MyClass实例：</p>
<pre><code><span class="keyword">new</span> <span class="keyword">MyClass</span>&lt;<span class="built_in">Integer</span>&gt;(<span class="string">""</span>)
</code></pre><p>上面的语句创建了<code>MyClass&lt;Integer&gt;</code>的对象，显式的指明泛型类<code>MyClass&lt;X&gt;</code>的类型实参是Integer。但是MyClass的构造方法包含类型形参T并没有被显式的赋值。编译器通过传入构造方法的String类型的参数推断类型参数T的实参是String类型。<br>在Java SE 7 之前的版本，编译器已经具备推断泛型构造方法类型实参的能力，Java SE 7及之后的版本，编译器可以推断泛型类的类型实参（必须使用<a href="#the-diamond">the diamond</a>）</p>
<pre><code><span class="keyword">MyClass</span>&lt;<span class="built_in">Integer</span>&gt; myObject = <span class="keyword">new</span> <span class="keyword">MyClass</span>&lt;&gt;(<span class="string">""</span>);
</code></pre><p>上面的语句，编译器既可以推断出泛型类的类型实参，也可以推断出泛型构造方法的类型实参。</p>
<blockquote>
<p>注意：类型推断算法只使用<em>调用参数</em>、<em>目标类型</em>和<em>明显知道类型的返回值</em>来推断类型实参，推断算法不会使用当前程序之后的程序段对类型做推断。</p>
</blockquote>
<h3 id="目标类型">目标类型</h3><p>Java编译器利用目标类型推断泛型方法调用时的参数类型。表达式的目标类型是Java编译器根据表达式出现的位置，<strong>期望的表达式的类型</strong>。例如：有Collections.emptyList()方法的声明如下：</p>
<pre><code>static <span class="tag">&lt;<span class="title">T</span>&gt;</span> List<span class="tag">&lt;<span class="title">T</span>&gt;</span> emptyList();
</code></pre><p>若有以下的赋值语句：</p>
<pre><code><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; listOne = Collections.emptyList();
</code></pre><p>则期望的结果类型是<code>List&lt;String&gt;</code>；此类型即为目标类型。因为方法emptyList返回一个<code>List&lt;T&gt;</code>类型的值，编译器推断类型形参T一定是String。此机制Java SE 7 和 Java SE 8 都适用当然你也可以显示的指定泛型方法的类型参数：</p>
<pre><code><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; listOne = Collections.&lt;<span class="built_in">String</span>&gt;emptyList();
</code></pre><p>当然，这在上下文语境中并<strong>不是必须的</strong>。但在下面的情况下：</p>
<pre><code><span class="keyword">void</span> processStringList(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; stringList) {
    <span class="comment">// process stringList</span>
}
</code></pre><p>将设你想调用方法processStringList，传入一个空list，在Java SE 7中，下面的语句会出现编译错误：</p>
<pre><code>processStringList<span class="list">(<span class="keyword">Collections</span>.emptyList<span class="list">()</span>)</span><span class="comment">;</span>
</code></pre><p>错误大致是：</p>
<pre><code><span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; cannot be converted to <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;
</code></pre><p>编译器需要类型实参T，所以被默认当成<code>List&lt;Object&gt;</code>，进而emptyList方法返回<code>List&lt;Object&gt;</code>类型的结果，和processStringList方法的参数类型不兼容。因此，在Java SE 7中，必须指定类型参数的值的值：</p>
<pre><code>processStringList<span class="list">(<span class="keyword">Collections</span>.&lt;String&gt;emptyList<span class="list">()</span>)</span><span class="comment">;</span>
</code></pre><p>这种情况在Java SE 8中将不复存在，在Java SE 8中，<em>目标类型</em>的范围被扩展到包括方法参数。即可以通过形参的类型参数推断返回值的类型参数。<br>因为形参是<code>List&lt;String&gt;</code>,Collections.emptyList返回<code>List&lt;T&gt;</code>类型的结果，<code>List&lt;String&gt;</code>被作为目标类型，编译器推断T为String类型。因此，下面的语句在Java SE 8中可以编译通过：</p>
<pre><code>processStringList<span class="list">(<span class="keyword">Collections</span>.emptyList<span class="list">()</span>)</span><span class="comment">;</span>
</code></pre><h2 id="通配符（Wildcard）">通配符（Wildcard）</h2><p>泛型编程中，把问号（?）称为<em>通配符</em>，表示未知类型。通配符在很多情况下会用到：类型参数、属性、局部变量，甚至是返回类型（尽管明确的返回值类型才是好的编程习惯）。但<em>绝不会用于</em>：泛型方法调用的类型实参、泛型类实例化、超类型（supertype）。</p>
<h3 id="有上界的通配符">有上界的通配符</h3><p>你可以通过上界通配符减轻泛型对变量类型的限制。例如，你希望一个泛型方法同时能处理<code>List&lt;Integer&gt;</code>, <code>List&lt;Double&gt;</code> 和 <code>List&lt;Number&gt;</code>，你可以使用上界通配符。<br>应使用<em>?</em>和<em>extends</em>关键字（无论接口还是类），例如<code>List&lt;? extends Number&gt;</code>。 <code>List&lt;Number&gt;</code> 比<code>List&lt;? extends Number&gt;</code>的限制更严格。因为前者的匹配类型只有Number类型，而后者任何Number和Number的子类型都适用。<br>下面的process方法可以处理类型是任何Foo类或者Foo类的子类型。</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;? extends Foo&gt; <span class="built_in">list</span>)</span> </span>{
    <span class="keyword">for</span> (Foo elem : <span class="built_in">list</span>) {
        <span class="comment">// ...</span>
    }
}
</code></pre><p>下面的sumOfList方法, <code>List&lt;Integer&gt;</code> 和 <code>List&lt;Double&gt;</code>都适用：</p>
<pre><code>public static double sumOfList(<span class="keyword">List</span>&lt;? extends Number&gt; <span class="keyword">list</span>) {
    double s = 0.0;
    <span class="keyword">for</span> (Number <span class="keyword">n</span> : <span class="keyword">list</span>)
        s += <span class="keyword">n</span>.doubleValue();
    <span class="keyword">return</span> s;
}

<span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">li</span> = Arrays.asList(1, 2, 3);
System.<span class="keyword">out</span>.println(<span class="string">"sum = "</span> + sumOfList(<span class="keyword">li</span>));

<span class="keyword">List</span>&lt;Double&gt; ld = Arrays.asList(1.2, 2.3, 3.5);
System.<span class="keyword">out</span>.println(<span class="string">"sum = "</span> + sumOfList(ld));
</code></pre><h3 id="无界通配符">无界通配符</h3><p>无界通配符用一个单独的<em>?</em>表示，例如<code>List&lt;?&gt;</code>表示未知类型的List，一般无界通配符用于以下两个场景：</p>
<ul>
<li>如果你正在写可以使用Object类提供的功能来实现的方法。</li>
<li>当使用泛型类中的不依赖于类型参数的方法时，例如List.size和List.clear. <code>Class&lt;?&gt;</code>经常被使用，因为<code>Class&lt;T&gt;</code>类中的大部分方法和类型参数T无关。</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> printList(List&lt;<span class="keyword">Object</span>&gt; list) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">Object</span> elem : list)</span><br><span class="line">        System.out.<span class="built_in">println</span>(elem + <span class="string">" "</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上面的printList目的是打印任何类型的对象列表的话，是实现不了的。原因是<code>List&lt;Integer&gt;</code>, <code>List&lt;String&gt;</code>, <code>List&lt;Double&gt;</code>等都不是<code>List&lt;Object&gt;</code>的子类型。如果需要打印任何类型的对象，需要使用通配符：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> void printList(<span class="keyword">List</span><span class="preprocessor">&lt;?</span>&gt; <span class="keyword">list</span>) {
    <span class="keyword">for</span> (Object elem: <span class="keyword">list</span>)
        System.out.<span class="keyword">print</span>(elem + <span class="string">" "</span>);
    System.out.println();
}
</code></pre><p>因为对于任意的具体类型T来说，<code>List&lt;T&gt;</code>是<code>List&lt;?&gt;</code>的子类型，你可以使用printList方法打印任意类型的对象列表。</p>
<pre><code><span class="keyword">List</span>&lt;<span class="keyword">Integer</span>&gt; li = <span class="keyword">Arrays</span>.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);
<span class="keyword">List</span>&lt;<span class="keyword">String</span>&gt;  ls = <span class="keyword">Arrays</span>.asList(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>);
printList(li);
printList(ls);
</code></pre><blockquote>
<p>需要注意<code>List&lt;Object&gt;</code> 和 <code>List&lt;?&gt;</code>是不同的，你可以向<code>List&lt;Object&gt;</code>中插入任何Object的子类型的对象，但是你只能向<code>List&lt;?&gt;</code>中插入null。更多关于通配符应该在什么情况下使用，请参见<a href="#wildcards-guideline">通配符使用指南</a></p>
</blockquote>
<h3 id="有下界的通配符">有下界的通配符</h3><p>和有上界的通配符相反，有下界的通配符使用<code>&lt;? super A&gt;</code> 表示通配符的下界是A。</p>
<blockquote>
<p>注意，你可以指定上界，也可以指定下界，但是不同同时指定两者。</p>
</blockquote>
<p>如果你想要一个方法能够处理Integer类型以及所有Integer类型的父类，则可以使用有下界的通配符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNumbers</span><span class="params">(List&lt;? super Integer&gt; <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a id="wildcards-and-subtyping" href="#wildcards-and-subtyping"></a></p>
<h3 id="通配符和子类型">通配符和子类型</h3><p>在<a href="#g-i-s">泛型、继承和子类型</a>一节，我们曾经说过，仅仅类型参数有继承关系的泛型类或者泛型接口之间没有任何继承关系。但是你可以通过通配符建立泛型类和接口之间的继承关系。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">A</span> &#123;</span> <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>则你可以这样写代码：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B b = new B()<span class="comment">;</span></span><br><span class="line"><span class="literal">A</span> <span class="literal">a</span> = b<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>对于普通的类来说，子类型规则是成立的：如果B继承A，那么B是A的子类型。但是这个规则对于泛型类型来说，不适用。</p>
<p>Integer是Number类的子类，<code>List&lt;Integer&gt;</code>和<code>List&lt;Number&gt;</code>是什么关系？</p>
<p><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-05-19/3.png" alt="subtype"></p>
<p>尽管Integer是Number的子类型，但是<code>List&lt;Integer&gt;</code>和<code>List&lt;Number&gt;</code>并没有继承关系。它们之间仅有的关系就是共同的父类是<code>List&lt;?&gt;</code>.<br>下图说明了有上下界通配符的泛型类之间的继承关系：</p>
<p><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-05-19/4.png" alt="subtype-wildcard"></p>
<p>在<a href="#wildcards-guidline">通配符使用指南</a>一节，将介绍更多关于上下界通配符的使用方法。</p>
<h3 id="通配符捕获和辅助方法">通配符捕获和辅助方法</h3><p>在某些情况下，编译器会推断通配符的类型。例如，一个列表被定义为<code>List&lt;?&gt;</code>，当计算表达式的值的时候，编译器会根据代码推断出特定的类型。这种场景就叫做<em>通配符捕获（Wildcard Capture）</em>。<br>在大部分情况下，你都不需要关注通配符捕获，除非你得到包含<em>capture of</em>的错误提示。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.util.List;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardError</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> foo(List&lt;?&gt; i) &#123;</span><br><span class="line">        i.<span class="keyword">set</span>(<span class="number">0</span>, i.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，编译器处理输入参数i时，把它的类型参数当成Object，当触发<code>List.set(int,E)</code>时，编译器无法确定set进list中的对象类型，从而报错。当有类型错误提示的时候，往往是编译器认为你对变量设置了错误的类型。添加泛型，正是为了解决编译期类型检查。<br>例如使用JDK 7编译上面的代码的时候，会提示如下的错误：</p>
<pre><code>WildcardError.java:<span class="number">6</span>: error: <span class="function"><span class="keyword">method</span> <span class="title">set</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="title">cannot</span> <span class="title">be</span> <span class="title">applied</span> <span class="title">to</span> <span class="title">given</span> <span class="title">types</span>;</span>
    i.<span class="keyword">set</span>(<span class="number">0</span>, i.get(<span class="number">0</span>));
     ^
  required: int,CAP<span class="string">#1</span>
  found: int,Object
  reason: actual argument Object cannot be converted <span class="keyword">to</span> CAP<span class="string">#1</span> <span class="keyword">by</span> <span class="function"><span class="keyword">method</span> <span class="title">invocation</span> <span class="title">conversion</span>
  <span class="title">where</span> <span class="title">E</span> <span class="title">is</span> <span class="title">a</span> <span class="title">type</span>-<span class="title">variable</span>:</span>
    E extends Object declared <span class="keyword">in</span> <span class="keyword">interface</span> List
  <span class="keyword">where</span> CAP<span class="string">#1</span> <span class="keyword">is</span> a fresh <span class="keyword">type</span>-variable:
    CAP<span class="string">#1</span> extends Object <span class="keyword">from</span> capture <span class="keyword">of</span> ?
<span class="number">1</span> error
</code></pre><p>你可以写一个私有的辅助方法来解决上面的错误：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WildcardFixed</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(List&lt;?&gt; i)</span> </span>&#123;</span><br><span class="line">        fooHelper(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helper method created so that the wildcard can be captured</span></span><br><span class="line">    <span class="comment">// through type inference.</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fooHelper</span><span class="params">(List&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        l.<span class="keyword">set</span>(<span class="number">0</span>, l.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>辅助方法使编译器能够通过类型推断，得到T的类型是<code>CAP#1</code>。辅助方法惯例命名方式<code>originalMethodNameHelper</code>。<br>再看一个稍微复杂的例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">import</span> java.util.<span class="built_in">List</span>;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">WildcardErrorBad</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> swapFirst(<span class="built_in">List</span>&lt;? <span class="keyword">extends</span> Number&gt; l1, <span class="built_in">List</span>&lt;? <span class="keyword">extends</span> Number&gt; l2) &#123;</span><br><span class="line">      Number temp = l1.<span class="literal">get</span>(<span class="number">0</span>);</span><br><span class="line">      l1.<span class="literal">set</span>(<span class="number">0</span>, l2.<span class="literal">get</span>(<span class="number">0</span>)); <span class="comment">// expected a CAP#1 extends Number,</span></span><br><span class="line">                            <span class="comment">// got a CAP#2 extends Number;</span></span><br><span class="line">                            <span class="comment">// same bound, but different types</span></span><br><span class="line">      l2.<span class="literal">set</span>(<span class="number">0</span>, temp);	    <span class="comment">// expected a CAP#1 extends Number,</span></span><br><span class="line">                            <span class="comment">// got a Number</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子尝试不安全的操作，例如用下面的方式调用<code>swapFirst</code>方法：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">List</span>&lt;<span class="keyword">Integer</span>&gt; li = <span class="keyword">Arrays</span>.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">List</span>&lt;Double&gt;  ld = <span class="keyword">Arrays</span>.asList(<span class="number">10.10</span>, <span class="number">20.20</span>, <span class="number">30.30</span>);</span><br><span class="line">swapFirst(li, ld);</span><br></pre></td></tr></table></figure>
<p>尽管<code>List&lt;Integer&gt;</code>和<code>List&lt;Double&gt;</code>都满足<code>List&lt;? extends Number&gt;</code>的类型限制，但试图把Integer列表中的元素放入Double类型的列表中肯定是错误的。<br>JDk javac程序编译以上代码会报类似下面的错误：</p>
<pre><code>WildcardErrorBad.java:<span class="number">7</span>: error: <span class="function"><span class="keyword">method</span> <span class="title">set</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="title">cannot</span> <span class="title">be</span> <span class="title">applied</span> <span class="title">to</span> <span class="title">given</span> <span class="title">types</span>;</span>
      l1.<span class="keyword">set</span>(<span class="number">0</span>, l2.get(<span class="number">0</span>)); <span class="comment">// expected a CAP#1 extends Number,</span>
        ^
  required: int,CAP<span class="string">#1</span>
  found: int,Number
  reason: actual argument Number cannot be converted <span class="keyword">to</span> CAP<span class="string">#1</span> <span class="keyword">by</span> <span class="function"><span class="keyword">method</span> <span class="title">invocation</span> <span class="title">conversion</span>
  <span class="title">where</span> <span class="title">E</span> <span class="title">is</span> <span class="title">a</span> <span class="title">type</span>-<span class="title">variable</span>:</span>
    E extends Object declared <span class="keyword">in</span> <span class="keyword">interface</span> List
  <span class="keyword">where</span> CAP<span class="string">#1</span> <span class="keyword">is</span> a fresh <span class="keyword">type</span>-variable:
    CAP<span class="string">#1</span> extends Number <span class="keyword">from</span> capture <span class="keyword">of</span> ? extends Number
WildcardErrorBad.java:<span class="number">10</span>: error: <span class="function"><span class="keyword">method</span> <span class="title">set</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="title">cannot</span> <span class="title">be</span> <span class="title">applied</span> <span class="title">to</span> <span class="title">given</span> <span class="title">types</span>;</span>
      l2.<span class="keyword">set</span>(<span class="number">0</span>, temp);      <span class="comment">// expected a CAP#1 extends Number,</span>
        ^
  required: int,CAP<span class="string">#1</span>
  found: int,Number
  reason: actual argument Number cannot be converted <span class="keyword">to</span> CAP<span class="string">#1</span> <span class="keyword">by</span> <span class="function"><span class="keyword">method</span> <span class="title">invocation</span> <span class="title">conversion</span>
  <span class="title">where</span> <span class="title">E</span> <span class="title">is</span> <span class="title">a</span> <span class="title">type</span>-<span class="title">variable</span>:</span>
    E extends Object declared <span class="keyword">in</span> <span class="keyword">interface</span> List
  <span class="keyword">where</span> CAP<span class="string">#1</span> <span class="keyword">is</span> a fresh <span class="keyword">type</span>-variable:
    CAP<span class="string">#1</span> extends Number <span class="keyword">from</span> capture <span class="keyword">of</span> ? extends Number
WildcardErrorBad.java:<span class="number">15</span>: error: <span class="function"><span class="keyword">method</span> <span class="title">set</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="title">cannot</span> <span class="title">be</span> <span class="title">applied</span> <span class="title">to</span> <span class="title">given</span> <span class="title">types</span>;</span>
        i.<span class="keyword">set</span>(<span class="number">0</span>, i.get(<span class="number">0</span>));
         ^
  required: int,CAP<span class="string">#1</span>
  found: int,Object
  reason: actual argument Object cannot be converted <span class="keyword">to</span> CAP<span class="string">#1</span> <span class="keyword">by</span> <span class="function"><span class="keyword">method</span> <span class="title">invocation</span> <span class="title">conversion</span>
  <span class="title">where</span> <span class="title">E</span> <span class="title">is</span> <span class="title">a</span> <span class="title">type</span>-<span class="title">variable</span>:</span>
    E extends Object declared <span class="keyword">in</span> <span class="keyword">interface</span> List
  <span class="keyword">where</span> CAP<span class="string">#1</span> <span class="keyword">is</span> a fresh <span class="keyword">type</span>-variable:
    CAP<span class="string">#1</span> extends Object <span class="keyword">from</span> capture <span class="keyword">of</span> ?
<span class="number">3</span> errors
</code></pre><p>没有辅助方法能够解决上面的问题，因为代码压根是错误的。</p>
<p><a id="wildcards-guideline" href="#wildcards-guideline"></a></p>
<h3 id="通配符使用指南">通配符使用指南</h3><p>使用带上下界的通配符是Java泛型中最容易让人产生迷惑的地方，这一节将提供一些代码设计上的指南。<br>为了方便后续讨论，读者应该理解一个变量有如下的两个功能：</p>
<ul>
<li><strong>传入参数（An “In” Variable）：</strong> 传入参数在代码中往往作为数据使用，例如<code>copy(src,dest)</code>函数有两个参数，src作为被拷贝的对象，是传入变量，习惯上叫做<em>入参</em>。</li>
<li><strong>传出参数（An “Out” Variable)：</strong> 传出参数在代码中往往作为结果使用，例如<code>copy(src,dest)</code>函数中的dest就是传出参数，习惯上称为<em>传出参数</em>。</li>
</ul>
<p>当然有些变量既被用做传入变量又被用作传出变量，这种情况在这一小节中也有讨论。<br>你可以结合<em>in</em>和<em>out</em>的原则，用下面列表中的tips作为决定使用哪种泛型通配符的依据：</p>
<blockquote>
<p><strong>通配符使用指南</strong></p>
<ul>
<li>传入参数用上界通配符extends关键字</li>
<li>传出参数用下界通配符super关键字</li>
<li>传入参数在代码中可被当做Object对象访问时，使用无界通配符</li>
<li>既是传入参数又是传出参数时，不要使用通配符</li>
</ul>
<p>注：上面的这些规则不适用与方法的返回类型，应该避免在返回值中使用通配符，因为这样强迫方法使用者去写额外的代码处理通配符。</p>
</blockquote>
<p>如果列表定义为<code>List&lt;? extends ...&gt;</code>则非正规的定义了一个只读的列表，但不严格保证列表是只读的。<br>假设有如下的两个类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaturalNumber</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> int i;</span><br><span class="line"></span><br><span class="line">    public <span class="type">NaturalNumber</span>(int i) &#123; <span class="keyword">this</span>.i = i; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvenNumber</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">NaturalNumber</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    public <span class="type">EvenNumber</span>(int i) &#123; <span class="keyword">super</span>(i); &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码会产生编译错误：：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;EvenNumber&gt; <span class="keyword">le</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;? extends NaturalNumber&gt; <span class="keyword">ln</span> = <span class="keyword">le</span>;</span><br><span class="line"><span class="keyword">ln</span>.<span class="built_in">add</span>(<span class="keyword">new</span> NaturalNumber(<span class="number">35</span>));  // compile-time error</span><br></pre></td></tr></table></figure>
<p>因为<code>List&lt;EvenNumber&gt;</code>是<code>List&lt;? extends NaturalNumber&gt;</code>的子类型，你可以把le赋值给ln，但是你不能向<code>EvenNumber</code>列表中添加<code>NaturalNumber</code>。你可以对<code>List&lt;? extends ...&gt;</code>列表做如下的操作：</p>
<ul>
<li>add null</li>
<li>调用 <code>clear()</code></li>
<li>得到列表的Iterator并调用<code>remove()</code>方法</li>
<li>捕获通配符类型并把从列表读取的元素添加到列表</li>
</ul>
<p>可以看到含有通配符的列表并非是只读的，但你无法添加新的非空元素，也无法改变已有元素。</p>
<p><a id="type-erasure" href="#type-inference"></a></p>
<h2 id="类型擦除（Type_Erasure）">类型擦除（Type Erasure）</h2><p>Java语言通过引入泛型来提供更严格的编译期类型检查，为了实现泛型，Java编译器应用类型擦除：</p>
<ul>
<li>将所有类型参数替换为通配符的界限或Object（如果无界限），产生的字节码只包含普通的那个的类、接口和方法。</li>
<li>如果需要保证类型安全，还需要插入类型转换。</li>
<li>生成桥接方法来保持泛型类型的多态性。</li>
</ul>
<p>类型擦除确保了没有任何新的类型创建，从而不会造成任何运行时的开销。</p>
<h3 id="泛型类的类型擦除">泛型类的类型擦除</h3><p>在类型擦除过程中，Java编译器将删除所有类型参数，并替换类型参数为他的界限，如果没有界限，将替换为Object。<br>例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node(T data, Node&lt;T&gt; <span class="keyword">next</span>) &#125;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T getData() &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为类型参数没有界限，编译器将类型参数替换为Object。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Node &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node(Object data, Node <span class="keyword">next</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object getData() &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类型参数有界限：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Node&lt;T</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Comparable&lt;T&gt;&gt;</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">T</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span>&lt;<span class="type">T</span>&gt; next;</span><br><span class="line"></span><br><span class="line">    public <span class="type">Node</span>(<span class="type">T</span> data, <span class="type">Node</span>&lt;<span class="type">T</span>&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">T</span> getData() &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java编译器把有界限的类型参数<code>T</code>替换为第一个有界类型<code>Comparable</code>：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Node &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Comparable data;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node(Comparable data, Node <span class="keyword">next</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Comparable getData() &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法的类型擦除">泛型方法的类型擦除</h3><p>Java编译器也会擦除泛型方法实参中的类型参数：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counts the number of occurrences of elem in anArray.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(T[] anArray, T elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T e : anArray)</span><br><span class="line">        <span class="keyword">if</span> (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>T</code>没有界限限制，所以类型参数会被替换为<code>Object</code>：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(Object[] anArray, Object elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object e : anArray)</span><br><span class="line">        <span class="keyword">if</span> (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如下面的三个类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span> <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Shape</span> &#123;</span> <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Shape</span> &#123;</span> <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>你可以写一个泛型方法来画出不同的图形：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Shape&gt; <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(T shape)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>Java编译器将<code>T</code>替换为Shape：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw</span>(Shape <span class="built_in">shape</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型擦除和桥接方法的影响">类型擦除和桥接方法的影响</h3><p>有的时候类型擦除会引发预料不到的情况，在下面的<a href="#bridge-methods">桥接方法</a>展示了编译器在某些时候会创建合成方法（<em>桥接方法</em>）。桥接方法是类型擦除处理过程的一部分。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Node&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="type">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node(T <span class="type">data</span>) &#123; this.<span class="type">data</span> = <span class="type">data</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setData(T <span class="type">data</span>) &#123;</span><br><span class="line">        System.<span class="type">out</span>.println(<span class="string">"Node.setData"</span>);</span><br><span class="line">        this.<span class="type">data</span> = <span class="type">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyNode <span class="keyword">extends</span> Node&lt;<span class="type">Integer</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> MyNode(<span class="type">Integer</span> <span class="type">data</span>) &#123; super(<span class="type">data</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setData(<span class="type">Integer</span> <span class="type">data</span>) &#123;</span><br><span class="line">        System.<span class="type">out</span>.println(<span class="string">"MyNode.setData"</span>);</span><br><span class="line">        super.setData(<span class="type">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn <span class="subst">=</span> <span class="literal">new</span> MyNode(<span class="number">5</span>);</span><br><span class="line">Node n <span class="subst">=</span> mn;            <span class="comment">// A raw type - compiler throws an unchecked warning</span></span><br><span class="line">n<span class="built_in">.</span>setData(<span class="string">"Hello"</span>);     </span><br><span class="line"><span class="built_in">Integer</span> x <span class="subst">=</span> mn<span class="built_in">.</span><span class="built_in">data</span>;    <span class="comment">// Causes a ClassCastException to be thrown.</span></span><br></pre></td></tr></table></figure>
<p>类型擦除之后，上面的代码变为：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn <span class="subst">=</span> <span class="literal">new</span> MyNode(<span class="number">5</span>);</span><br><span class="line">Node n <span class="subst">=</span> (MyNode)mn;         <span class="comment">// A raw type - compiler throws an unchecked warning</span></span><br><span class="line">n<span class="built_in">.</span>setData(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="built_in">Integer</span> x <span class="subst">=</span> (<span class="built_in">String</span>)mn<span class="built_in">.</span><span class="built_in">data</span>; <span class="comment">// Causes a ClassCastException to be thrown.</span></span><br></pre></td></tr></table></figure>
<p>当代码运行时：</p>
<ul>
<li><code>n.setData(&quot;Hello&quot;);</code> 实际上调用了MyNode对象的<code>setData(Object)</code>方法（<code>MyNode</code>继承了<code>Node</code>的<code>setData(Object)</code>方法）</li>
<li>引用<code>n</code>指向的对象的成员变量data被赋予<code>String</code>类型的值</li>
<li>引用<code>mn</code>指向的相同的对象的成员预期是Integer类型</li>
<li>试图将String类型的值赋给Integer类型，抛出<code>ClassCastException</code>异常</li>
</ul>
<p><a id="bridge-methods" href="#bridge-methods"></a></p>
<h3 id="桥接方法（Bridge_Methods）">桥接方法（Bridge Methods）</h3><p>当一个类继承自有类型参数的类或实现有类型参数的接口时，编译器在编译它时一般需要生成桥接方法，作为类型擦除处理的一部分。一般你不需要担心桥接方法，但是如果它出现在堆栈跟踪中，会使人感到迷惑。<br>类型擦除过后，<code>Node</code>类和<code>MyNode</code>类如下所示：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Node &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="type">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node(Object <span class="type">data</span>) &#123; this.<span class="type">data</span> = <span class="type">data</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setData(Object <span class="type">data</span>) &#123;</span><br><span class="line">        System.<span class="type">out</span>.println(<span class="string">"Node.setData"</span>);</span><br><span class="line">        this.<span class="type">data</span> = <span class="type">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyNode <span class="keyword">extends</span> Node &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyNode(<span class="type">Integer</span> <span class="type">data</span>) &#123; super(<span class="type">data</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setData(<span class="type">Integer</span> <span class="type">data</span>) &#123;</span><br><span class="line">        System.<span class="type">out</span>.println(<span class="string">"MyNode.setData"</span>);</span><br><span class="line">        super.setData(<span class="type">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见类型擦除之后，方法签名不再匹配，<code>Node</code>中<code>setData(Object)</code>方法在<code>MyNode</code>中变成<code>setData(Integer)</code>，这样子类的方法不再覆盖父类的方法。<br>为了解决这个问题，并且能够在类型擦除之后，仍然保持多态性，Java编译器生成一个桥接方法来保证子类型工作正常。对于<code>MyNode</code>类，编译器生成下面的桥接方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Node</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bridge method generated by the compiler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    public void setData(<span class="type">Object</span> data) &#123;</span><br><span class="line">        setData((<span class="type">Integer</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(<span class="type">Integer</span> data) &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"MyNode.setData"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>产生的桥接方法能够覆盖父类的<code>setData(Object data)</code>方法，并把真正的实现代理给了原有的<code>setData(Integer data)</code>方法。</p>
<h2 id="非具体化类型（Non-Reifiable_Types）">非具体化类型（Non-Reifiable Types）</h2><p>类型擦除还和具有非具体化类型的可变参数方法同时使用，会产生一些问题。本小节将详细介绍以下内容：</p>
<ul>
<li>非具体化类型</li>
<li>堆污染</li>
<li>可变参数方法与非具体化类型的潜在漏洞</li>
<li>防止非具体化类型的可变参数方法产生的警告</li>
</ul>
<h3 id="非具体化类型（Non-Reifiable_Types）-1">非具体化类型（Non-Reifiable Types）</h3><p>具体化类型（Reifiable types）是在在运行时可以得到其全部类型信息的类型。包括基本类型（primitives），非泛型类型，原始类型（raw types）和无界通配符的调用。<br>非具体化类型（Non-Reifiable Types）是类型信息在编译期间被类型擦除的类型——对没有定义为无界通配符的泛型类型的调用。非具体化类型的类型信息在运行时不是全部可见的。例如：<code>List&lt;String&gt;</code>和<code>List&lt;Numbuer&gt;</code>JVM在运行时不能区分这两种类型。正如在<a href="#restrictions-on-generics">泛型的限制</a>中描述的，有些机制在非具体化类型上不能使用，比如<code>instanceof</code>。</p>
<h3 id="堆污染（Heap_Pollution）">堆污染（Heap Pollution）</h3><p>当包含类型参数的引用指向一个并非这种类型的对象的时候，就会发生堆污染。一般在这种情形下，编译器在编译器会报未检查警告（unchecked warning）。当无论编译期类型检查还是运行时都无法验证一个包含类型参数的操作（类型转换或者方法调用）是否正确的时候，就会产生未检查警告。混用原始类型（raw types）和泛型参数或者执行未检查的类型转换时都会产生堆污染。<br>一般情况下，如果所有代码都同时编译，编译器利用未检查警告提醒你留意潜在的堆污染；如果不同部分的代码分开编译，则编译器很难检测到潜在的堆污染。<br>当然，如果你能确保代码没有任何未检查警告，则不可能发生堆污染。</p>
<h3 id="可变参数方法与非具体化类型的潜在漏洞（Potential_Vulnerabilities_of_Varargs_Methods_with_Non-Reifiable_Formal_Parameters）">可变参数方法与非具体化类型的潜在漏洞（Potential Vulnerabilities of Varargs Methods with Non-Reifiable Formal Parameters）</h3><p>泛型方法包含可变长度参数时可能造成堆污染。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArrayBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addToList</span> <span class="params">(List&lt;T&gt; listArg, T... elements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T x : elements) &#123;</span><br><span class="line">      listArg.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">faultyMethod</span><span class="params">(List&lt;String&gt;... l)</span> </span>&#123;</span><br><span class="line">    Object[] objectArray = l;     <span class="comment">// Valid</span></span><br><span class="line">    objectArray[<span class="number">0</span>] = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">    String s = l[<span class="number">0</span>].<span class="keyword">get</span>(<span class="number">0</span>);       <span class="comment">// ClassCastException thrown here</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HeapPollutionExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  public <span class="literal">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; stringListA = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; stringListB = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.addToList(stringListA, <span class="string">"Seven"</span>, <span class="string">"Eight"</span>, <span class="string">"Nine"</span>);</span><br><span class="line">    ArrayBuilder.addToList(stringListB, <span class="string">"Ten"</span>, <span class="string">"Eleven"</span>, <span class="string">"Twelve"</span>);</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt; listOfStringLists =</span><br><span class="line">      <span class="keyword">new</span> ArrayList&lt;<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;&gt;();</span><br><span class="line">    ArrayBuilder.addToList(listOfStringLists,</span><br><span class="line">      stringListA, stringListB);</span><br><span class="line"></span><br><span class="line">    ArrayBuilder.faultyMethod(Arrays.asList(<span class="string">"Hello!"</span>), Arrays.asList(<span class="string">"World!"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当编译上面代码的时候，编译器会产生关于<code>ArrayBuilder.addToList</code>方法的警告：</p>
<pre><code>warning: [varargs] Possible heap pollution from parameterized vararg <span class="class"><span class="keyword">type</span> <span class="title">T</span></span>
</code></pre><p>当遇到可变参数的方法时，编译器将可变参数转换成数组，但是Java不允许创建泛型数组（例如<code>new T[]</code>），在<code>ArrayBuilder.addToList</code>方法中，编译器将可变参数<code>T...</code>转换为<code>T[]</code>。但由于类型擦除，参数数组最终的类型是<code>Object[]</code>,因此可能会出现堆污染。</p>
<p>下面的语句将参数数组赋值给Object数组：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>[] objectArray = l;</span><br></pre></td></tr></table></figure>
<p>上面的语句会产生堆污染。参数数组可以赋值给Object类型的数组，但是此赋值语句编译器不会产生未检查警告，因为已经在将可变参数<code>List&lt;String&gt;... l</code>转换为<code>List[] l</code>的时候产生过警告。赋值语句是合法的，因为<code>List[]</code>是<code>Object[]</code>的子类型。</p>
<p>这样，当你把任何类型的列表赋值给<code>objectArray</code>数组中的元素的时候，编译器不会产生任何的错误或者警告，例如下面的语句：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">objectArray[0] </span>=<span class="string"> Arrays.asList(42);</span></span><br></pre></td></tr></table></figure>
<p>将<code>objectArray</code>数组中的第一个元素赋值为<code>List&lt;Integer&gt;</code>类型的值。</p>
<p>假设你用如下的方式调用<code>ArrayBuilder.faultyMethod</code>方法：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBuilder.faultyMethod(Arrays.<span class="keyword">asList</span>(<span class="string">"Hello!"</span>), Arrays.<span class="keyword">asList</span>(<span class="string">"World!"</span>));</span><br></pre></td></tr></table></figure>
<p>在运行时，JVM会抛出<code>ClassCastException</code>异常：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassCastException thrown here</span></span><br><span class="line"><span class="built_in">String</span> s = l[<span class="number">0</span>].<span class="literal">get</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>存储在<code>l</code>中是<code>List&lt;Integer&gt;</code>类型，但上面的语句期待的类型是<code>List&lt;String&gt;</code>。</p>
<h3 id="防止非具体化类型的可变参数方法产生的警告（Prevent_Warnings_from_Varargs_Methods_with_Non-Reifiable_Formal_Parameters）">防止非具体化类型的可变参数方法产生的警告（Prevent Warnings from Varargs Methods with Non-Reifiable Formal Parameters）</h3><p>如果你声明了一个参数化类型的可变参数的方法，并且可以确保该方法体不抛出ClassCastException或其他类似的异常，可以通过对方法增加如下注解来防止编译器警告：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SafeVarargs</span></span><br></pre></td></tr></table></figure>
<p><code>@SafeVarargs</code>注解声明在这个方法内部不会错误的处理可变参数实参的类型。</p>
<p>使用以下的方法注解也可以消除编译器关于参数化类型的可变参数的警告，虽然效果并不理想:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function"><span class="title">SuppressWarnings</span><span class="params">(&#123;<span class="string">"unchecked"</span>, <span class="string">"varargs"</span>&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>这种方式不能消除方法调用方的编译警告。</p>
<p><a id="restrictions-on-generics"><a></a></a></p>
<h2 id="泛型的限制（Restrictions_on_Generics）">泛型的限制（Restrictions on Generics）</h2><h3 id="无法用基本类型实例化泛型类型参数">无法用基本类型实例化泛型类型参数</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Pair&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K <span class="variable">key</span>;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pair(K <span class="variable">key</span>, V value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="variable">key</span> = <span class="variable">key</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们无法用基本类型去实例化类型实参：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">8</span>, <span class="string">'a'</span>);  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<p>只能通过对象类型实例化：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, Character<span class="subst">&gt;</span> p <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;&gt;</span>(<span class="number">8</span>, <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>
<p>Java自动装箱，相当于如下的实例化方式：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Pair</span><span class="subst">&lt;</span><span class="built_in">Integer</span>, Character<span class="subst">&gt;</span> p <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Pair</span><span class="subst">&lt;&gt;</span>(<span class="built_in">Integer</span><span class="built_in">.</span>valueOf(<span class="number">8</span>), <span class="literal">new</span> Character(<span class="string">'a'</span>));</span><br></pre></td></tr></table></figure>
<h3 id="不能创建类型参数的对象">不能创建类型参数的对象</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;<span class="keyword">E</span>&gt; void <span class="keyword">append</span>(<span class="keyword">List</span>&lt;<span class="keyword">E</span>&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">    <span class="keyword">E</span> elem = new <span class="literal">E</span>();  <span class="comment">// compile-time error</span></span><br><span class="line">    <span class="keyword">list</span>.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法是可以使用反射来创建类型参数的对象：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;<span class="keyword">E</span>&gt; void <span class="keyword">append</span>(<span class="keyword">List</span>&lt;<span class="keyword">E</span>&gt; <span class="keyword">list</span>, <span class="keyword">Class</span>&lt;<span class="keyword">E</span>&gt; cls) throws Exception &#123;</span><br><span class="line">    <span class="keyword">E</span> elem = cls.newInstance();   <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">list</span>.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>append</code>方法可以用如下方式调用：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">append(ls, <span class="built_in">String</span>.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure>
<h3 id="无法创建泛型类型的静态属性">无法创建泛型类型的静态属性</h3><p>以下泛型类型的静态属性声明是不允许的：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileDevice</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T os;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为如果允许静态属性是泛型参数类型，则对不同的实例化会产生歧义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MobileDevice<span class="tag">&lt;<span class="title">Smartphone</span>&gt;</span> phone = new MobileDevice<span class="tag">&lt;&gt;</span>();</span><br><span class="line">MobileDevice<span class="tag">&lt;<span class="title">Pager</span>&gt;</span> pager = new MobileDevice<span class="tag">&lt;&gt;</span>();</span><br><span class="line">MobileDevice<span class="tag">&lt;<span class="title">TabletPC</span>&gt;</span> pc = new MobileDevice<span class="tag">&lt;&gt;</span>();</span><br></pre></td></tr></table></figure>
<p>静态属性只跟随类存在一份，多个类型参数的对象创建时，无法设置静态成员os。</p>
<h3 id="不能对类型参数使用类型转换或instanceof">不能对类型参数使用类型转换或<code>instanceof</code></h3><p>由于类型擦除，无法验证泛型参数的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">rtti</span><span class="params">(List&lt;E&gt; <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> instanceof ArrayList&lt;Integer&gt;) &#123;  <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设传入<code>rtti</code>方法的参数结合为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = &#123; ArrayList<span class="tag">&lt;<span class="title">Integer</span>&gt;</span>, ArrayList<span class="tag">&lt;<span class="title">String</span>&gt;</span> LinkedList<span class="tag">&lt;<span class="title">Character</span>&gt;</span>, ... &#125;</span><br></pre></td></tr></table></figure>
<p>在运行时不会跟踪类型参数，所以JVM无法区分<code>ArrayList&lt;Integer&gt;</code> 和 <code>ArrayList&lt;String&gt;</code>，最多我们可以使用无界通配符来验证实参是否是<code>ArrayList</code>：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void rtti(<span class="keyword">List</span><span class="preprocessor">&lt;?</span>&gt; <span class="keyword">list</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">list</span> <span class="keyword">instanceof</span> ArrayList<span class="preprocessor">&lt;?</span>&gt;) &#123;  <span class="comment">// OK; instanceof requires a reifiable type</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除非使用无界通配符，否则无法对泛型参数类型进行强制类型转换：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;</span> li <span class="subst">=</span> <span class="literal">new</span> ArrayList<span class="subst">&lt;&gt;</span>();</span><br><span class="line"><span class="built_in">List</span><span class="subst">&lt;</span>Number<span class="subst">&gt;</span>  ln <span class="subst">=</span> (<span class="built_in">List</span><span class="subst">&lt;</span>Number<span class="subst">&gt;</span>) li;  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<p>在某些情况下，编译器明确知道类型参数一定匹配的情况下，才允许类型转换，例如：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span> l1 <span class="subst">=</span> <span class="attribute">...</span>;</span><br><span class="line">ArrayList<span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span> l2 <span class="subst">=</span> (ArrayList<span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span>)l1;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h3 id="不能创建泛型类型的数组：">不能创建泛型类型的数组：</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Integer&gt;[] arrayOfLists = <span class="keyword">new</span> <span class="built_in">List</span>&lt;Integer&gt;[<span class="number">2</span>];  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<p>当向一个数组中插入不同类型的值时，会出现什么情况？</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>[] strings = <span class="keyword">new</span> <span class="built_in">String</span>[<span class="number">2</span>];</span><br><span class="line">strings[<span class="number">0</span>] = <span class="string">"hi"</span>;   <span class="comment">// OK</span></span><br><span class="line">strings[<span class="number">1</span>] = <span class="number">100</span>;    <span class="comment">// An ArrayStoreException is thrown.</span></span><br></pre></td></tr></table></figure>
<p>同样，如果在泛型List上尝试插入不同类型会怎么样？</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>[] stringLists = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;[];  <span class="comment">// compiler error, but pretend it's allowed</span></span><br><span class="line">stringLists[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();   <span class="comment">// OK</span></span><br><span class="line">stringLists[<span class="number">1</span>] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  <span class="comment">// An ArrayStoreException should be thrown,</span></span><br><span class="line">                                            <span class="comment">// but the runtime can't detect it.</span></span><br></pre></td></tr></table></figure>
<h3 id="无法创建、捕获或抛出泛型类型的异常">无法创建、捕获或抛出泛型类型的异常</h3><p>泛型类无法直接或者间接的继承<code>Throwable</code>类型：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extends Throwable indirectly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathException&lt;T&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Exception</span> &#123;</span> <span class="comment">/* ... */</span> &#125;    <span class="comment">// compile-time error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extends Throwable directly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueFullException&lt;T&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Throwable</span> &#123;</span> <span class="comment">/* ... */</span> <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure></p>
<p>也无法捕获泛型类型：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> Exception, J&gt; <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(List&lt;J&gt; jobs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (J job : jobs)</span><br><span class="line">            // ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123;   <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是你可以声明一个方法抛出泛型类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser&lt;T</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Exception&gt;</span> &#123;</span></span><br><span class="line">    public void parse(<span class="type">File</span> file) <span class="keyword">throws</span> <span class="type">T</span> &#123;     <span class="comment">// OK</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无法通过不同的泛型参数类型重载方法">无法通过不同的泛型参数类型重载方法</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;String&gt; strSet)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;Integer&gt; intSet)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为类型擦除导致两个方法的参数类型是一样的。</p>
<p><a id="refs" href="#refs"></a></p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html" target="_blank" rel="external">https://docs.oracle.com/javase/tutorial/java/generics/index.html</a></li>
<li><a href="http://stackoverflow.com/questions/857420/what-are-the-reasons-why-map-getobject-key-is-not-fully-generic" target="_blank" rel="external">What are the reasons why Map.get(Object key) is not (fully) generic</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：泛型可以将某些类型相关的错误从运行时提前到编译时显现，但Java的泛型有很多特点和限制。本文介绍了泛型类型、原始类型、泛型方法、有界类型参数、泛型的继承和子类型、类型推断、通配符、类型擦除、非具体化类型和泛型的限制，之前用到的和以后要用的，都在这里了。<br><strong>Abstract</strong>: Java generics add stability to your code by making some bugs about types be detected early on complie-time. This article gives a comprehensive introduction to the important points Java generics.</p>
<h2 id="写在最前面">写在最前面</h2><p>一说泛型，好像都会。但前些天在看源码的时候，发现一个警告，引出了好多泛型的问题，最终让我下定决心整理一下Java泛型的坑（感谢Oracle，有一个很全面的Tutorial，Java编程思想都没有它介绍的详尽）。如果你也觉得你掌握了泛型，不妨试试以下问题，这些问题的解释，就包含在本篇文章里。</p>
<p>先看几个问题：</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="generic" scheme="http://zuoqy.com/tags/generic/"/>
    
      <category term="Java" scheme="http://zuoqy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scala]]></title>
    <link href="http://zuoqy.com/2015/05/11/scala/"/>
    <id>http://zuoqy.com/2015/05/11/scala/</id>
    <published>2015-05-11T12:34:22.000Z</published>
    <updated>2015-06-07T14:23:39.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：Scala语言要点<br><strong>Abstract</strong>: Simple Scala</p>
<a id="more"></a>
<h2 id="关键字">关键字</h2><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">abstract</td>
<td style="text-align:center">case</td>
<td style="text-align:center">catch</td>
<td style="text-align:center">class</td>
</tr>
<tr>
<td style="text-align:center">def</td>
<td style="text-align:center">do</td>
<td style="text-align:center">else</td>
<td style="text-align:center">extends</td>
</tr>
<tr>
<td style="text-align:center">false</td>
<td style="text-align:center">final</td>
<td style="text-align:center">finally</td>
<td style="text-align:center">for</td>
</tr>
<tr>
<td style="text-align:center">forSome</td>
<td style="text-align:center">if</td>
<td style="text-align:center">implicit</td>
<td style="text-align:center">import</td>
</tr>
<tr>
<td style="text-align:center">lazy</td>
<td style="text-align:center">match</td>
<td style="text-align:center">new</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">object</td>
<td style="text-align:center">override</td>
<td style="text-align:center">package</td>
<td style="text-align:center">private</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">return</td>
<td style="text-align:center">sealed</td>
<td style="text-align:center">super</td>
</tr>
<tr>
<td style="text-align:center">this</td>
<td style="text-align:center">throw</td>
<td style="text-align:center">trait</td>
<td style="text-align:center">try</td>
</tr>
<tr>
<td style="text-align:center">true</td>
<td style="text-align:center">type</td>
<td style="text-align:center">val</td>
<td style="text-align:center">var</td>
</tr>
<tr>
<td style="text-align:center">while</td>
<td style="text-align:center">with</td>
<td style="text-align:center">yield</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">:</td>
<td style="text-align:center">=</td>
<td style="text-align:center">=&gt;</td>
</tr>
<tr>
<td style="text-align:center">&lt;-</td>
<td style="text-align:center">&lt;:</td>
<td style="text-align:center">&lt;%</td>
<td style="text-align:center">&gt;:</td>
</tr>
<tr>
<td style="text-align:center">#</td>
<td style="text-align:center">@</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="数据类型">数据类型</h2><table>
<thead>
<tr>
<th style="text-align:center">dataType</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Byte</td>
<td style="text-align:center">8 bit signed value. Range from -128 to 127</td>
</tr>
<tr>
<td style="text-align:center">Short</td>
<td style="text-align:center">16 bit signed value. Range -32768 to 32767</td>
</tr>
<tr>
<td style="text-align:center">Int</td>
<td style="text-align:center">32 bit signed value. Range -2147483648 to 2147483647</td>
</tr>
<tr>
<td style="text-align:center">Long</td>
<td style="text-align:center">64 bit signed value. -9223372036854775808 to 9223372036854775807</td>
</tr>
<tr>
<td style="text-align:center">Float</td>
<td style="text-align:center">32 bit IEEE 754 single-precision float</td>
</tr>
<tr>
<td style="text-align:center">Double</td>
<td style="text-align:center">64 bit IEEE 754 double-precision float</td>
</tr>
<tr>
<td style="text-align:center">Char</td>
<td style="text-align:center">16 bit unsigned Unicode character. Range from U+0000 to U+FFFF</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">A sequence of Chars</td>
</tr>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">Either the literal true or the literal false</td>
</tr>
<tr>
<td style="text-align:center">Unit</td>
<td style="text-align:center">Corresponds to no value</td>
</tr>
<tr>
<td style="text-align:center">Null</td>
<td style="text-align:center">null or empty reference</td>
</tr>
<tr>
<td style="text-align:center">Nothing</td>
<td style="text-align:center">The subtype of every other type; includes no values</td>
</tr>
<tr>
<td style="text-align:center">Any</td>
<td style="text-align:center">The supertype of any type; any object is of type <em>Any</em></td>
</tr>
<tr>
<td style="text-align:center">AnyRef</td>
<td style="text-align:center">The supertype of any reference type</td>
</tr>
</tbody>
</table>
<h2 id="声明变量和值">声明变量和值</h2><pre><code><span class="variable"><span class="keyword">val</span> value</span> = <span class="number">7</span> <span class="comment">//声明值（常量，无法改变）</span>
<span class="variable"><span class="keyword">var</span> variable</span> = <span class="number">7</span> <span class="comment">//声明变量</span>
</code></pre><h2 id="赋值语句">赋值语句</h2><p>赋值语句没有值</p>
<pre><code><span class="variable">y =</span> <span class="number">1</span> // 值是()
<span class="variable">x =</span> <span class="variable">y =</span> <span class="number">1</span> //  <span class="variable">x =</span> () ; <span class="variable">y =</span> <span class="number">1</span>
</code></pre><h2 id="控制结构">控制结构</h2><h3 id="条件表达式">条件表达式</h3><p>条件表达式也有值，if/else没有覆盖到的返回<em>无用值</em>(Unit类，等同于void，用<em>()</em>表示)</p>
<pre><code><span class="variable"><span class="keyword">val</span> s</span> = <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span> <span class="comment">//所有值都有定义</span>
<span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="number">1</span>  <span class="comment">//else缺失等同于  if (x &gt; 0) 1 else ()</span>
</code></pre><h3 id="块表达式">块表达式</h3><p>包含在{}之间的语句集合为块表达式，块表达式也有值，取最后一个语句的值。</p>
<pre><code><span class="variable"><span class="keyword">val</span> distance</span> = {<span class="variable"><span class="keyword">val</span> dx</span> = x - x0; <span class="variable"><span class="keyword">val</span> dy</span> = y - y0; sqrt(dx * dx + dy * dy}
</code></pre><h3 id="循环">循环</h3><pre><code><span class="function"><span class="title">for</span><span class="params">(i &lt;- 表达式)</span></span> <span class="comment">//遍历右边表达式所有值</span>
<span class="function"><span class="title">for</span><span class="params">(i &lt;- <span class="number">1</span> to n)</span></span>  <span class="comment">// i = 1,2...n</span>
<span class="function"><span class="title">for</span><span class="params">(i &lt;- <span class="number">1</span> until n)</span></span> <span class="comment">// i = 1,2...n-1</span>
</code></pre><p>scala 没有提供 break 和 continue，可以通过以下方式：</p>
<pre><code>import scala.util.control.Breaks._
breakable {
    <span class="keyword">for</span> (<span class="keyword">...</span>) {
        <span class="keyword">if</span> (<span class="keyword">...</span>) <span class="keyword">break</span>;
        <span class="keyword">...</span>
    }
}
</code></pre><p>但以上方式使用异常抛出和捕获的形式实现，效率较低。</p>
<h2 id="函数(Functions)">函数(Functions)</h2><h3 id="函数定义">函数定义</h3><pre><code><span class="function"><span class="keyword">def</span> <span class="title">functionName</span> <span class="params">([list of parameters])</span> :</span> [<span class="keyword">return</span> type] = {
   function body
   <span class="keyword">return</span> [expr]
}
</code></pre><p>参数列表（List of parameters）和返回值类型（return type）是可选的。例如：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">addInt</span><span class="params">( a:Int, b:Int )</span> :</span> Int = {
  var sum:Int = <span class="number">0</span>
  sum = a + b

  <span class="keyword">return</span> sum
}
<span class="function"><span class="keyword">def</span> <span class="title">printMe</span><span class="params">( )</span> :</span> Unit = {
    println(<span class="string">"Hello, Scala!"</span>)
}  
</code></pre><h3 id="函数调用">函数调用</h3><pre><code>[instance.]<span class="function"><span class="title">functionName</span><span class="params">( list of parameters )</span></span>
</code></pre><h4 id="换名调用（Functions_Call-by-Name）">换名调用（Functions Call-by-Name）</h4><p>一般情况下，调用一个函数的时候，需要传入确定的参数；scala可以把函数作为参数，使得参数的值可以在运行时确定。<br>scala允许在函数声明和调用该函数参数的地方省略(), 但保留=&gt;</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">Test</span> {</span>
   <span class="function"><span class="keyword">def</span> <span class="title">main</span>(</span>args: <span class="type">Array</span>[<span class="type">String</span>]) {
        delayed(time());
   }

   <span class="function"><span class="keyword">def</span> <span class="title">time</span>(</span>) = {
      println(<span class="string">"Getting time in nano seconds"</span>)
      <span class="type">System</span>.nanoTime
   }
   <span class="comment">//换名调用</span>
   <span class="function"><span class="keyword">def</span> <span class="title">delayed</span>(</span> t: =&gt; <span class="type">Long</span> ) = {
      println(<span class="string">"In delayed method"</span>)
      println(<span class="string">"Param: "</span> + t)
      t
   }
   <span class="comment">//普通调用</span>
   <span class="function"><span class="keyword">def</span> <span class="title">delayed</span>(</span> t():=&gt;<span class="type">Long</span> ) = {
       ...
       t()
   }
}
</code></pre><h4 id="有名实参（Functions_with_Named_Arguments）">有名实参（Functions with Named Arguments）</h4><pre><code>object Test {
   <span class="keyword">def</span> main(args: Array[String]) {
        printInt(b=<span class="number">5</span>, a=<span class="number">7</span>); 
   }
   <span class="keyword">def</span> printInt( a:<span class="keyword">Int</span>, b:<span class="keyword">Int</span> ) = {
      <span class="keyword">println</span>(<span class="string">"Value of a : "</span> + a );
      <span class="keyword">println</span>(<span class="string">"Value of b : "</span> + b );
   }
}
</code></pre><p>命名实参的方式允许不按照顺序传入参数。</p>
<h4 id="可变参数（Function_with_Variable_Arguments）">可变参数（Function with Variable Arguments）</h4><pre><code><span class="class"><span class="keyword">object</span> <span class="title">Test</span> {</span>
   <span class="function"><span class="keyword">def</span> <span class="title">main</span>(</span>args: <span class="type">Array</span>[<span class="type">String</span>]) {
        printStrings(<span class="string">"Hello"</span>, <span class="string">"Scala"</span>, <span class="string">"Python"</span>);
   }
   <span class="function"><span class="keyword">def</span> <span class="title">printStrings</span>(</span> args:<span class="type">String</span>* ) = {
      <span class="keyword">var</span> i : <span class="type">Int</span> = <span class="number">0</span>;
      <span class="keyword">for</span>( arg &lt;- args ){
         println(<span class="string">"Arg value["</span> + i + <span class="string">"] = "</span> + arg );
         i = i + <span class="number">1</span>;
      }
   }
}
</code></pre><h4 id="递归函数（Recursion_Functions）">递归函数（Recursion Functions）</h4><pre><code><span class="class"><span class="keyword">object</span> <span class="title">Test</span> {</span>
   <span class="function"><span class="keyword">def</span> <span class="title">main</span>(</span>args: <span class="type">Array</span>[<span class="type">String</span>]) {
      <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>)
         println( <span class="string">"Factorial of "</span> + i + <span class="string">": = "</span> + factorial(i) )
   }

   <span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(</span>n: <span class="type">BigInt</span>): <span class="type">BigInt</span> = {  
      <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)
         <span class="number">1</span>  
      <span class="keyword">else</span>    
      n * factorial(n - <span class="number">1</span>)
   }
}
</code></pre><h4 id="默认参数（Default_Parameter_Values）">默认参数（Default Parameter Values）</h4><pre><code>object Test {
   <span class="keyword">def</span> main(args: Array[String]) {
        <span class="keyword">println</span>( <span class="string">"Returned Value : "</span> + addInt() );
   }
   <span class="keyword">def</span> addInt( a:<span class="keyword">Int</span>=<span class="number">5</span>, b:<span class="keyword">Int</span>=<span class="number">7</span> ) : <span class="keyword">Int</span> = {
      var sum:<span class="keyword">Int</span> = <span class="number">0</span>
      sum = a + b

      <span class="keyword">return</span> sum
   }
}
</code></pre><h4 id="高阶函数（Higher-Order_Functions）">高阶函数（Higher-Order Functions）</h4><p>高阶函数就是接收函数作为参数，或者返回值是一个函数的函数。</p>
<pre><code>object Test {
   def main(args: Array[String]) {

<span class="code">      println( apply( layout, 10) )</span>

   }

   def apply(f: Int =&gt; String, v: Int) = f(v)

   def layout[<span class="link_label">A</span>](<span class="link_url">x: A</span>) = "[" + x.toString() + "]"

}
</code></pre><h4 id="内嵌函数（Nested_Functions）">内嵌函数（Nested Functions）</h4><p>内嵌函数就是在函数内部定义的函数。其作用域只在函数内部有效。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(i: Int)</span>:</span> Int = {
    <span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(i: Int, accumulator: Int)</span>:</span> Int = {
     <span class="keyword">if</span> (i &lt;= <span class="number">1</span>)
        accumulator
     <span class="keyword">else</span>
        fact(i - <span class="number">1</span>, i * accumulator)
    }
    fact(i, <span class="number">1</span>)
}
</code></pre><h4 id="匿名函数（Anonymous_Functions）">匿名函数（Anonymous Functions）</h4><pre><code>(x:Int) =&gt; x+<span class="number">1</span>   <span class="comment">//带参数的匿名函数</span>
() =&gt; { System.getProperty(<span class="string">"user.dir"</span>) }  <span class="comment">//无参匿名函数</span>
<span class="keyword">var</span> inc = (x:Int) =&gt; x+<span class="number">1</span> <span class="comment">//函数变量</span>
</code></pre><h4 id="偏函数（Partially_Applied_Functions）">偏函数（Partially Applied Functions）</h4><pre><code><span class="keyword">import</span> java.util.<span class="type">Date</span>

<span class="class"><span class="keyword">object</span> <span class="title">Test</span> {</span>
   <span class="function"><span class="keyword">def</span> <span class="title">main</span>(</span>args: <span class="type">Array</span>[<span class="type">String</span>]) {
      <span class="function"><span class="keyword">val</span> <span class="title">date</span> =</span> <span class="keyword">new</span> <span class="type">Date</span>
      <span class="function"><span class="keyword">val</span> <span class="title">logWithDateBound</span> =</span> log(date, _ : <span class="type">String</span>) <span class="comment">//绑定日期，message可变</span>

      logWithDateBound(<span class="string">"message1"</span> )  <span class="comment">//调用时只需要传入message参数</span>
      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)
      logWithDateBound(<span class="string">"message2"</span> )
      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)
      logWithDateBound(<span class="string">"message3"</span> )
   }

   <span class="function"><span class="keyword">def</span> <span class="title">log</span>(</span>date: <span class="type">Date</span>, message: <span class="type">String</span>)  = {
     println(date + <span class="string">"----"</span> + message)
   }
}
</code></pre><h4 id="柯里化函数（Currying_Functions）">柯里化函数（Currying Functions）</h4><p>柯里化是把原本包含多个参数的函数分解为一系列接受单个参数的函数。</p>
<pre><code>def strcat<span class="list">(<span class="keyword">s1</span>: String)</span> = <span class="list">(<span class="keyword">s2</span>: String)</span> =&gt; s1 + s2
</code></pre><p>可以理解为：函数strcat(s1: String)返回一个匿名函数 (s2: String) =&gt; s1 + s2， 匿名函数的返回值是两个参数之和。</p>
<pre><code>def <span class="function"><span class="title">strcat</span><span class="params">(s1: String)</span><span class="params">(s2: String)</span></span> = s1 + s2 <span class="comment">//柯里化简写形式</span>
</code></pre><h2 id="闭包">闭包</h2><p>闭包是一种特殊的函数，它的返回值依赖于在该函数外部声明的变量。</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">Test</span> {</span>
   <span class="function"><span class="keyword">def</span> <span class="title">main</span>(</span>args: <span class="type">Array</span>[<span class="type">String</span>]) {
      println( <span class="string">"muliplier(1) value = "</span> +  multiplier(<span class="number">1</span>) )
      println( <span class="string">"muliplier(2) value = "</span> +  multiplier(<span class="number">2</span>) )
   }
   <span class="keyword">var</span> factor = <span class="number">3</span>
   <span class="function"><span class="keyword">val</span> <span class="title">multiplier</span> =</span> (i:<span class="type">Int</span>) =&gt; i * factor
}
</code></pre><h2 id="类（Class）">类（Class）</h2><h3 id="声明">声明</h3><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="variable"><span class="keyword">val</span> xc</span>: <span class="typename">Int</span>, <span class="variable"><span class="keyword">val</span> yc</span>: <span class="typename">Int</span>) {
   <span class="variable"><span class="keyword">var</span> x</span>: <span class="typename">Int</span> = xc
   <span class="variable"><span class="keyword">var</span> y</span>: <span class="typename">Int</span> = yc
   def move(dx: <span class="typename">Int</span>, dy: <span class="typename">Int</span>) {
      x = x + dx
      y = y + dy
      println (<span class="string">"Point x location : "</span> + x);
      println (<span class="string">"Point y location : "</span> + y);
   }
}
</code></pre><h3 id="实例化">实例化</h3><pre><code><span class="function"><span class="keyword">val</span> <span class="title">pt</span> =</span> <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">10</span>, <span class="number">20</span>);
</code></pre><h2 id="属性">属性</h2><p>scala中的属性相当于Java中的private属性加上Getter和Setter方法。有公有属性、类私有属性和对象私有属性三种。<br>公有属性相当于private字段加上public的Getter和Setter；<br>类私有属性相当于private字段加上private的Setter和Getter，在类内部的方法可以访问类的私有属性。<br>对象私有属性相当于只有private字段，只限在对象内部能访问，即使在类内部也不能访问相同类对象的对象私有属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span> </span>&#123;</span><br><span class="line">  <span class="variable"><span class="keyword">val</span> p1</span> = <span class="number">1</span> <span class="comment">// public 常量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> p11</span> = <span class="number">11</span>  <span class="comment">//类私有常量</span></span><br><span class="line">  <span class="keyword">private</span>[this] <span class="variable"><span class="keyword">val</span> p111</span> = <span class="number">111</span> <span class="comment">// 对象私有常量</span></span><br><span class="line"></span><br><span class="line">  <span class="variable"><span class="keyword">var</span> p2</span> = <span class="number">2</span>                    <span class="comment">//public 变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> p22</span> = <span class="number">22</span>          <span class="comment">// 类私有变量</span></span><br><span class="line">  <span class="keyword">private</span>[this] <span class="variable"><span class="keyword">var</span> p222</span> = <span class="number">222</span>  <span class="comment">// 对象私有变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>javap -private Property.class</code>命令反编译一下生成的java代码：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">classes</span>.<span class="title">Property</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> p1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> p11;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> p111;  <span class="comment">//对象私有常量不生成getter和setter</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> p2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> p22;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> p222;  <span class="comment">// 对象私有变量不生成getter和setter</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">p1</span><span class="params">()</span></span>;   <span class="comment">// public常量只生成public getter</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">int</span> <span class="title">p11</span><span class="params">()</span></span>; <span class="comment">// 类私有常量只生成private getter</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// public变量生成public getter和setter</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">p2</span><span class="params">()</span></span>;   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> p2_$eq(<span class="keyword">int</span>); <span class="comment">// Scala的Setter方法</span></span><br><span class="line">  <span class="comment">// 类私有变量生成private 的getter和setter</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">int</span> <span class="title">p22</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> p22_$eq(<span class="keyword">int</span>);</span><br><span class="line">  <span class="comment">// 主构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> classes.<span class="title">Property</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用val声明的常量，在Java中对应final的属性，没有对应的Setter方法。</p>
<blockquote>
<p>Scala中的Setter和Getter是分别是<code>属性名()</code>和<code>属性名_=()</code>括号可以不写。通常改变属性名的方法使用<code>()</code>,访问属性的只读方法省略<code>()</code>.</p>
</blockquote>
<h3 id="继承">继承</h3><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Location</span></span>(<span class="keyword">override</span> <span class="variable"><span class="keyword">val</span> xc</span>: <span class="typename">Int</span>, <span class="keyword">override</span> <span class="variable"><span class="keyword">val</span> yc</span>: <span class="typename">Int</span>,
    <span class="variable"><span class="keyword">val</span> zc</span> :<span class="typename">Int</span>) extends Point(xc, yc){
    <span class="variable"><span class="keyword">var</span> z</span>: <span class="typename">Int</span> = zc

    def move(dx: <span class="typename">Int</span>, dy: <span class="typename">Int</span>, dz: <span class="typename">Int</span>) {
        x = x + dx
        y = y + dy
        z = z + dz
        println (<span class="string">"Point x location : "</span> + x);
        println (<span class="string">"Point y location : "</span> + y);
        println (<span class="string">"Point z location : "</span> + z);
    }
}
</code></pre><h3 id="单例对象">单例对象</h3><p>scala比Java更加面向对象，其没有static成员，声明并初始化单例对象使用object关键字。</p>
<pre><code><span class="class"><span class="keyword">object</span> <span class="title">Test</span> {</span>
   <span class="function"><span class="keyword">def</span> <span class="title">main</span>(</span>args: <span class="type">Array</span>[<span class="type">String</span>]) {
      <span class="function"><span class="keyword">val</span> <span class="title">point</span> =</span> <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">10</span>, <span class="number">20</span>)
      printPoint

      <span class="function"><span class="keyword">def</span> <span class="title">printPoint</span>{</span>
         println (<span class="string">"Point x location : "</span> + point.x);
         println (<span class="string">"Point y location : "</span> + point.y);
      }
   }
}
</code></pre><p>未完待续…</p>
<h2 id="参考">参考</h2><p><a href="http://www.tutorialspoint.com/scala/index.htm" target="_blank" rel="external">Scala Tutorial</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：Scala语言要点<br><strong>Abstract</strong>: Simple Scala</p>]]>
    
    </summary>
    
      <category term="scala" scheme="http://zuoqy.com/tags/scala/"/>
    
      <category term="scala" scheme="http://zuoqy.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java容器类——接口]]></title>
    <link href="http://zuoqy.com/2015/05/06/java-containers-interfaces/"/>
    <id>http://zuoqy.com/2015/05/06/java-containers-interfaces/</id>
    <published>2015-05-06T07:20:43.000Z</published>
    <updated>2015-05-19T13:35:15.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：本文介绍了Java容器类的核心接口，以及容器泛型的使用原则。<br><strong>Abstract</strong>: This article describes the core interfaces of Java Collections, and the principles of using generic.</p>
<a id="more"></a>
<p>JDK java.util 包中包含了几个重要的集合类(主要包含实现了Collection接口和Map接口的类)，从本篇文章开始总结JDK中自带的几个重要的容器类。</p>
<h2 id="Java集合框架核心接口">Java集合框架核心接口</h2><p><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-05-06/1.png" alt="The core collection interfaces"></p>
<h3 id="Iterable">Iterable</h3><p>实现了Iterable接口的类，可以使用foreach语法迭代，从JDK1.5开始加入。</p>
<pre><code>package java.lang;

<span class="keyword">import</span> java.util.<span class="type">Iterator</span>;

public <span class="keyword">interface</span> <span class="type">Iterable</span>&lt;T&gt; {

    /**
     * <span class="type">Returns</span> an <span class="keyword">iterator</span> over a <span class="type">set</span> <span class="keyword">of</span> elements <span class="keyword">of</span> <span class="keyword">type</span> T.
     *
     * @<span class="keyword">return</span> an <span class="type">Iterator</span>.
     */
    <span class="type">Iterator</span>&lt;T&gt; <span class="keyword">iterator</span>();
}
</code></pre><h3 id="Collection">Collection</h3><p>一组对象的集合。没有规定对象的顺序（如果有）和是否允许重复。Java平台不提供此接口的任何直接实现，但提供了更具体的子接口，如Set和List实现。</p>
<ul>
<li>一般实现Collection子接口的类需要提供两个标准构造方法：1.无参构造方法（用于创建空集合）2.只有一个Collection类型参数的构造方法（用于创建一个集合副本）。这虽然不是硬性的规定（接口无法限定构造方法），但是每个实现类都遵循了这个原则。</li>
<li>对不支持的操作，应当抛出<em>UnsupportedOperationException</em></li>
</ul>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>{
    <span class="comment">// Query Operations</span>
    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;
    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;   <span class="comment">//from Iterable</span>
    Object[] toArray();
    &lt;T&gt; T[] toArray(T[] a);

    <span class="comment">// Modification Operations</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;

    <span class="comment">// Bulk Operations</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;

    <span class="comment">// Comparison and hashing</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;
    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;
}
</code></pre><p>这里引入一个小插曲：为什么Collection.add()方法使用了泛型，而remove()方法却使用了Object类型的参数？答案参见这里：<br><a href="http://stackoverflow.com/questions/104799/why-arent-java-collections-remove-methods-generic" target="_blank" rel="external">Why aren’t Java Collections remove methods generic?</a><br><a href="http://smallwig.blogspot.jp/2007/12/why-does-setcontains-take-object-not-e.html" target="_blank" rel="external">Why does Set.contains() take an Object, not an E?</a><br>总结起来有以下几方面的原因：</p>
<ul>
<li>当且仅当你需要防止Collection被破坏的时候，才考虑使用泛型约束<blockquote>
<p>Actually, it’s very simple! If add() took a wrong object, it would break the collection. It would contain things it’s not supposed to! That is not the case for remove(), or contains(). Incidentally, that basic rule — using type parameters to prevent actual damage to the collection only — is followed absolutely consistently in the whole library. –  Kevin Bourrillion</p>
</blockquote>
</li>
<li>在remove上使用泛型限制，可能auto boxing问题</li>
</ul>
<p>另外，泛型是编译期的静态类型检查，所以以下的泛型使用方式也是错误的：</p>
<pre><code><span class="keyword">List</span><span class="preprocessor">&lt;?</span> extends MinCut&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;MinCut&gt;();
</code></pre><p>这将导致除了null，list里不能插入任何对象。</p>
<h3 id="Set">Set</h3><p>数学集合的抽象，不允许元素重复。</p>
<pre><code><span class="keyword">package</span> java.util;

<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>{
    <span class="comment">// Query Operations</span>
    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;
    Object[] toArray();
    &lt;T&gt; T[] toArray(T[] a);

    <span class="comment">// Modification Operations</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;

    <span class="comment">// Bulk Operations</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? <span class="keyword">extends</span> E&gt; c)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;

    <span class="comment">// Comparison and hashing</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;
    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;
}
</code></pre><h3 id="SortedSet">SortedSet</h3><p>有序对象集合。SortedSet中的对象会根据Comparable接口或提供的Comparator进行排序。</p>
<pre><code>package java.util;

public interface SortedSet&lt;<span class="keyword">E</span>&gt; extends <span class="keyword">Set</span>&lt;<span class="keyword">E</span>&gt; {
    Comparator&lt;? super <span class="keyword">E</span>&gt; comparator();
    SortedSet&lt;<span class="keyword">E</span>&gt; subSet(<span class="keyword">E</span> fromElement, <span class="keyword">E</span> toElement);
    SortedSet&lt;<span class="keyword">E</span>&gt; headSet(<span class="keyword">E</span> toElement);
    SortedSet&lt;<span class="keyword">E</span>&gt; tailSet(<span class="keyword">E</span> fromElement);
    <span class="keyword">E</span> first();
    <span class="keyword">E</span> last();
}
</code></pre><h3 id="NavigableSet">NavigableSet</h3><p>继承SortedSet并且其中的元素可以按照升序和降序访问。</p>
<pre><code>package java.util;

public interface SortedSet&lt;<span class="keyword">E</span>&gt; extends <span class="keyword">Set</span>&lt;<span class="keyword">E</span>&gt; {
    Comparator&lt;? super <span class="keyword">E</span>&gt; comparator();
    SortedSet&lt;<span class="keyword">E</span>&gt; subSet(<span class="keyword">E</span> fromElement, <span class="keyword">E</span> toElement);
    SortedSet&lt;<span class="keyword">E</span>&gt; headSet(<span class="keyword">E</span> toElement);
    SortedSet&lt;<span class="keyword">E</span>&gt; tailSet(<span class="keyword">E</span> fromElement);
    <span class="keyword">E</span> first();
    <span class="keyword">E</span> last();
}
</code></pre><h3 id="List">List</h3><p>有序集合，也称为序列（<em>Sequence</em>）。一般情况下允许元素重复。允许按位置访问。</p>
<pre><code><span class="keyword">package</span> java.util;

<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>{
    <span class="comment">// Query Operations</span>
    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;
    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;
    Object[] toArray();
    &lt;T&gt; T[] toArray(T[] a);

    <span class="comment">// Modification Operations</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;

    <span class="comment">// Bulk Modification Operations</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;

    <span class="comment">// Comparison and hashing</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;
    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;

    <span class="comment">// Positional Access Operations</span>
    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;
    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;
    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;

    <span class="comment">// Search Operations</span>
    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;
    <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;

    <span class="comment">// List Iterators</span>
    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;
    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;

    <span class="comment">// View</span>
    <span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;
}
</code></pre><h3 id="Queue">Queue</h3><p>专为保存加工前的元素的集合。除了基本的Collection操作，队列提供额外的插入、提取和检查操作。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>{
    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;
    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;
}
</code></pre><h3 id="BlockingQueue">BlockingQueue</h3><p>阻塞队列</p>
<pre><code><span class="keyword">package</span> java.util.concurrent;

<span class="keyword">import</span> java.util.Collection;
<span class="keyword">import</span> java.util.Queue;

<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>{
    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span>
        <span class="keyword">throws</span> InterruptedException</span>;
    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;
    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span>
        <span class="keyword">throws</span> InterruptedException</span>;
    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;
    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;
    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;
}
</code></pre><h3 id="TransferQueue">TransferQueue</h3><p>生产者可以等待消费者接收元素的阻塞队列。</p>
<pre><code><span class="keyword">package</span> java.util.concurrent;

<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>{
    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e)</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">tryTransfer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span>
        <span class="keyword">throws</span> InterruptedException</span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">hasWaitingConsumer</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">int</span> <span class="title">getWaitingConsumerCount</span><span class="params">()</span></span>;
}
</code></pre><h3 id="Deque">Deque</h3><p>双端队列，支持在两端插入和删除元素。扩展了Queue接口。</p>
<pre><code><span class="keyword">package</span> java.util;

<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>{
    <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span>;
    <span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">peekLast</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span>;

    <span class="comment">// *** Queue methods ***</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;
    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;
    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;

    <span class="comment">// *** Stack methods ***</span>
    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;
    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;

    <span class="comment">// *** Collection methods ***</span>
    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;
    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;
    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;
    <span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;
}
</code></pre><h3 id="BlockingDeque">BlockingDeque</h3><p>阻塞双端队列</p>
<h3 id="Map">Map</h3><p>键值映射，每个键对应一个值。</p>
<h3 id="SortedMap">SortedMap</h3><p>按Key有序的Map</p>
<h3 id="NavigableMap">NavigableMap</h3><p>继承SortedMap，并且其中的元素可以按照Key升序和降序访问。</p>
<h3 id="ConcurrentMap">ConcurrentMap</h3><p>putIfAbsent、remove和replace方法都具有原子性.</p>
<h3 id="ConcurrentNavigableMap">ConcurrentNavigableMap</h3><p>元素可以按照Key升序和降序访问。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/collections/reference.html" target="_blank" rel="external">Outline of the Collections Framework</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：本文介绍了Java容器类的核心接口，以及容器泛型的使用原则。<br><strong>Abstract</strong>: This article describes the core interfaces of Java Collections, and the principles of using generic.</p>]]>
    
    </summary>
    
      <category term="Collections" scheme="http://zuoqy.com/tags/Collections/"/>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="Java" scheme="http://zuoqy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java finalize方法]]></title>
    <link href="http://zuoqy.com/2015/04/20/java-finalize/"/>
    <id>http://zuoqy.com/2015/04/20/java-finalize/</id>
    <published>2015-04-20T02:49:05.000Z</published>
    <updated>2015-04-20T08:47:01.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：本文简单介绍了Java finalize方法，以及运行时是否可能查看对象的GC状态。<br><strong>Abstract</strong>: This article introduces the Java finalize method, and whether it is possible to view the status of the runtime object GC.<br><a id="more"></a></p>
<p>即使在<a href="/2015/04/20/java-gc-reference/">可达性分析算法</a>中不可达的对象，也并非是非死不可，对象要被回收，至少需要以下两个过程：</p>
<ul>
<li>根据是否有必要执行finalize方法进行第一次筛选（如果finalize方法没有被覆盖或者JVM已经调用过，视为<em>没有必要执行</em>）。如果对象被判定为有必要执行finalize方法，则被加入F-Queue队列，稍后由JVM建立的低优先级的Finalizer线程调用其finalize方法（为防止死循环或者调用缓慢阻塞队列中其他对象，JVM不保证等待调用执行完毕）。</li>
<li>对象在finalize方法中，与GC Roots重新建立了连接，则不会被回收；否则对象将被回收。</li>
</ul>
<p><em>注</em>：任何对象的finalize方法都只会被JVM调用一次，如果对象面临第二次回收过程，finalize方法将不会被再次调用。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeTest</span> </span>{
    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeTest SAVE_HOOK = <span class="keyword">null</span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alive</span><span class="params">()</span> </span>{
        System.out.println(<span class="string">"I am alive!"</span>);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">()</span> </span>{
        System.out.println(<span class="string">"Die!"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>{
        <span class="keyword">super</span>.finalize();
        SAVE_HOOK = <span class="keyword">this</span>;
        System.out.println(<span class="string">"finalize()"</span>);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{
        SAVE_HOOK = <span class="keyword">new</span> FinalizeTest();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) {
            gc();
            <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) {
                SAVE_HOOK.alive();
            } <span class="keyword">else</span> {
                die();
            }
        }
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{
        SAVE_HOOK = <span class="keyword">null</span>;
        System.gc();
        Thread.sleep(<span class="number">500</span>);
    }
}
</code></pre><p><em>以上代码验证了finalize()方法只会被JVM调用一次，但不能说明对象是否在运行过程中是否已经被回收掉！换句话说，在运行时判断一个对象是否已经被回收掉是<strong>不可能</strong>的（<a href="http://stackoverflow.com/questions/4223956/check-if-object-can-be-fetched-by-garbage-collector" target="_blank" rel="external">参见这里</a>）。</em></p>
<p><em>finalize方法可以被try-finally替代，并处理的更好更及时。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：本文简单介绍了Java finalize方法，以及运行时是否可能查看对象的GC状态。<br><strong>Abstract</strong>: This article introduces the Java finalize method, and whether it is possible to view the status of the runtime object GC.<br>]]>
    
    </summary>
    
      <category term="GC" scheme="http://zuoqy.com/tags/GC/"/>
    
      <category term="JVM" scheme="http://zuoqy.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="Java" scheme="http://zuoqy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java内存回收算法和引用类型]]></title>
    <link href="http://zuoqy.com/2015/04/20/java-gc-reference/"/>
    <id>http://zuoqy.com/2015/04/20/java-gc-reference/</id>
    <published>2015-04-20T01:52:24.000Z</published>
    <updated>2015-04-20T07:24:45.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：<em>本文介绍了两种内存回收算法和4种Java引用类型。</em><br><strong>Abstract</strong>: <em>This article introduced two kinds of Garbage Collection Algorithm and four kinds of reference type in Java.</em></p>
<a id="more"></a>
<h2 id="内存回收算法">内存回收算法</h2><h3 id="引用计数(Reference_Counting)">引用计数(Reference Counting)</h3><p>给对象添加一个引用计数器，当有一个对象引用它，计数值加1；当引用失效时，计数值减1；任何时刻，计数为0的对象可回收。<br>主流的JVM并没有选用该算法，主要原因是：<em>无法解决循环引用的问题</em>。</p>
<h3 id="可达性分析(Reachability_Analysis)">可达性分析(Reachability Analysis)</h3><p>通过一系列的称为<em>GC Roots</em>的的对象作为起始点，向下搜索（搜索路径为<strong>引用链</strong> (<em>Reference Chain</em>)），当对象没有任何引用链与GC Roots相连时，对象可回收。<br>一般以下对象可作为GC Roots：</p>
<ul>
<li>虚拟机栈中本地变量表所引用的对象</li>
<li>方法区中类静态属性所引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈引用的对象</li>
</ul>
<h2 id="引用(Reference)">引用(Reference)</h2><p>JDK1.2之前<strong>引用</strong>的定义：如果内存中存储的数值是另一块内存的起始地址，则这块内存代表一个引用。<br>JDK1.2之后，<strong>引用</strong>引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)四种（依次减弱）。</p>
<h3 id="强引用">强引用</h3><p>类似Object obj = new Object()这类引用，只要引用还存在，对象就不会被回收。</p>
<h3 id="软引用">软引用</h3><p>用来描述有用但非必须的对象。OOM之前，JVM会在这些对象范围中进行第二次回收。</p>
<h3 id="弱引用">弱引用</h3><p>弱引用指向的对象只能生存到下一次垃圾回收之前，无论当前内存是否足够，都会回收掉被弱引用关联的对象。</p>
<h3 id="虚引用">虚引用</h3><p>虚引用也称为幽灵引用或者幻影引用，它使最弱的一种引用关系。虚引用的存在，不会对对象的生存时间构成影响，也无法通过虚引用取得对象实例。<br>为对象设置虚引用管理的唯一目的是能在这个对象<strong>执行了finalize方法，准备好被垃圾回收时</strong>(不能在运行时通过幽灵引用判断对象是否已经被GC[2])收到一个系统通知。</p>
<blockquote>
<p>A Phantom Reference can’t tell when an Object was GCed. It is just a signal which says that an Object has been finalized and is ready for GC.</p>
</blockquote>
<h2 id="Reference">Reference</h2><ul>
<li><em>《深入理解Java虚拟机》</em></li>
<li><em><a href="http://stackoverflow.com/questions/4223956/check-if-object-can-be-fetched-by-garbage-collector" target="_blank" rel="external">有关是否能在运行时得知对象是否已经被GC在StackOverflow上的讨论</a></em></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：<em>本文介绍了两种内存回收算法和4种Java引用类型。</em><br><strong>Abstract</strong>: <em>This article introduced two kinds of Garbage Collection Algorithm and four kinds of reference type in Java.</em></p>]]>
    
    </summary>
    
      <category term="GC" scheme="http://zuoqy.com/tags/GC/"/>
    
      <category term="JVM" scheme="http://zuoqy.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="Java" scheme="http://zuoqy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java内存溢出(Java OutOfMemoryError)]]></title>
    <link href="http://zuoqy.com/2015/04/17/java-memory2/"/>
    <id>http://zuoqy.com/2015/04/17/java-memory2/</id>
    <published>2015-04-17T06:59:40.000Z</published>
    <updated>2015-04-20T03:04:25.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：<em>本文介绍了Java内存溢出的四种形式：Java堆溢出、虚拟机栈和本地方法栈溢出、方法区和运行时常量池溢出、直接内存溢出。并对JVM堆外内存使用做了简单了介绍。</em><br><strong>Abstract</strong>: <em>This article describes the four types of memory overflow in Java: Java heap overflow, virtual machine stack and local method stack overflow, the method area and runtime constant pool overflow, direct memory overflow. And a simple introduction of off-heap memory usage.</em></p>
<a id="more"></a>
<h2 id="Java堆溢出">Java堆溢出</h2><pre><code><span class="comment">//JVM args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span>
public <span class="class"><span class="keyword">class</span> <span class="title">TestMemLeak</span> </span>{
    public <span class="literal">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) {
        <span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">Object</span>&gt;();
        <span class="keyword">while</span>(<span class="keyword">true</span>) {
            list.add(<span class="keyword">new</span> <span class="built_in">Object</span>());
        }
    }
}
</code></pre><p>-XX:+HeapDumpOnOutOfMemoryError 设置JVM在出现OOM时，对Heap进行转储，可以使用Eclipse MemoryAnalyzer 进行分析。<br>如果对运行中的服务进行dump，可以使用jmap命令：</p>
<pre><code>jmap -dump:live,<span class="keyword">format</span>=b,<span class="keyword">file</span>=heap.bin
</code></pre><p>使用MAT分析结果会有如下的描述：<br><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-04-17/1.png" alt="oom"><br>帮助查找问题所在</p>
<h2 id="虚拟机栈和本地方法栈溢出">虚拟机栈和本地方法栈溢出</h2><p>HotSpot JVM不区分虚拟机栈和本地方法栈，虽然存在-Xoss设置，但是<em>实际上是无效的</em>。栈容量只有-Xss来确定。<br>虚拟机规范中规定了虚拟机栈和本地方法栈的两种异常：</p>
<h3 id="StackOverflowError:">StackOverflowError:</h3><p>线程请求的栈深度大于虚拟机允许的最大深度。</p>
<pre><code><span class="comment">//JVM args: -Xss256k (规定最小栈大小是160k)</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSOF</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        test();
    }
    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>{
        test();
    }
}
</code></pre><h3 id="OutOfMemoryError:">OutOfMemoryError:</h3><p>虚拟机扩展栈的大小时，不能申请到足够的内存空间。可通过不断创建线程的方式，使JVM出现内存溢出的错误。</p>
<h2 id="方法区和运行时常量池溢出">方法区和运行时常量池溢出</h2><pre><code><span class="comment">//JVM args: -XX:PermSize=2M -XX:MaxPermSize=4M</span>
public <span class="class"><span class="keyword">class</span> <span class="title">TestConstancePoolOOM</span> </span>{
    public <span class="literal">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) {
        <span class="built_in">int</span> i = <span class="number">0</span>;
        <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();
        <span class="keyword">while</span>(<span class="keyword">true</span>) {
            list.add(<span class="built_in">String</span>.valueOf(i++).intern());
        }
    }
}
</code></pre><p>以上代码在JDK1.6运行时会抛<em>java.lang.OutOfMemoryError: PermGen space</em>错误。Jdk1.7不会出现此错误。<em>TODO</em><br>String.intern方法检查当前String是否在常量池中，如果存在，返回该对象；否则将当前对象放入常量池并返回其引用；</p>
<h2 id="直接内存溢出">直接内存溢出</h2><p>JVM通过参数 -XX:MaxDirectMemorySize 指定可用直接内存的大小，如果不指定，则默认与-Xms最大对内存大小相同<br>Java使用直接内存有两种方法：一种是使用sun.misc.UnSafe类来申请直接内存；另外就是直接调用nio的ByteBuffer.allocateDirect()方法。</p>
<h3 id="sun-misc-Unsafe申请直接内存：">sun.misc.Unsafe申请直接内存：</h3><p>直接使用以下代码申请直接内存空间：</p>
<pre><code><span class="keyword">Unsafe</span> <span class="keyword">unsafe</span> = <span class="keyword">Unsafe</span>.getUnsafe();
<span class="keyword">unsafe</span>.allocateMemory(<span class="number">1024</span>*<span class="number">1024</span>);
</code></pre><p>会报如下的错误：</p>
<pre><code>Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="class">.lang</span><span class="class">.SecurityException</span>: Unsafe
    at sun<span class="class">.misc</span><span class="class">.Unsafe</span><span class="class">.getUnsafe</span>(Unsafe<span class="class">.java</span>:<span class="number">90</span>)
    at DirectMemoryOOM.<span class="function"><span class="title">main</span><span class="params">(DirectMemoryOOM.java:<span class="number">9</span>)</span></span>
    at sun<span class="class">.reflect</span><span class="class">.NativeMethodAccessorImpl</span><span class="class">.invoke0</span>(Native Method)
    at sun<span class="class">.reflect</span><span class="class">.NativeMethodAccessorImpl</span><span class="class">.invoke</span>(NativeMethodAccessorImpl<span class="class">.java</span>:<span class="number">57</span>)
    at sun<span class="class">.reflect</span><span class="class">.DelegatingMethodAccessorImpl</span><span class="class">.invoke</span>(DelegatingMethodAccessorImpl<span class="class">.java</span>:<span class="number">43</span>)
    at java<span class="class">.lang</span><span class="class">.reflect</span><span class="class">.Method</span><span class="class">.invoke</span>(Method<span class="class">.java</span>:<span class="number">606</span>)
    at com<span class="class">.intellij</span><span class="class">.rt</span><span class="class">.execution</span><span class="class">.application</span><span class="class">.AppMain</span><span class="class">.main</span>(AppMain<span class="class">.java</span>:<span class="number">140</span>)
</code></pre><p>官方的解释是：</p>
<blockquote>
<p>Although the class and all methods are public, use of this class is limited because only trusted code can obtain instances of it.</p>
</blockquote>
<p>解决方案就是使用反射：</p>
<pre><code>Field <span class="variable">f =</span> Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);
f.setAccessible(<span class="constant">true</span>);
Unsafe <span class="variable">us =</span> (Unsafe) f.get(<span class="constant">null</span>);
long <span class="variable">p =</span> us.allocateMemory(<span class="number">1000</span>);
us.freeMemory(p);
</code></pre><p>直接内存溢出代码如下：</p>
<pre><code><span class="comment">//JVM args: -Xms10m -Xmx10m -XX:MaxDirectMemorySize=10m</span>
<span class="keyword">public</span> <span class="keyword">class</span> DirectMemoryOOM {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException {
        Field f = Unsafe.<span class="keyword">class</span>.getDeclaredFields()[<span class="number">0</span>];
        f.setAccessible(<span class="keyword">true</span>);
        Unsafe us = (Unsafe) f.get(<span class="keyword">null</span>);
        <span class="keyword">long</span> <span class="keyword">size</span> = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;
        <span class="keyword">while</span> (<span class="keyword">true</span>) {
            <span class="keyword">long</span> p = us.allocateMemory(<span class="keyword">size</span>);
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">size</span>; i++) {
                us.putByte(p + i, <span class="keyword">Byte</span>.MAX_VALUE);
            }
        }
    }
}
</code></pre><p>上述代码在MacOS jdk1.7上运行，内存分配会暴涨并开始使用交换分区，但不会报OOM错误。<br>在<a href="http://stackoverflow.com/questions/28670700/java-unsafe-memory-allocation-limit" target="_blank" rel="external">StackOverFlow</a>上的回答是直接调用了操作系统的malloc函数，从而不受虚拟机参数的限制。呃，太凶险了。尽信书不如无书，周志明的《深入理解JAVA虚拟机》也有BUG。</p>
<h3 id="Java_NIO申请直接内存：">Java NIO申请直接内存：</h3><p>其实有了Java NIO之后，使用直接内存比Unsafe要方便的多：</p>
<pre><code><span class="comment">//JVM args: -Xms10m -Xmx10m -XX:MaxDirectMemorySize=10m</span>
<span class="keyword">public</span> <span class="keyword">class</span> DirectMemoryOOM {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException {
        <span class="keyword">int</span> <span class="keyword">size</span> = <span class="number">1024</span> * <span class="number">1024</span>;
        System.out.<span class="keyword">println</span>(sun.misc.VM.maxDirectMemory());
        <span class="keyword">while</span> (<span class="keyword">true</span>) {
            ByteBuffer.allocateDirect(<span class="keyword">size</span>);
        }
    }
}
</code></pre><p>上面这段程序很快就可以造成OOM错误，JVM退出。翻了一下ByteBuffer.allocateDirect()的实现，里面就是用的Unsafe.allocateMemory()函数。这难道不很奇怪？<br>原来是我没有仔细看，JDK1.7 java.nio.Bits line:123 调用了Bits.reserveMemory()，这个方法对申请内存大小进行了检查，超出之后抛出OOM错误。</p>
<pre><code><span class="comment">// These methods should be called whenever direct memory is allocated or</span>
<span class="comment">// freed.  They allow the user to control the amount of direct memory</span>
<span class="comment">// which a process may access.  All sizes are specified in bytes.</span>
<span class="keyword">static</span> <span class="keyword">void</span> reserveMemory(<span class="keyword">long</span> <span class="keyword">size</span>, <span class="keyword">int</span> cap) {
    ...
    <span class="keyword">synchronized</span> (Bits.<span class="keyword">class</span>) {
                <span class="keyword">if</span> (totalCapacity + cap &gt; maxMemory)
                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(<span class="string">"Direct buffer memory"</span>);
                reservedMemory += <span class="keyword">size</span>;
                totalCapacity += cap;
                <span class="keyword">count</span>++;
    }
    ...
}
</code></pre><p>并且，在Bits.java中，也有根据-XX:MaxDirectMemorySize=<size>初始化的代码：</size></p>
<pre><code><span class="comment">// initialization if it is launched with "-XX:MaxDirectMemorySize=&lt;size&gt;".</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span> maxMemory = VM.maxDirectMemory();
</code></pre><p>参见：<a href="http://stackoverflow.com/questions/29702028/why-xxmaxdirectmemorysize-cant-limit-unsafe-allocatememory" target="_blank" rel="external">StackOverFlow</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：<em>本文介绍了Java内存溢出的四种形式：Java堆溢出、虚拟机栈和本地方法栈溢出、方法区和运行时常量池溢出、直接内存溢出。并对JVM堆外内存使用做了简单了介绍。</em><br><strong>Abstract</strong>: <em>This article describes the four types of memory overflow in Java: Java heap overflow, virtual machine stack and local method stack overflow, the method area and runtime constant pool overflow, direct memory overflow. And a simple introduction of off-heap memory usage.</em></p>]]>
    
    </summary>
    
      <category term="JVM" scheme="http://zuoqy.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="OOM" scheme="http://zuoqy.com/tags/OOM/"/>
    
      <category term="Java" scheme="http://zuoqy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java内存区域]]></title>
    <link href="http://zuoqy.com/2015/04/16/java-memory1/"/>
    <id>http://zuoqy.com/2015/04/16/java-memory1/</id>
    <published>2015-04-16T13:38:41.000Z</published>
    <updated>2015-04-20T03:04:07.000Z</updated>
    <content type="html"><![CDATA[<p><strong>摘要</strong>：本文主要介绍了Java运行时数据区域的划分、各个区域的职能、对象内存分配和定位方法。<br><strong>Abstract</strong>: This article describes the division of the Java runtime data area, the functions of the corresponding region, the object memory allocation and positioning methods.</p>
<a id="more"></a>
<h2 id="运行时数据区域">运行时数据区域</h2><p>JVM在程序运行过程中，会把内存划分成以下区域：<br><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-04-16/1.png" alt="img"></p>
<h3 id="程序计数器">程序计数器</h3><p>每个线程都有独立存储的程序计数器，互不影响，独立存储，属于<em>线程私有</em>内存。如果线程执行的是Java方法，计数器记录的是正在执行的虚拟机字节指令的地址；如果正在执行的时Native方法，这个计数器的值则为空(Undefined)。<br>此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h3 id="Java虚拟机栈(Java_Virtual_Machine_Stacks)">Java虚拟机栈(Java Virtual Machine Stacks)</h3><p>虚拟机栈描述的时Java方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<br>局部变量表存放了<em>编译期</em>可知的各种基本数据类型、对象引用、和返回地址类型。其所需的内存空间在<em>编译期</em>分配，运行时不会改变局部变量表的大小。<br>异常状况：1）StackOverflowError: 线程请求的栈深度大于JVM允许的深度。2）OutOfMemoryError:虚拟机栈动态扩展的时候无法申请到足够的内存。</p>
<h3 id="本地方法栈(Native_Method_Stack)">本地方法栈(Native Method Stack)</h3><p>本地方法栈为虚拟机使用到的Native方法提供栈空间，本地方法栈也有上述两种异常情况。</p>
<h3 id="Java堆">Java堆</h3><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。几乎所有的对象实例都在这里分配内存。（逃逸分析和标量替换允许在栈上分配对象内存）<br>Java堆是垃圾收集器管理的主要区域，也被成为GC堆。从内存分代回收的角度看，Java堆可以细分为：新生代和老年代；从内存分配的角度看，Java堆可能分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)</p>
<h3 id="方法区(Method_Area)">方法区(Method Area)</h3><p>线程共享内存区域，用于存储虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。HotSpot JVM用永久代(Permanent Generation)实现方法区，但两者并不等价。但这种实现方法容易导致内存溢出（可通过-XX:MaxPermSize设置永久代上限），新版的JDK1.7 Hotspot 已经把原本放在永久带的字符串常量池移出。<br>这个区域的内存回收主要针对类型的卸载和常量池的回收。异常情况：OutOfMemoryError.</p>
<h3 id="直接内存(Direct_Memory)">直接内存(Direct Memory)</h3><p>直接内存不是JVM运行时数据区域，但在Java NIO中引入了基于Channel和Buffer的I/O方式，可以直接使用Native函数库分配<em>堆外内存</em>。申请直接内存大小超过限制，同样会有OutOfMemory异常。</p>
<h3 id="新生对象内存分配方式">新生对象内存分配方式</h3><ul>
<li>指针碰撞(Bump The Pointer): 指针作为分配和未分配的界限，要求JAVA堆规整。</li>
<li>空闲列表(Free List): Java堆不规整。</li>
</ul>
<p>为了解决以上两种分配方式并发安全问题，可以采用：</p>
<ul>
<li>CAS失败重试</li>
<li>本地线程分配缓冲TLAB (配置参数：-XX:+/-UseTLAB)(只有本地缓冲用完，需要重新分配的时候才需要同步锁定)</li>
</ul>
<h2 id="对象的创建">对象的创建</h2><h3 id="对象的内存布局">对象的内存布局</h3><p>对象的内存布局可以分为三块：对象头(Header)、实例数据（Instance Data）、对齐填充（Padding）。</p>
<h4 id="对象头">对象头</h4><ul>
<li>运行时数据：HashCode、GC分代、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳。这部分数据的长度与虚拟机位数相同。官方称为<em>“MarkWord”</em></li>
<li>类型指针：确定对象是哪个类的实例。（不一定所有的虚拟机都通过保留类型指针来确定对象的类型）</li>
</ul>
<h4 id="实例数据">实例数据</h4><p>存放代码中定义的各种类型的字段内容，顺序收到JVM内存分配策略的影响，相同长度的字段往往相邻分配。</p>
<h4 id="对齐填充">对齐填充</h4><p>Hotspot虚拟机要求对象的大小是8字节的整数倍，不够的用Padding字段补全。</p>
<h3 id="对象的访问定位">对象的访问定位</h3><ul>
<li>句柄：reference中包含了对象的句柄地址，句柄中包含对象各部分的地址<br><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-04-16/2.png" alt="img"></li>
<li>直接指针：reference中直接存储对象的地址（Hotspot实现）<br><img src="http://7xi4cl.com1.z0.glb.clouddn.com/images/2015-04-16/2.png" alt="img"></li>
</ul>
<h2 id="References">References</h2><ul>
<li>图片来自：《深入理解Java虚拟机》</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>摘要</strong>：本文主要介绍了Java运行时数据区域的划分、各个区域的职能、对象内存分配和定位方法。<br><strong>Abstract</strong>: This article describes the division of the Java runtime data area, the functions of the corresponding region, the object memory allocation and positioning methods.</p>]]>
    
    </summary>
    
      <category term="JVM" scheme="http://zuoqy.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://zuoqy.com/tags/Java/"/>
    
      <category term="Java" scheme="http://zuoqy.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1576 最长严格上升子序列]]></title>
    <link href="http://zuoqy.com/2013/11/12/1576-longest-inc-subseq/"/>
    <id>http://zuoqy.com/2013/11/12/1576-longest-inc-subseq/</id>
    <published>2013-11-12T04:40:39.000Z</published>
    <updated>2015-04-21T09:34:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述_Description"><a href="http://www.wikioi.com/problem/1576/" target="_blank" rel="external">题目描述 Description</a></h2><p>非常经典的问题，拿来给大家练手了。<br>序列 { 1,2,…,n } 的一个子序列是指序列 { i1, i2, ……, ik },其中 1&lt;=i1 &lt; i2 &lt; …… &lt; ik&lt;=n, 序列 { a1, a2, ……, an } 的一个子序列是指序列 { ai1, ai2, ……, aik },其中 { i1, i2, ……, ik } 是 { 1, 2, ……, n } 的一个子序列.同时,称 k 为此子序列的长度.<br>如果 { ai1, ai2, ……, aik } 满足 ai1 ≤ ai2 ≤ …… ≤ aik,则称之为上升子序列.如果不等号都是严格成立的,则称之为严格上升子序列.同理,如果前面不等关系全部取相反方向,则称之为下降子序列和严格下降子序列.<br>长度最长的上升子序列称为最长上升子序列.本问题对于给定的整数序列,请求出其最长严格上升子序列的长度</p>
<a id="more"></a>
<p><strong>输入描述 Input Description</strong><br>第一行，一个整数N。<br>第二行 ，N个整数（N &lt; = 5000）<br><strong>输出描述 Output Description</strong><br>输出K的极大值，即最长严格上升子序列的长度<br>样例输入 Sample Input<br>5<br>9 3 6 2 7<br>样例输出 Sample Output<br>3<br>数据范围及提示 Data Size &amp; Hint<br>【样例解释】<br>最长严格上升子序列为3,6,7</p>
<h2 id="思路">思路</h2><ol>
<li>子问题描述：用dp[i] 表示到i位置为止，最长严格上升子序列的长度,a[i] 为数组中的元素</li>
<li>状态转换： 对于0&lt;=j &lt; i 先求出符合a[j] &lt; a[i] 的最大子序列长度，a[i] = max(a[j]) + 1;<br>因此： dp[i] = max(dp[j]+1. dp[i]) 0&lt;=j &lt; i &amp;&amp; a[j] &lt; a[i]</li>
</ol>
<h2 id="代码示例">代码示例</h2><pre><code><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span>
</span>{
    <span class="keyword">int</span> res = <span class="number">1</span>;
    <span class="keyword">int</span> dp[<span class="number">5009</span>]={<span class="number">1</span>};
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {
        dp[i] = <span class="number">1</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) {
            <span class="keyword">if</span> (a[j] &lt; a[i]) {
                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);
            }
        }
        <span class="keyword">if</span>(dp[i] &gt; res){
            res = dp[i];
        }
    }
    <span class="keyword">return</span> res;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述_Description"><a href="http://www.wikioi.com/problem/1576/">题目描述 Description</a></h2><p>非常经典的问题，拿来给大家练手了。<br>序列 { 1,2,…,n } 的一个子序列是指序列 { i1, i2, ……, ik },其中 1&lt;=i1 &lt; i2 &lt; …… &lt; ik&lt;=n, 序列 { a1, a2, ……, an } 的一个子序列是指序列 { ai1, ai2, ……, aik },其中 { i1, i2, ……, ik } 是 { 1, 2, ……, n } 的一个子序列.同时,称 k 为此子序列的长度.<br>如果 { ai1, ai2, ……, aik } 满足 ai1 ≤ ai2 ≤ …… ≤ aik,则称之为上升子序列.如果不等号都是严格成立的,则称之为严格上升子序列.同理,如果前面不等关系全部取相反方向,则称之为下降子序列和严格下降子序列.<br>长度最长的上升子序列称为最长上升子序列.本问题对于给定的整数序列,请求出其最长严格上升子序列的长度</p>]]>
    
    </summary>
    
      <category term="DP" scheme="http://zuoqy.com/tags/DP/"/>
    
      <category term="wikioi" scheme="http://zuoqy.com/tags/wikioi/"/>
    
      <category term="动态规划" scheme="http://zuoqy.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="coding gym" scheme="http://zuoqy.com/categories/coding-gym/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[3027 线段覆盖 2]]></title>
    <link href="http://zuoqy.com/2013/11/11/3027-segment-coverage2/"/>
    <id>http://zuoqy.com/2013/11/11/3027-segment-coverage2/</id>
    <published>2013-11-11T03:55:17.000Z</published>
    <updated>2015-04-21T09:29:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述_Description"><a href="http://www.wikioi.com/problem/3027/" target="_blank" rel="external">题目描述 Description</a></h2><p>数轴上有n条线段，线段的两端都是整数坐标，坐标范围在0~1000000，每条线段有一个价值，请从n条线段中挑出若干条线段，使得这些线段两两不覆盖（端点可以重合）且线段价值之和最大。<br>n&lt;=1000</p>
<a id="more"></a>
<p>输入描述 Input Description<br>第一行一个整数n，表示有多少条线段。<br>接下来n行每行三个整数, ai bi ci，分别代表第i条线段的左端点ai，右端点bi（保证左端点&lt;右端点）和价值ci。<br>输出描述 Output Description<br>输出能够获得的最大价值<br>样例输入 Sample Input<br>3<br>1 2 1<br>2 3 2<br>1 3 4<br>样例输出 Sample Output<br>4<br>数据范围及提示 Data Size &amp; Hint<br>数据范围<br>对于40%的数据，n≤10；<br>对于100%的数据，n≤1000；<br>0&lt;=ai,bi&lt;=1000000<br>0&lt;=ci&lt;=1000000</p>
<h2 id="思路：">思路：</h2><p>对线段按照左端点进行排序<br>子问题描述：用v[i] 表示到第i个线段为止的最大价值<br>状态迁移方程： v[i] = max(v[j]) + a[i].value (0&lt;= j &lt; i &amp;&amp; a[j].end &lt;= a[i].start)</p>
<h2 id="代码示例：">代码示例：</h2><pre><code><span class="built_in">int</span> cmp(<span class="keyword">const</span> <span class="built_in">line</span> lhs, <span class="keyword">const</span> <span class="built_in">line</span> rhs)
{
    <span class="keyword">return</span> lhs.start &lt; rhs.start;
}

<span class="built_in">int</span> cover(<span class="built_in">line</span> *a, <span class="built_in">int</span> n)
{
    <span class="built_in">sort</span>(a, a + n, cmp);
    <span class="built_in">int</span> pmax = <span class="number">0</span>;
    v[<span class="number">0</span>] = a[<span class="number">0</span>].value;
    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; i++) {
        v[i] = a[i].value;
        <span class="built_in">int</span> <span class="built_in">max</span> = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++) {
            <span class="keyword">if</span> (a[j].end &lt;= a[i].start &amp;&amp; <span class="built_in">max</span> &lt; v[j]) {
                <span class="built_in">max</span> = v[j];
            }
        }
        v[i] += <span class="built_in">max</span>;
        <span class="keyword">if</span> (pmax &lt; v[i]) {
            pmax = v[i];
        }
    }
    <span class="keyword">return</span> pmax;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述_Description"><a href="http://www.wikioi.com/problem/3027/">题目描述 Description</a></h2><p>数轴上有n条线段，线段的两端都是整数坐标，坐标范围在0~1000000，每条线段有一个价值，请从n条线段中挑出若干条线段，使得这些线段两两不覆盖（端点可以重合）且线段价值之和最大。<br>n&lt;=1000</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://zuoqy.com/tags/Algorithm/"/>
    
      <category term="DP" scheme="http://zuoqy.com/tags/DP/"/>
    
      <category term="动态规划" scheme="http://zuoqy.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="coding gym" scheme="http://zuoqy.com/categories/coding-gym/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1214 线段覆盖]]></title>
    <link href="http://zuoqy.com/2013/11/09/1214-segment-coverage/"/>
    <id>http://zuoqy.com/2013/11/09/1214-segment-coverage/</id>
    <published>2013-11-09T04:24:01.000Z</published>
    <updated>2015-04-21T09:29:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目描述_Description"><a href="http://www.wikioi.com/problem/1214/" target="_blank" rel="external">题目描述 Description</a></h2><p>给定x轴上的N（0&lt;N&lt;100）条线段，每个线段由它的二个端点a_I和b_I确定，I=1,2,……N.这些坐标都是区间（－999，999）的整数。有些线段之间会相互交叠或覆盖。请你编写一个程序，从给出的线段中去掉尽量少的线段，使得剩下的线段两两之间没有内部公共点。所谓的内部公共点是指一个点同时属于两条线段且至少在其中一条线段的内部（即除去端点的部分）。</p>
<a id="more"></a>
<p>输入描述 Input Description<br>输入第一行是一个整数N。接下来有N行，每行有二个空格隔开的整数，表示一条线段的二个端点的坐标。<br><strong>输出描述 Output Description</strong><br>输出第一行是一个整数表示最多剩下的线段数。<br><strong>样例输入 Sample Input</strong><br>3<br>6 3<br>1 3<br>2 5<br><strong>样例输出 Sample Output</strong><br>2</p>
<h2 id="动态规划思路:">动态规划思路:</h2><p>最优子结构：到j为止最多的线段数<br>子问题重叠：用f[j]数组存放重叠计算的子问题</p>
<ol>
<li>对输入的数据，把左端点放在左边</li>
<li>按左端点坐标从小到大排序</li>
<li>用数组f[j]存放到线段j为止，最多留下的线段数目，初始都是1。</li>
<li>按顺序扫描线段，如果线段j的左端点大于等于之前线段的右端点，到j最多线段数为f[i] + 1， 如果有多个这样的情况，就取f[i] + 1（i = 1….j-1）中最大的一个。</li>
</ol>
<h2 id="代码示例:">代码示例:</h2><pre><code><span class="built_in">int</span> n;
cin &gt;&gt; n;
<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++){
    cin &gt;&gt; lines[i].start;
    cin &gt;&gt; lines[i].end;
    f[i] = <span class="number">1</span>;
    <span class="keyword">if</span>(lines[i].start &gt; lines[i].end){
        swap(lines[i].start, lines[i].end);
    }
}
qsort(lines, n, sizeof(<span class="built_in">line</span>),cmp);
<span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; n; j++){<span class="comment">//scan all</span>
    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; j; i++){ 
        <span class="keyword">if</span>(lines[i].end &lt;= lines[j].start){<span class="comment">//如果与前面的不重叠</span>
            f[j] = <span class="built_in">max</span>(f[j], f[i] + <span class="number">1</span>); <span class="comment">// 取最多的线段数</span>
        }
    }
}
<span class="built_in">int</span> <span class="built_in">max</span> = <span class="number">0</span>;
<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++){
    <span class="keyword">if</span>(f[i] &gt; <span class="built_in">max</span>){
        <span class="built_in">max</span> = f[i];
    }
}
cout &lt;&lt; <span class="built_in">max</span> &lt;&lt; endl;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目描述_Description"><a href="http://www.wikioi.com/problem/1214/">题目描述 Description</a></h2><p>给定x轴上的N（0&lt;N&lt;100）条线段，每个线段由它的二个端点a_I和b_I确定，I=1,2,……N.这些坐标都是区间（－999，999）的整数。有些线段之间会相互交叠或覆盖。请你编写一个程序，从给出的线段中去掉尽量少的线段，使得剩下的线段两两之间没有内部公共点。所谓的内部公共点是指一个点同时属于两条线段且至少在其中一条线段的内部（即除去端点的部分）。</p>]]>
    
    </summary>
    
      <category term="DP" scheme="http://zuoqy.com/tags/DP/"/>
    
      <category term="wikioi" scheme="http://zuoqy.com/tags/wikioi/"/>
    
      <category term="动态规划" scheme="http://zuoqy.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="coding gym" scheme="http://zuoqy.com/categories/coding-gym/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态规划]]></title>
    <link href="http://zuoqy.com/2013/11/09/dynamic-programming/"/>
    <id>http://zuoqy.com/2013/11/09/dynamic-programming/</id>
    <published>2013-11-09T04:09:50.000Z</published>
    <updated>2015-04-21T10:05:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概念">概念</h2><p>适用于动态规划求解的问题，经过分解得到的问题往往不是相互独立的。若用分治算法来解这类问题，子问题常常被计算多次。动态规划的基本思想是，将计算过的子问题存储到一个表中，来避免重复计算。</p>
<h2 id="动态规划的基本要素">动态规划的基本要素</h2><p>最优子结构：当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构的性质。<br>重叠子问题：当采用递归的方式计算问题时，相同的子问题被重复计算多次。</p>
<h2 id="设计动态规划算法的步骤">设计动态规划算法的步骤</h2><ul>
<li>找出最优解的性质，并刻画其结构特征</li>
<li>递归定义最优值</li>
<li>自底向上的方式计算出最优值</li>
<li>根据计算最优值时得到的信息，构造最优解。</li>
</ul>
<a id="more"></a>
<h2 id="动态规划专题">动态规划专题</h2><h3 id="序列型DP">序列型DP</h3><ul>
<li><a href="/2013/11/09/1214-segment-coverage/">线段覆盖</a></li>
<li><a href="/2013/11/11/3027-segment-coverage2/">3027 线段覆盖 2</a></li>
<li><a href="/2013/11/12/1576-longest-inc-subseq/">1576 最长严格上升子序列</a></li>
</ul>
<h3 id="背包型DP">背包型DP</h3><ul>
<li><a href="http://curlcoder.com/?p=67" target="_blank" rel="external">0-1 背包问题</a></li>
<li><a href="http://curlcoder.com/2013/11/18/1068-%E4%B9%8C%E9%BE%9F%E6%A3%8B/" target="_blank" rel="external">1068 乌龟棋</a></li>
</ul>
<p>(未完待续)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概念">概念</h2><p>适用于动态规划求解的问题，经过分解得到的问题往往不是相互独立的。若用分治算法来解这类问题，子问题常常被计算多次。动态规划的基本思想是，将计算过的子问题存储到一个表中，来避免重复计算。</p>
<h2 id="动态规划的基本要素">动态规划的基本要素</h2><p>最优子结构：当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构的性质。<br>重叠子问题：当采用递归的方式计算问题时，相同的子问题被重复计算多次。</p>
<h2 id="设计动态规划算法的步骤">设计动态规划算法的步骤</h2><ul>
<li>找出最优解的性质，并刻画其结构特征</li>
<li>递归定义最优值</li>
<li>自底向上的方式计算出最优值</li>
<li>根据计算最优值时得到的信息，构造最优解。</li>
</ul>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://zuoqy.com/tags/Algorithm/"/>
    
      <category term="DP" scheme="http://zuoqy.com/tags/DP/"/>
    
      <category term="动态规划" scheme="http://zuoqy.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Algorithm" scheme="http://zuoqy.com/categories/Algorithm/"/>
    
  </entry>
  
</feed>